<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>XANDER Studio</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XANDER Studio"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XANDER Studio"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Stay Foolish, Stay Hungery..."><meta property="og:type" content="website"><meta property="og:title" content="XANDER Studio"><meta property="og:url" content="https://xuanhe95.github.io/"><meta property="og:site_name" content="XANDER Studio"><meta property="og:description" content="Stay Foolish, Stay Hungery..."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xuanhe95.github.io/img/og_image.png"><meta property="article:author" content="Xuanhe"><meta property="article:tag" content="studio, blog"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuanhe95.github.io"},"headline":"XANDER Studio","image":["https://xuanhe95.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xuanhe"},"publisher":{"@type":"Organization","name":"XANDER Studio","logo":{"@type":"ImageObject"}},"description":"Stay Foolish, Stay Hungery..."}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">XANDER Studio</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-01T10:03:36.000Z" title="2022/5/1 下午6:03:36">2022-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-01T10:03:36.881Z" title="2022/5/1 下午6:03:36">2022-05-01</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/01/91-Decode-Ways/">91. Decode Ways</a></h1><div class="content"><blockquote>
<p>A message containing letters from A-Z can be encoded into numbers using the following mapping:</p>
<p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into:</p>
<ul>
<li>“AAJF” with the grouping (1 1 10 6)</li>
<li>“KJF” with the grouping (11 10 6)<br>Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”.</li>
</ul>
<p>Given a string s containing only digits, return the number of ways to decode it.</p>
<p>The test cases are generated so that the answer fits in a 32-bit integer.</p>
</blockquote>
<p>动态规划。转移方程的考虑比较麻烦。<br>当当前的字符不为0时，该为可以自己组成有效编码，因此dp[i] &#x3D; dp[i-1]。<br>然后考虑上一位可以和当前位组成有效编码的情况，如果上一位和当前位的数字小于26，且上一位不等于0，则可以联合编码。<br>因此dp需要再加上前一位可以组成的编码数，即dp[i] +&#x3D; dp[i-2]。<br>当i等于1时，由于会越界因此我们手动给dp[i]++。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[]dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span> )&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span>) dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-30T16:40:13.000Z" title="2022/5/1 上午12:40:13">2022-05-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-01T10:39:01.268Z" title="2022/5/1 下午6:39:01">2022-05-01</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/01/399-Evaluate-Division/">399. Evaluate Division</a></h1><div class="content"><blockquote>
<p>You are given an array of variable pairs equations and an array of real numbers values, where equations[i] &#x3D; [Ai, Bi] and values[i] represent the equation Ai &#x2F; Bi &#x3D; values[i]. Each Ai or Bi is a string that represents a single variable.</p>
<p>You are also given some queries, where queries[j] &#x3D; [Cj, Dj] represents the jth query where you must find the answer for Cj &#x2F; Dj &#x3D; ?.</p>
<p>Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p>
<p>Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>
</blockquote>
<p>这道题的核心是边上带权的并查集。<br>如何在find以及union时计算并更新权重是最重要的。<br>组合过后，根节点的权重依然为1，以其为标准更新其他节点的权重。</p>
<p>先通过一个哈希表建立字符串与id的映射关系，为每个字符串生成一个单独的id。</p>
<p>然后将一个equation里的两个字符串进行union操作。<br>并查集初始化时，所有权重为1。</p>
<p>在find时，执行路径压缩时需要用当前的权重weight[id]更新为其自身乘以其上一级的权重weight[origin]。<br>这里需要注意计算的顺序需要从根上的权重，以递归的形式计算到当前权重。<br>因此我们需要先单独保存parents[id]的位置。然后find(parents[id])，先计算出其上级的weight。<br>最后再将weight[id]更新为更新后的上一级的权重乘以自身权重。<br><img src="https://pic.leetcode-cn.com/1609861645-DbxMDs-image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> parents[id];</span><br><span class="line">parents[id] = find(parents[id]);</span><br><span class="line">weight[id] *= weight[origin];</span><br></pre></td></tr></table></figure>
<p>在union时，将两个集合中的一个的根指向另一个。<br>例如当结合a与b两个节点时，我们已经计算过了(a -&gt; b)的权重关系，以及(d -&gt; c)的权重关系。<br>我们将(b -&gt; d)。这时我们可以通过values[i]得到(a -&gt; d)的权重关系。因此我们可以据此得出以下公式：</p>
<p><strong>weight[(b-&gt;c)] &#x3D; weight[(d-&gt;c)] × values[(a-&gt;d)]&#x2F;weight[(a-&gt;b)]</strong></p>
<p><img src="https://pic.leetcode-cn.com/1609862151-XZgKGY-image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parents[p1] = parents[p2];</span><br><span class="line">weight[p1] = weight[id2]*val/weight[id1];</span><br></pre></td></tr></table></figure>
<p>最后，当所有节点都被合并后，我们可以遍历queries。<br>从哈希表获得对应字符串的id。<br>当有字符串未在哈希表中时，返回-1.0。<br>否则计算两个id对应的权重，并添加到答案中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="type">double</span>[] ret = <span class="keyword">new</span> <span class="title class_">double</span>[queries.size()];</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(equations.size() * <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; equations.size(); i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>( !map.containsKey( var1 ) )&#123;</span><br><span class="line">                map.put( var1, id );</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !map.containsKey( var2 ) )&#123;</span><br><span class="line">                map.put( var2, id );</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            uf.union(map.get(var1), map.get(var2), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; queries.size(); i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">var1</span> <span class="operator">=</span> queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">var2</span> <span class="operator">=</span> queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id1</span> <span class="operator">=</span> map.get(var1);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id2</span> <span class="operator">=</span> map.get(var2);</span><br><span class="line">            <span class="keyword">if</span>(id1 == <span class="literal">null</span> || id2 == <span class="literal">null</span>) ret[i] = -<span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">else</span> ret[i] = uf.isConnected(id1, id2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] parents;</span><br><span class="line">        <span class="type">double</span>[] weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            parents = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            weight = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parents.length; i++)&#123;</span><br><span class="line">                parents[i] = i;</span><br><span class="line">                weight[i] = <span class="number">1.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (id != parents[id]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> parents[id];</span><br><span class="line">                parents[id] = find(parents[id]);</span><br><span class="line">                weight[id] *= weight[origin];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parents[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2, <span class="type">double</span> val)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> find(id1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> find(id2);</span><br><span class="line">            <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            parents[p1] = parents[p2];</span><br><span class="line">            weight[p1] = weight[id2]*val/weight[id1];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> id1, <span class="type">int</span> id2)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> find(id1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> find(id2);</span><br><span class="line">            <span class="keyword">if</span>(p1 == p2) <span class="keyword">return</span> weight[id1] / weight[id2];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T18:03:52.000Z" title="2022/4/30 上午2:03:52">2022-04-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-29T18:03:52.718Z" title="2022/4/30 上午2:03:52">2022-04-30</time></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/1823-Find-the-Winner-of-the-Circular-Game/">1823. Find the Winner of the Circular Game</a></h1><div class="content"><blockquote>
<p>There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 &lt;&#x3D; i &lt; n, and moving clockwise from the nth friend brings you to the 1st friend.</p>
<p>The rules of the game are as follows:</p>
<ul>
<li>1.Start at the 1st friend.</li>
<li>2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.</li>
<li>3.The last friend you counted leaves the circle and loses the game.</li>
<li>4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.</li>
<li>5.Else, the last friend in the circle wins the game.<br>Given the number of friends, n, and an integer k, return the winner of the game.</li>
</ul>
</blockquote>
<p><img src="https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png"></p>
<p>约瑟夫环问题。<br>根据题目要求，当去除一个成员时，下一个节点的编号为k+1。<br>当新的循环开始时，总人数n-1，同时k+1变为新循环中的1。</p>
<p>因此可以采用递归，当n剩下一个人时，返回其编号1。<br>对应上层这个成员的位置为k+1，向上递归。<br>由于k+1可以越界，因此每次返回需要对其取模。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheWinner</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> findTheWinner(n-<span class="number">1</span>, k) + k;</span><br><span class="line">        <span class="keyword">return</span> ans % n == <span class="number">0</span> ? n : ans % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T17:20:02.000Z" title="2022/4/30 上午1:20:02">2022-04-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-29T17:20:02.492Z" title="2022/4/30 上午1:20:02">2022-04-30</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/1249-Minimum-Remove-to-Make-Valid-Parentheses/">1249. Minimum Remove to Make Valid Parentheses</a></h1><div class="content"><blockquote>
<p>Given a string s of ‘(‘ , ‘)’ and lowercase English characters.</p>
<p>Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string.</p>
<p>Formally, a parentheses string is valid if and only if:</p>
<ul>
<li>It is the empty string, contains only lowercase characters, or</li>
<li>It can be written as AB (A concatenated with B), where A and B are valid strings, or</li>
<li>It can be written as (A), where A is a valid string.</li>
</ul>
</blockquote>
<p>用栈储存括号，按顺序将括号压入栈。<br>如果和上一个括号配对，则挤出上一个括号。</p>
<p>当栈不为空时，如果栈顶的符号为“)”，则优先去掉字符串左侧的括号。<br>如果栈顶的符号为“(”，则优先去掉字符串右侧的括号。<br>最后返回字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minRemoveToMakeValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) stack.push(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == <span class="string">&#x27;(&#x27;</span>) stack.pop();</span><br><span class="line">                <span class="keyword">else</span> stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.pop() == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sb.indexOf(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                sb.delete(index, index+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sb.lastIndexOf(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                sb.delete(index, index+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T16:36:59.000Z" title="2022/4/30 上午12:36:59">2022-04-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-29T16:36:59.127Z" title="2022/4/30 上午12:36:59">2022-04-30</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/30/155-Min-Stack/">155. Min Stack</a></h1><div class="content"><blockquote>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>Implement the MinStack class:</p>
<ul>
<li>MinStack() initializes the stack object.</li>
<li>void push(int val) pushes the element val onto the stack.</li>
<li>void pop() removes the element on the top of the stack.</li>
<li>int top() gets the top element of the stack.</li>
<li>int getMin() retrieves the minimum element in the stack.</li>
</ul>
</blockquote>
<p>分别将数据保存在一个Priority Queue和一个栈中。<br>pop方法pop掉stack的内容，然后将其从优先队列中移除。<br>top方法返回stack的栈顶。<br>getMin方法返回优先队列的顶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; pq;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        pq.add(val);</span><br><span class="line">        stack.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        pq.remove(i);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T15:28:02.000Z" title="2022/4/29 下午11:28:02">2022-04-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-29T15:29:02.726Z" title="2022/4/29 下午11:29:02">2022-04-29</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/29/413-Arithmetic-Slices/">413. Arithmetic Slices</a></h1><div class="content"><blockquote>
<p>An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<ul>
<li>For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.<br>Given an integer array nums, return the number of arithmetic subarrays of nums.</li>
</ul>
<p>A subarray is a contiguous subsequence of the array.</p>
</blockquote>
<p>动态规划，遍历一次记录所有数字的差。<br>然后遍历并计算连续相同的数字数量temp。<br>当不相同时，则计算temp长度可以选择的组合数，将其添加到count。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] difference = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            difference[i] = nums[i+<span class="number">1</span>] - nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> difference[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; nums.length-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(difference[j] == prev)&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count += combinations(temp);</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = difference[j];</span><br><span class="line">        &#125;</span><br><span class="line">        count += combinations(temp);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">combinations</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n * (n-<span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T14:39:11.000Z" title="2022/4/29 下午10:39:11">2022-04-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-29T14:39:11.236Z" title="2022/4/29 下午10:39:11">2022-04-29</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/29/62-Unique-Paths/">62. Unique Paths</a></h1><div class="content"><blockquote>
<p>There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p>
<p>The test cases are generated so that the answer will be less than or equal to 2 * 109.</p>
</blockquote>
<p>动态规划，每一个位置的线路都等于其左侧和上侧的两条线路的加和。<br>将初始的两个边值设置为1，然后计算直至终点位置即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-29T11:29:28.000Z" title="2022/4/29 下午7:29:28">2022-04-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-29T11:29:28.126Z" title="2022/4/29 下午7:29:28">2022-04-29</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/29/785-Is-Graph-Bipartite/">785. Is Graph Bipartite?</a></h1><div class="content"><blockquote>
<p>There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:</p>
<ul>
<li>There are no self-edges (graph[u] does not contain u).</li>
<li>There are no parallel edges (graph[u] does not contain duplicate values).</li>
<li>If v is in graph[u], then u is in graph[v] (the graph is undirected).</li>
<li>The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.<br>A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.</li>
</ul>
<p>Return true if and only if it is bipartite.</p>
</blockquote>
<p>原题等于问：每个节点与其相连接的节点是否可以颜色不同？<br>通过BFS搜索，将每一层通过开关flag分组。<br>创建一个visited数组，记录分组和遍历情况。<br>当节点被放入错误的分组时，返回false。</p>
<p>注意因为图里的各个节点可能不连接，因此需要遍历对所有节点进行BFS搜索，通过visited的情况进行剪枝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph.length; i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(graph[i].length == <span class="number">0</span> || visited[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q.add(graph[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                    <span class="type">int</span>[] node = q.poll();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> next : node)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(visited[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                            q.add(graph[next]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(visited[next] == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                            visited[next] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">if</span>(visited[next] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                            visited[next] = <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = !flag;</span><br><span class="line">                size = q.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-28T15:30:35.000Z" title="2022/4/28 下午11:30:35">2022-04-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-28T15:37:09.937Z" title="2022/4/28 下午11:37:09">2022-04-28</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/28/1631-Path-With-Minimum-Effort/">1631. Path With Minimum Effort</a></h1><div class="content"><blockquote>
<p>You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</p>
<p>A route’s effort is the maximum absolute difference in heights between two consecutive cells of the route.</p>
<p>Return the minimum effort required to travel from the top-left cell to the bottom-right cell.</p>
</blockquote>
<p>A*算法，启发式搜索。BFS搜索结合Priority Queue。<br>采用一个数组储存当前访问点的位置，以及其effort。<br>采用优先队列，优先搜索effort最小的方向。<br>每次循环倾倒出队列中所有的元素。<br>计算上一个节点和当前节点的差值作为nextEffort，并和上一个节点的effort作比较，较大的作为当前节点的effort，<br>将effort作为权重，优先搜索一个层级内effort较小的路径。<br>将所有操作加入队列，并排除越界的位置。<br>当当前节点为最后一个节点时，返回其effort。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] operations = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights.length, n = heights[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span>[] point = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] visited = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        q.add(point);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curr[<span class="number">0</span>], j = curr[<span class="number">1</span>], currEffort = curr[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                visited[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == m-<span class="number">1</span> &amp;&amp; j == n-<span class="number">1</span>) <span class="keyword">return</span> currEffort;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span>[] operation : operations)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> i + operation[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> j + operation[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nextX &lt; <span class="number">0</span> || nextY &lt; <span class="number">0</span> || nextX &gt;= m || nextY &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextEffort</span> <span class="operator">=</span> Math.max(currEffort, Math.abs(heights[i][j] - heights[nextX][nextY]));</span><br><span class="line">                    <span class="type">int</span>[] next = &#123;nextX, nextY, nextEffort&#125;;</span><br><span class="line">                    </span><br><span class="line">                    q.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-28T03:13:28.000Z" title="2022/4/28 上午11:13:28">2022-04-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-28T03:13:28.404Z" title="2022/4/28 上午11:13:28">2022-04-28</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/28/45-Jump-Game-II/">45. Jump Game II</a></h1><div class="content"><blockquote>
<p>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>You can assume that you can always reach the last index.</p>
</blockquote>
<p>设置一个当前可以访问的最大范围limit，在遍历中对其进行更新。<br>和当前可访问位置中的最远距离end，每次访问到达end时，计算步数。</p>
<p>遍历数组，比较limit和当前i能访问的最远距离i+nums[i]，保留较大值。<br>当i达到end时，更新end为之前记录的可访问最远距离limit。步数+1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            limit = Math.max(limit, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                end = limit;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">Previous</a></div><div class="pagination-next"><a href="/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/16/">16</a></li></ul></nav></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">XANDER Studio</a><p class="is-size-7"><span>&copy; 2022 Xuanhe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>