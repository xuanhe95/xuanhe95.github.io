<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>XANDER Studio</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XANDER Studio"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XANDER Studio"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Stay Foolish, Stay Hungery..."><meta property="og:type" content="website"><meta property="og:title" content="XANDER Studio"><meta property="og:url" content="https://xuanhe95.github.io/"><meta property="og:site_name" content="XANDER Studio"><meta property="og:description" content="Stay Foolish, Stay Hungery..."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xuanhe95.github.io/img/og_image.png"><meta property="article:author" content="Xuanhe"><meta property="article:tag" content="studio, blog"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuanhe95.github.io"},"headline":"XANDER Studio","image":["https://xuanhe95.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xuanhe"},"publisher":{"@type":"Organization","name":"XANDER Studio","logo":{"@type":"ImageObject"}},"description":"Stay Foolish, Stay Hungery..."}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">XANDER Studio</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-24T09:18:13.000Z" title="2022/4/24 下午5:18:13">2022-04-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-24T09:18:14.055Z" title="2022/4/24 下午5:18:14">2022-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/24/1396-Design-Underground-System/">1396. Design Underground System</a></h1><div class="content"><blockquote>
<p>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.</p>
<p>Implement the UndergroundSystem class:</p>
<ul>
<li>void checkIn(int id, string stationName, int t)</li>
<li><ul>
<li>A customer with a card ID equal to id, checks in at the station stationName at time t.</li>
</ul>
</li>
<li><ul>
<li>A customer can only be checked into one place at a time.</li>
</ul>
</li>
<li>void checkOut(int id, string stationName, int t)</li>
<li><ul>
<li>A customer with a card ID equal to id, checks out from the station stationName at time t.</li>
</ul>
</li>
<li>double getAverageTime(string startStation, string endStation)</li>
<li><ul>
<li>Returns the average time it takes to travel from startStation to endStation.</li>
</ul>
</li>
<li><ul>
<li>The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation.</li>
</ul>
</li>
<li><ul>
<li>The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation.</li>
</ul>
</li>
<li><ul>
<li>There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.<br>You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 &lt; t2. All events happen in chronological order.</li>
</ul>
</li>
</ul>
</blockquote>
<p>两个哈希表，第一个暂存id。第二个用来储存“站点——站点”和路线中的总用时，路线中的总人数。<br>最后返回总用时除以总人数。<br>（一开始采用的算法没有考虑id重复进站，和id出站进站不同的情况。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UndergroundSystem</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Pair&lt;String, Integer&gt;&gt; inMap;</span><br><span class="line">    HashMap&lt;String, <span class="type">int</span>[]&gt; outMap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UndergroundSystem</span><span class="params">()</span> &#123;</span><br><span class="line">        inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Pair&lt;String, Integer&gt;&gt;();</span><br><span class="line">        outMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, <span class="type">int</span>[]&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkIn</span><span class="params">(<span class="type">int</span> id, String stationName, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        Pair&lt;String, Integer&gt; data = <span class="keyword">new</span> <span class="title class_">Pair</span>(stationName, t);</span><br><span class="line">        inMap.put(id, data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkOut</span><span class="params">(<span class="type">int</span> id, String stationName, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        Pair&lt;String, Integer&gt; data = inMap.get(id);</span><br><span class="line">        <span class="type">String</span> <span class="variable">route</span> <span class="operator">=</span> data.getKey() + <span class="string">&quot;-&quot;</span> + stationName;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span>[] routeData = outMap.getOrDefault(route, <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]);</span><br><span class="line">        routeData[<span class="number">0</span>] += t - data.getValue();</span><br><span class="line">        routeData[<span class="number">1</span>]++;</span><br><span class="line">    </span><br><span class="line">        outMap.put(route, routeData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAverageTime</span><span class="params">(String startStation, String endStation)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">route</span> <span class="operator">=</span> startStation + <span class="string">&quot;-&quot;</span> + endStation;</span><br><span class="line">        <span class="keyword">return</span> outMap.get(route)[<span class="number">0</span>] / (<span class="type">double</span>) outMap.get(route)[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * UndergroundSystem obj = new UndergroundSystem();</span></span><br><span class="line"><span class="comment"> * obj.checkIn(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * obj.checkOut(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * double param_3 = obj.getAverageTime(startStation,endStation);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-23T17:39:41.000Z" title="2022/4/24 上午1:39:41">2022-04-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-24T15:29:26.730Z" title="2022/4/24 下午11:29:26">2022-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/24/78-Subsets/">78. Subsets</a></h1><div class="content"><blockquote>
<p>Given an integer array nums of unique elements, return all possible subsets (the power set).</p>
<p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>
</blockquote>
<p>回溯，先添加一个空集，然后回溯各个单独节点。<br>递归时传入数组内当前数字之后的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            backtrack(ret, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, <span class="type">int</span>[] nums, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">            arr.add(nums[i]);</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr.add(nums[i]);</span><br><span class="line">        ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            backtrack(ret, arr, nums, j);</span><br><span class="line">            arr.remove(arr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-23T10:48:37.000Z" title="2022/4/23 下午6:48:37">2022-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-23T10:50:19.296Z" title="2022/4/23 下午6:50:19">2022-04-23</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/23/43-Multiply-Strings/">43. Multiply Strings</a></h1><div class="content"><blockquote>
<p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p>
<p>Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>
</blockquote>
<p>两个字符串的位数做乘法，每次计算进位。<br>当前位等于自身加上计算结果的个位（由于有之前的进位存在。），下一位等于计算结果的十位。<br><img src="https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> num1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num2.length();</span><br><span class="line">        <span class="keyword">if</span>( num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] product = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] arr1 = num1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] arr2 = num2.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n-<span class="number">1</span>; j &gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> product[i+j+<span class="number">1</span>] + (arr1[i] - <span class="string">&#x27;0&#x27;</span>) * (arr2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> sum % <span class="number">10</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> sum / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">                product[i+j] += carry;</span><br><span class="line">                product[i+j+<span class="number">1</span>] = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; m+n; k++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span> &amp;&amp; product[k] == <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">            sb.append(product[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-23T08:42:03.000Z" title="2022/4/23 下午4:42:03">2022-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-23T08:42:03.118Z" title="2022/4/23 下午4:42:03">2022-04-23</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/23/49-Group-Anagrams/">49. Group Anagrams</a></h1><div class="content"><blockquote>
<p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p>
<p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>
<p>利用JAVA中字符串会固定内存地址。（因此在进行字符串操作时是生成了新的对象。）<br>遍历每个单词，记录26个字母出现的次数，并映射到字符数组上。<br>将字符数组转换成字符串，生成一个新的字符串。</p>
<p>将字符串作为key放入map中，value储存原有单词。（字符串的内存地址固定，因此同样的字符串可以被搜索到。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String word : strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] alphabet = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; word.length(); j++)&#123;</span><br><span class="line">                alphabet[word.charAt(j)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(alphabet);</span><br><span class="line">            List&lt;String&gt; str = map.getOrDefault(s, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            str.add(word);</span><br><span class="line">            map.put(s, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            ret.add(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-23T07:24:40.000Z" title="2022/4/23 下午3:24:40">2022-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-23T07:30:48.041Z" title="2022/4/23 下午3:30:48">2022-04-23</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/23/797-All-Paths-From-Source-to-Target/">797. All Paths From Source to Target</a></h1><div class="content"><blockquote>
<p>Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.</p>
<p>The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).</p>
</blockquote>
<p>回溯。DFS搜索所有的路径。<br>当搜索到最后一个位置时，保存动态数组并返回。（此处需要深拷贝数组。）<br>回到上一层，取走动态数组的最后一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(ret, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, <span class="type">int</span>[][] graph, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( i == graph.length - <span class="number">1</span>)&#123;</span><br><span class="line">            arr.add(i);</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.add(i);</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> j : graph[i] )&#123;</span><br><span class="line">            dfs(ret, arr, graph, j);</span><br><span class="line">            arr.remove(arr.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-23T05:52:46.000Z" title="2022/4/23 下午1:52:46">2022-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-23T05:52:46.673Z" title="2022/4/23 下午1:52:46">2022-04-23</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/23/535-Encode-and-Decode-TinyURL/">535. Encode and Decode TinyURL</a></h1><div class="content"><blockquote>
<p>Note: This is a companion problem to the System Design problem: Design TinyURL.<br>TinyURL is a URL shortening service where you enter a URL such as <a target="_blank" rel="noopener" href="https://leetcode.com/problems/design-tinyurl">https://leetcode.com/problems/design-tinyurl</a> and it returns a short URL such as <a target="_blank" rel="noopener" href="http://tinyurl.com/4e9iAk">http://tinyurl.com/4e9iAk</a>. Design a class to encode a URL and decode a tiny URL.</p>
<p>There is no restriction on how your encode&#x2F;decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>
<p>Implement the Solution class:</p>
<ul>
<li>Solution() Initializes the object of the system.</li>
<li>String encode(String longUrl) Returns a tiny URL for the given longUrl.</li>
<li>String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object.</li>
</ul>
</blockquote>
<p>计算传入连接的哈希值。将其作为key放入map中。<br>解码时将url转换为key，取出map中的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(String longUrl)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> longUrl.hashCode();</span><br><span class="line">        map.put(key, longUrl);</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decode</span><span class="params">(String shortUrl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(Integer.parseInt(shortUrl));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.decode(codec.encode(url));</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-22T16:18:58.000Z" title="2022/4/23 上午12:18:58">2022-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-22T16:18:58.096Z" title="2022/4/23 上午12:18:58">2022-04-23</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/23/1091-Shortest-Path-in-Binary-Matrix/">1091. Shortest Path in Binary Matrix</a></h1><div class="content"><blockquote>
<p>Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.</p>
<p>A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:</p>
<p>All the visited cells of the path are 0.<br>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).<br>The length of a clear path is the number of visited cells of this path.</p>
</blockquote>
<p>由于不能重复搜索，且需要在搜索时将搜索过的位置改变，因此需要采用BFS逐一层级的搜索。<br>逐层级搜索并记录层级。最后返回层级+1即可。<br>（还有更快的优化算法A*）</p>
<p>整体没有改变太多，基本还是方法二那种。启发式函数改为切比雪夫距离距离。<br>距离计算方法有很多，常用启发式函数有这几种。选择合适的启发式函数有利于速度的提升。这题可以用好几种启发式函数，初学都可以试着都写一下。</p>
<p>曼哈顿距离（Manhattan Distance）<br>一般只能在四个方向上移动时用（右、左、上、下）</p>
<p>对角线距离（Diagonal Distance）：<br>当我们只允许向八个方向移动时用（国际象棋中的王移动方式那种）</p>
<p>欧几里得距离（Euclidean Distance）：<br>不受限制，允许向任何方向移动时。</p>
<p>切比雪夫距离（Chebyshev Distance）：<br>可参考：[<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/]">https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/]</a>(LeetCode 1266)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathBinaryMatrix</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        q.add(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curr / n;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> curr % n;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] ==<span class="number">1</span>) <span class="keyword">continue</span>;                </span><br><span class="line">                <span class="keyword">if</span>(i == m-<span class="number">1</span> &amp;&amp; j == n-<span class="number">1</span> &amp;&amp; grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; j+<span class="number">1</span>&lt;n) q.add((i+<span class="number">1</span>) * n + (j+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; j-<span class="number">1</span>&gt;=<span class="number">0</span>) q.add((i+<span class="number">1</span>) * n + (j-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n) q.add((i+<span class="number">1</span>) * n + j);</span><br><span class="line">                    <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; j-<span class="number">1</span>&gt;=<span class="number">0</span>) q.add((i-<span class="number">1</span>) * n + (j-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; j+<span class="number">1</span>&lt;n) q.add((i-<span class="number">1</span>) * n + (j+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n) q.add(i * n + (j+<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span>) q.add(i * n + (j-<span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span>) q.add((i-<span class="number">1</span>) * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            size = q.size();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-21T17:23:40.000Z" title="2022/4/22 上午1:23:40">2022-04-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-21T17:23:40.358Z" title="2022/4/22 上午1:23:40">2022-04-22</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/22/572-Subtree-of-Another-Tree/">572. Subtree of Another Tree</a></h1><div class="content"><blockquote>
<p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</p>
<p>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself.</p>
</blockquote>
<p>帮助方法isEqual，DFS搜索判断两个节点的子节点是否完全相同。<br>DFS搜索，如果两个根节点的值相等则返回，且调用isEqual方法，如果子节点都相同则返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, subRoot) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == subRoot.val &amp;&amp; isEqual(root, subRoot)) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(dfs(root.left, subRoot) != <span class="literal">null</span> ) <span class="keyword">return</span> dfs(root.left, subRoot);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dfs(root.right, subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(TreeNode root, TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || subRoot == <span class="literal">null</span>) <span class="type">return</span> <span class="variable">root</span> <span class="operator">=</span>= subRoot;</span><br><span class="line">        <span class="keyword">if</span>(root.val != subRoot.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isEqual(root.left, subRoot.left) &amp;&amp; isEqual(root.right, subRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-21T10:54:00.000Z" title="2022/4/21 下午6:54:00">2022-04-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-21T10:54:00.419Z" title="2022/4/21 下午6:54:00">2022-04-21</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/21/117-Populating-Next-Pointers-in-Each-Node-II/">117. Populating Next Pointers in Each Node II</a></h1><div class="content"><blockquote>
<p>Given a binary tree</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> struct Node &#123;</span><br><span class="line"> <span class="type">int</span> val;</span><br><span class="line"> Node *left;</span><br><span class="line"> Node *right;</span><br><span class="line"> Node *next;</span><br><span class="line">&#125;</span><br><span class="line">```java</span><br><span class="line">Populate each next pointer to point to its next right node. If &gt; there is no next right node, the next pointer should be set to NULL.</span><br><span class="line"></span><br><span class="line">Initially, all next pointers are set to NULL.</span><br><span class="line"></span><br><span class="line">BFS搜索，从右至左将每层节点放入队列。</span><br><span class="line">用一个size记录该层级放入节点的数量，每次循环将size-<span class="number">1</span>，当size归零时放入新一层级的节点。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">   public int val;</span></span><br><span class="line"><span class="comment">   public Node left;</span></span><br><span class="line"><span class="comment">   public Node right;</span></span><br><span class="line"><span class="comment">   public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">       val = _val;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">       val = _val;</span></span><br><span class="line"><span class="comment">       left = _left;</span></span><br><span class="line"><span class="comment">       right = _right;</span></span><br><span class="line"><span class="comment">       next = _next;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">       </span><br><span class="line">       Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">       q.add(root);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">           <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">               curr.next = next;</span><br><span class="line">               next = curr;</span><br><span class="line">               <span class="keyword">if</span>(curr.right != <span class="literal">null</span>) q.add(curr.right);</span><br><span class="line">               <span class="keyword">if</span>(curr.left != <span class="literal">null</span>) q.add(curr.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-21T10:24:54.000Z" title="2022/4/21 下午6:24:54">2022-04-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-21T10:30:51.770Z" title="2022/4/21 下午6:30:51">2022-04-21</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/21/763-Partition-Labels/">763. Partition Labels</a></h1><div class="content"><blockquote>
<p>You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p>
<p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s.</p>
<p>Return a list of integers representing the size of these parts.</p>
</blockquote>
<p>将英文字母出现的首尾作为intervals看待。<br>根据字符创建数组并填入左右的index。<br>根据左侧index排序数组。</p>
<p>从左至右，如果intervals有交集，则合并。<br>否则在答案中添加当前interval的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] alphabet = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(head != index &amp;&amp; alphabet[index][<span class="number">0</span>] == <span class="number">0</span>) alphabet[index][<span class="number">0</span>] = i;</span><br><span class="line">            alphabet[index][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(alphabet, (a,b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span>[] hold = alphabet[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; alphabet.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(alphabet[i][<span class="number">0</span>] &lt;= hold[<span class="number">1</span>])&#123;</span><br><span class="line">                hold[<span class="number">1</span>] = Math.max(hold[<span class="number">1</span>], alphabet[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.add(hold[<span class="number">1</span>]-hold[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">                hold = alphabet[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(hold[<span class="number">1</span>]-hold[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">Previous</a></div><div class="pagination-next"><a href="/page/6/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/16/">16</a></li></ul></nav></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">XANDER Studio</a><p class="is-size-7"><span>&copy; 2022 Xuanhe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>