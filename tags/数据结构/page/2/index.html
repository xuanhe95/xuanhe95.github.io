<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><title>Tag: 数据结构 - XANDER Studio</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="XANDER Studio"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="XANDER Studio"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Stay Foolish, Stay Hungery..."><meta property="og:type" content="website"><meta property="og:title" content="XANDER Studio"><meta property="og:url" content="https://xuanhe95.github.io/"><meta property="og:site_name" content="XANDER Studio"><meta property="og:description" content="Stay Foolish, Stay Hungery..."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xuanhe95.github.io/img/og_image.png"><meta property="article:author" content="Xuanhe"><meta property="article:tag" content="studio, blog"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuanhe95.github.io"},"headline":"XANDER Studio","image":["https://xuanhe95.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xuanhe"},"publisher":{"@type":"Organization","name":"XANDER Studio","logo":{"@type":"ImageObject"}},"description":"Stay Foolish, Stay Hungery..."}</script><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">XANDER Studio</a></div><div class="navbar-menu"><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">数据结构</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-13T06:51:42.000Z" title="2022/4/13 下午2:51:42">2022-04-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-13T06:55:58.540Z" title="2022/4/13 下午2:55:58">2022-04-13</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/13/102-Binary-Tree-Level-Order-Traversal/">102. Binary Tree Level Order Traversal</a></h1><div class="content"><blockquote>
<p><strong>问题</strong><br>Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level).</p>
</blockquote>
<p>BFS搜索，用队列储存树节点。<br>每次循环情到出一个层级所有的节点并放入列表。<br><strong>注意</strong>：需要记录队列的size，否则在for each循环时队列size会改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        q.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                temp.add(curr.val);</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)&#123;q.offer(curr.left);&#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)&#123;q.offer(curr.right);&#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-11T20:29:21.000Z" title="2022/4/12 上午4:29:21">2022-04-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-11T20:29:33.992Z" title="2022/4/12 上午4:29:33">2022-04-12</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/12/232-Implement-Queue-using-Stacks/">232. Implement Queue using Stacks</a></h1><div class="content"><blockquote>
<p><strong>问题</strong><br>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).</p>
<p>Implement the MyQueue class:</p>
<ul>
<li><p>void push(int x) Pushes element x to the back of the queue.</p>
</li>
<li><p>int pop() Removes the element from the front of the queue and returns it.</p>
</li>
<li><p>int peek() Returns the element at the front of the queue.</p>
</li>
<li><p>boolean empty() Returns true if the queue is empty, false otherwise.<br>Notes:</p>
</li>
<li><p>You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid.</p>
</li>
<li><p>Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations.</p>
</li>
</ul>
</blockquote>
<p>创建两个栈。<br>当入队列时，将元素压入第一个栈。<br>当出队列或进行其他操作时，如第二个栈为空，则将第一个栈的元素倒出到第二个栈。<br>此时第二个栈内的内容为顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1;</span><br><span class="line">    Stack&lt;Integer&gt; s2;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        s1.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">                s2.add(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">                s2.add(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-10T06:29:14.000Z" title="2022/4/10 下午2:29:14">2022-04-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-02T17:51:35.079Z" title="2022/5/3 上午1:51:35">2022-05-03</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/">116. Populating Next Right Pointers in Each Node</a></h1><div class="content"><blockquote>
<p>问题<br>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> struct Node &#123;</span><br><span class="line"> <span class="type">int</span> val;</span><br><span class="line"> Node *left;</span><br><span class="line"> Node *right;</span><br><span class="line"> Node *next;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
</blockquote>
<p>递归，当root为null时返回。<br>如果root有右节点，则左节点next指向右节点。<br>如果root有右节点同时next已经指向了一个节点，则将其右节点next指向该节点的左子节点。<br>递归左右子节点，并返回root。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>)&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">            <span class="keyword">if</span> (root.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        connect(root.left);</span><br><span class="line">        connect(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>BFS搜索每一个节点，将节点指向队列中next下一个节点。<br>当计数器达到2的指数时，将节点指向null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> ( isPow(count) )&#123;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                curr.next = q.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                q.add(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                q.add(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPow</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="number">0</span> || val == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( val % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">            val = val / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-10T03:19:50.000Z" title="2022/4/10 上午11:19:50">2022-04-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-10T03:19:50.707Z" title="2022/4/10 上午11:19:50">2022-04-10</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/20-Valid-Parentheses/">20. Valid Parentheses</a></h1><div class="content"><blockquote>
<p>问题<br>Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
</ol>
</blockquote>
<p>用栈储存遍历中的字符。<br>如果是“（”，“{”或“[”，则入栈。<br>如果是其他字符，且不与栈顶的字符成对，则返回false。<br>其他情况需要pop掉栈顶。</p>
<ul>
<li>toCharArray(): 将字符串转换为字符数组，便于遍历。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span> ( c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> )&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( stack.size() == <span class="number">0</span> || </span><br><span class="line">                     c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; stack.peek() != <span class="string">&#x27;(&#x27;</span> || </span><br><span class="line">                     c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; stack.peek() != <span class="string">&#x27;&#123;&#x27;</span> || </span><br><span class="line">                     c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; stack.peek() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-10T01:39:03.000Z" title="2022/4/10 上午9:39:03">2022-04-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-20T11:32:59.851Z" title="2022/4/20 下午7:32:59">2022-04-20</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/617-Merge-Two-Binary-Trees/">617. Merge Two Binary Trees</a></h1><div class="content"><blockquote>
<p>问题<br>You are given two binary trees root1 and root2.</p>
<p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>
<p>Return the merged tree.</p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
</blockquote>
<p>递归。将root1和root2合并到root1。<br>如果一个节点为null，则返回另一个节点。<br>否则root1的值为root1 + root2的值。<br>root1.left递归root1和root2的left。<br>root2.right递归root1和root2的right。<br>返回root1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( root1 == <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root2 == <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root1.val = root1.val + root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-10T00:38:58.000Z" title="2022/4/10 上午8:38:58">2022-04-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-10T00:41:06.849Z" title="2022/4/10 上午8:41:06">2022-04-10</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/83-Remove-Duplicates-from-Sorted-List/">83. Remove Duplicates from Sorted List</a></h1><div class="content"><blockquote>
<p>问题<br>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.</p>
</blockquote>
<p>设置前一个节点和当前节点两个指针。<br>由于是有数的链表，遍历时可以直接比较两个节点。<br>如相等则前一个节点的next指向当前节点的next。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.val != curr.val)&#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev.next = curr.next;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-09T19:49:54.000Z" title="2022/4/10 上午3:49:54">2022-04-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-09T19:49:54.819Z" title="2022/4/10 上午3:49:54">2022-04-10</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/206-Reverse-Linked-List/">206. Reverse Linked List</a></h1><div class="content"><blockquote>
<p>问题<br>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>
</blockquote>
<p>翻转列表，当链表长度不足时，直接返回原链表。<br>将头元素设置到preNode，同时将其next设置为null，作为新链表的尾。<br>将其余的元素设置到curNode。</p>
<p>当当前节点不为null时<br>遍历：</p>
<ol>
<li>将curNode的next保存在temp。</li>
<li>将curNode的next指向preNode，作为preNode的上一个节点。</li>
<li>将preNode指向curNode，完成交换。</li>
<li>将curNode指向temp，curNode变为原来的curNode的next。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( head == <span class="literal">null</span> )&#123;   <span class="comment">//if not enough, return head</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preNode</span> <span class="operator">=</span> head;    <span class="comment">//set head to preNode, it will be the last node in the end</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curNode</span> <span class="operator">=</span> head.next;   <span class="comment">//curNode move to next</span></span><br><span class="line">        preNode.next = <span class="literal">null</span>;    <span class="comment">//only preserve one head node</span></span><br><span class="line">        ListNode temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( curNode != <span class="literal">null</span> )&#123;</span><br><span class="line">            temp = curNode.next;    <span class="comment">//preserve nodes after curNode</span></span><br><span class="line">            curNode.next = preNode; <span class="comment">//cur -&gt; pre</span></span><br><span class="line">            preNode = curNode;  <span class="comment">//set back reversed list to preNode</span></span><br><span class="line">            curNode = temp; <span class="comment">//put back preserved nodes, curNode move to the next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-09T00:19:16.000Z" title="2022/4/9 上午8:19:16">2022-04-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-20T11:33:50.289Z" title="2022/4/20 下午7:33:50">2022-04-20</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/09/21-Merge-Two-Sorted-Lists/">21. Merge Two Sorted Lists</a></h1><div class="content"><blockquote>
<p>You are given the heads of two sorted linked lists list1 and list2.</p>
<p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return the head of the merged linked list.</p>
</blockquote>
<p>先设置空的哨兵节点，然后将尾部指针指向这个节点。<br>遍历两个链表，将尾部节点的下一个值指向两个节点中值较小的一个。<br>然后将指针移动到下一个值。<br>最后返回哨兵节点的下一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> dummyHead;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( list1 != <span class="literal">null</span> &amp;&amp; list2 !=<span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val)&#123;</span><br><span class="line">                tail.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                tail.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( list1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            tail.next = list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-08T21:24:04.000Z" title="2022/4/9 上午5:24:04">2022-04-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-08T21:24:52.458Z" title="2022/4/9 上午5:24:52">2022-04-09</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/">复习</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/09/141-Linked-List-Cycle/">141. Linked List Cycle</a></h1><div class="content"><blockquote>
<p>问题<br>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
</blockquote>
<p>遍历并移动快慢指针。<br>如两个指针最终相遇，则链表中有循环。<br>如快指针移动到链表尾部，则链表无循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> ( head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( fast.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span> )&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-07T04:09:40.000Z" title="2022/4/7 下午12:09:40">2022-04-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-20T11:36:47.625Z" title="2022/4/20 下午7:36:47">2022-04-20</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Easy/">Easy</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/07/1046-Last-Stone-Weight/">1046. Last Stone Weight</a></h1><div class="content"><blockquote>
<p><strong>问题</strong><br>You are given an array of integers stones where stones[i] is the weight of the ith stone.</p>
<p>We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;&#x3D; y. The result of this smash is:</p>
<ul>
<li>If x &#x3D;&#x3D; y, both stones are destroyed, and</li>
<li>If x !&#x3D; y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.<br>At the end of the game, there is at most one stone left.</li>
</ul>
<p>Return the smallest possible weight of the left stone. If there are no stones left, return 0.</p>
</blockquote>
<p>采用PriorityQueue队列，将所有元素放入。<br>每次取出两个，将两者的差值放回队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeight</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone : stones)&#123;</span><br><span class="line">            pq.add(stone);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> ( pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">largeStone</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">smallStone</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            pq.add( largeStone - smallStone );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Previous</a></div><div class="pagination-next"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">1</a></li><li><a class="pagination-link is-current" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/page/2/">2</a></li><li><a class="pagination-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/page/3/">3</a></li></ul></nav></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">XANDER Studio</a><p class="is-size-7"><span>&copy; 2022 Xuanhe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><!--!--></body></html>