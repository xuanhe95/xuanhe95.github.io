{"meta":{"title":"XANDER Studio","subtitle":"Xander Studio","description":"Stay Foolish, Stay Hungery...","author":"Xuanhe","url":"https://xuanhe95.github.io","root":"/"},"pages":[],"posts":[{"title":"36. Valid Sudoku","slug":"36-Valid-Sudoku","date":"2022-04-06T19:08:49.000Z","updated":"2022-04-06T19:08:49.845Z","comments":true,"path":"2022/04/07/36-Valid-Sudoku/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/36-Valid-Sudoku/","excerpt":"","text":"问题Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. 遍历并创建三组不同的哈希表，每个表内包含一组哈希集合。如果访问的元素已在哈希集合内，则返回false 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; rowMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; colMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; blockMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); for (int i = 0; i &lt; board[0].length; i++ )&#123; for (int j = 0; j &lt; board.length; j++ )&#123; char curChar = board[i][j]; if (curChar == &#x27;.&#x27;)&#123; continue; &#125; if (!rowMap.containsKey(i))&#123; rowMap.put(i, new HashSet&lt;Character&gt;()); &#125; if (!colMap.containsKey(j))&#123; colMap.put(j, new HashSet&lt;Character&gt;()); &#125; if (!blockMap.containsKey(j/3*3+i/3))&#123; blockMap.put(j/3*3+i/3, new HashSet&lt;Character&gt;()); &#125; HashSet&lt;Character&gt; curRow = rowMap.get(i); HashSet&lt;Character&gt; curCol = colMap.get(j); HashSet&lt;Character&gt; curBlock = blockMap.get(j/3*3+i/3); if ( !curRow.contains(curChar) &amp;&amp; !curCol.contains(curChar) &amp;&amp; !curBlock.contains(curChar) )&#123; curRow.add(curChar); curCol.add(curChar); curBlock.add(curChar); &#125; else&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"923. 3Sum With Multiplicity","slug":"923-3Sum-With-Multiplicity","date":"2022-04-06T18:27:00.000Z","updated":"2022-04-06T18:27:00.097Z","comments":true,"path":"2022/04/07/923-3Sum-With-Multiplicity/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/923-3Sum-With-Multiplicity/","excerpt":"","text":"问题Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] &#x3D;&#x3D; target. As the answer can be very large, return it modulo 109 + 7. 首先遍历元素，根据元素的值和出现次数建立哈希表。然后再哈希表中选择三个元素，如果和等于target，则计算三个元素出现次数的乘积。最后除以重复计算的次数。由于数值较大，因此中途计算应该采用长整型long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int threeSumMulti(int[] arr, int target) &#123; //enumberate every element and put them into the map HashMap&lt;Integer, Long&gt; map = new HashMap&lt;Integer, Long&gt;(); long count = 0; for ( int num : arr )&#123; if (!map.containsKey(num))&#123; map.put(num, (long)1); &#125; else&#123; map.put(num, map.get(num)+1); &#125; &#125; //traverse whole elements and select three numbers for ( int a : map.keySet() )&#123; long totalA = map.get(a); for (int b : map.keySet())&#123; long totalB = map.get(b); if ( a == b )&#123; if (totalB &lt; 2)&#123; continue; &#125; totalB = totalB - 1; &#125; int c = target - a - b; if ( map.containsKey(c) )&#123; long totalC = map.get(c); long total = 0; if ( a == b &amp;&amp; b == c )&#123; total = totalA * totalB * ( totalC - 2 ) ; &#125; else if ( b == c || a == c )&#123; total = totalA * totalB * ( totalC - 1 ) ; &#125; else&#123; total = totalA * totalB * totalC; &#125; if ( total &gt; 0 )&#123; count += total; &#125; &#125; &#125; &#125; count/=6; int ans = (int) (count % 1000000007); return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"118. Pascal's Triangle","slug":"118-Pascal-s-Triangle","date":"2022-04-05T18:53:43.000Z","updated":"2022-04-05T19:01:11.012Z","comments":true,"path":"2022/04/06/118-Pascal-s-Triangle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/118-Pascal-s-Triangle/","excerpt":"","text":"问题Given an integer numRows, return the first numRows of Pascal’s triangle. 动态规划，直接按照杨辉三角形的定义计算。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows); for (int i = 0; i &lt; numRows ; i++)&#123; List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(i+1); for (int j = 0; j &lt;= i; j++)&#123; if ( j == 0 || j == i )&#123; arr.add(1); &#125; else&#123; arr.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j)); &#125; &#125; ans.add(arr); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"11. Container With Most Water","slug":"11-Container-With-Most-Water","date":"2022-04-05T16:50:01.000Z","updated":"2022-04-05T19:03:02.604Z","comments":true,"path":"2022/04/06/11-Container-With-Most-Water/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/11-Container-With-Most-Water/","excerpt":"","text":"问题You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. 双指针在首尾，二者容量取决于两者中较小的一个。贪心算法，保留两个指针上较大的元素，移动较小一边的指针。由于指针移动时距离只会减小，因此当新的元素比上一个更大时才有可能比之前的容量更大。遍历一次找到最大容量。时间复杂度：O(n) 感觉这个移动有点博弈论的味了，每次都移动自己最差的一边，虽然可能变得更差，但是总比不动（或者减小）强，动最差的部分可能找到更好的结果，但是动另一边总会更差或者不变，兄弟们，这不是题，这是人生，逃离舒适圈！！（这解释我觉得无敌了，哈哈哈） 12345678910111213141516171819202122232425class Solution &#123; public int maxArea(int[] height) &#123; int best = 0; int i = 0; int j = height.length - 1; while ( i &lt; j )&#123; int product = 0; if (height[i] &lt; height[j])&#123; product = height[i] * ( j -i ); i++; &#125; else&#123; product = height[j] * ( j -i ); j--; &#125; if ( product &gt; best)&#123; best = product; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"344. Reverse String","slug":"344-Reverse-String","date":"2022-04-05T13:56:14.000Z","updated":"2022-04-05T19:06:30.027Z","comments":true,"path":"2022/04/05/344-Reverse-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/344-Reverse-String/","excerpt":"","text":"问题简述Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. 双指针，同时更新并交换两个数值。 12345678910111213141516class Solution &#123; public void reverseString(char[] s) &#123; int i = 0; int j = s.length - 1; while( i &lt; j ) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"167. Two Sum II - Input Array Is Sorted","slug":"167-Two-Sum-II-Input-Array-Is-Sorted","date":"2022-04-05T05:52:45.000Z","updated":"2022-04-05T19:05:47.624Z","comments":true,"path":"2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","excerpt":"","text":"问题描述Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 由于是有序数列，因此可以采用双指针。左右两侧和不等于目标时，根据大小结果移动左右指针。 123456789101112131415161718192021222324class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int i = 0; int j = numbers.length - 1; int[] ans = new int[2]; while( i &lt; j )&#123; int diff = target - numbers[j]; if ( diff == numbers[i])&#123; ans[0] = i+1; ans[1] = j+1; return ans; &#125; else if ( diff &lt; numbers[i] ) &#123; j--; &#125; else&#123; i++; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"566. Reshape the Matrix","slug":"566-Reshape-the-Matrix","date":"2022-04-05T04:40:01.000Z","updated":"2022-04-06T07:18:53.861Z","comments":true,"path":"2022/04/05/566-Reshape-the-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/566-Reshape-the-Matrix/","excerpt":"","text":"问题概述In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. 根据数组的数学公式得出其位置，一次遍历将原数组中的数字填入。O(r*c) 1234567891011121314151617181920212223class Solution &#123; public int[][] matrixReshape(int[][] mat, int r, int c) &#123; int[][] ans = new int[r][c]; int oldR = mat.length; int oldC = mat[0].length; if ( oldR * oldC != r * c )&#123; return mat; &#125; for (int i = 0; i &lt; r*c ; i++ )&#123; int m = i/oldC; int n = i%oldC; int p = i/c; int q = i%c; ans[p][q] = mat[m][n]; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"283. Move Zeroes","slug":"283-Move-Zeroes","date":"2022-04-04T18:11:56.000Z","updated":"2022-04-06T07:19:29.538Z","comments":true,"path":"2022/04/05/283-Move-Zeroes/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/283-Move-Zeroes/","excerpt":"","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int j = 0; while ( j &lt; nums.length )&#123; if ( nums[j] != 0 )&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; &#125; j++; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"121-Best-Time-to-Buy-and-Sell-Stock","date":"2022-04-04T17:50:49.000Z","updated":"2022-04-06T07:20:10.618Z","comments":true,"path":"2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","excerpt":"","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ )&#123; difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] )&#123; difference[i] = difference[i] + difference[i - 1]; &#125; if (difference[i] &gt; best)&#123; best = difference[i]; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"350. Intersection of Two Arrays II","slug":"350-Intersection-of-Two-Arrays-II","date":"2022-04-04T12:42:40.000Z","updated":"2022-04-06T07:20:49.549Z","comments":true,"path":"2022/04/04/350-Intersection-of-Two-Arrays-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/350-Intersection-of-Two-Arrays-II/","excerpt":"","text":"问题描述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ )&#123; if (!map.containsKey(nums1[i]))&#123; map.put(nums1[i],1); &#125; else&#123; map.put(nums1[i],map.get(nums1[i])+1); &#125; &#125; for ( int i = 0 ; i &lt; nums2.length ; i++ )&#123; if (map.containsKey(nums2[i]))&#123; if (map.get(nums2[i]) &gt; 0)&#123; count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); &#125; &#125; &#125; int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++)&#123; ans[i] = arr.get(i); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"31. Next Permutation","slug":"31-Next-Permutation","date":"2022-04-03T20:11:22.000Z","updated":"2022-04-05T05:58:47.787Z","comments":true,"path":"2022/04/04/31-Next-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/31-Next-Permutation/","excerpt":"","text":"问题描述A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr &#x3D; [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr &#x3D; [1,2,3] is [1,3,2].Similarly, the next permutation of arr &#x3D; [2,3,1] is [3,1,2].While the next permutation of arr &#x3D; [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public void nextPermutation(int[] nums) &#123; int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1)&#123; int i = nums.length -2; while (i &gt;= 0)&#123; if (nums[i + 1] &lt;= nums[i]) &#123; //从尾部开始，比较元素是否是大到小 i--; continue; &#125; else &#123; //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--)&#123; if (nums[j] &lt;= nums[i])&#123; continue; &#125; int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; &#125; break; &#125; &#125; if (flag == 0 )&#123; //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"}]},{"title":"88. Merge Sorted Array","slug":"88-Merge-Sorted-Array","date":"2022-04-03T15:26:40.000Z","updated":"2022-04-05T05:58:48.410Z","comments":true,"path":"2022/04/03/88-Merge-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/88-Merge-Sorted-Array/","excerpt":"","text":"问题描述You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) &#123; if ( nums1[i] &lt; nums2[j] )&#123; nums1[k] = nums2[j]; j--; k--; &#125; else &#123; nums1[k] = nums1[i]; i--; k--; &#125; &#125; if ( i &lt; 0 )&#123; while ( j &gt;= 0 )&#123; nums1[k] = nums2[j]; j--; k--; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"}]},{"title":"1. Two Sum","slug":"1-Two-Sum","date":"2022-04-03T14:35:42.000Z","updated":"2022-04-05T05:58:46.865Z","comments":true,"path":"2022/04/03/1-Two-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/1-Two-Sum/","excerpt":"","text":"问题描述Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int result = target - nums[i]; if ( map.containsKey(result) )&#123; ans[0] = map.get(result); ans[1] = i; return ans; &#125; else&#123; map.put(nums[i], i); &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2022-04-03T13:54:39.000Z","updated":"2022-04-05T05:58:57.511Z","comments":true,"path":"2022/04/03/189-Rotate-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/189-Rotate-Array/","excerpt":"","text":"问题描述Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution &#123; public void rotate(int[] nums, int k) &#123; if (k != 0)&#123; int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) &#123; int i = n + k; i %= nums.length; int temp = nums[n]; while( true )&#123; int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n)&#123; nums[n] = temp; break; &#125; &#125; &#125; &#125; &#125; private int gcd(int a, int b)&#123; int max = a; int min = b; if (max == min)&#123; return min; &#125; if ( a &lt; b )&#123; max = b; min = a; &#125; return gcd(max - min, min); &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"977. Squares of a Sorted Array","slug":"977-Squares-of-a-Sorted-Array","date":"2022-04-03T13:35:19.000Z","updated":"2022-04-05T05:59:10.780Z","comments":true,"path":"2022/04/03/977-Squares-of-a-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/977-Squares-of-a-Sorted-Array/","excerpt":"","text":"问题描述Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) &#123; if ( nums[left] &lt; 0 )&#123; if ( (-nums[left]) &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else &#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; else&#123; if ( nums[left] &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else&#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"测试一下","slug":"测试一下","date":"2022-03-30T14:26:17.000Z","updated":"2022-03-30T14:26:17.799Z","comments":true,"path":"2022/03/30/测试一下/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/","excerpt":"","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","categories":[],"tags":[]},{"title":"post title","slug":"post-title","date":"2022-03-30T12:22:27.000Z","updated":"2022-03-30T12:24:40.285Z","comments":true,"path":"2022/03/30/post-title/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/post-title/","excerpt":"","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-30T12:02:37.831Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/03/30/hello-world/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"}]}