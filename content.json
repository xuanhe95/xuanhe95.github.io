{"pages":[],"posts":[{"title":"1. Two Sum","text":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++){ int result = target - nums[i]; if ( map.containsKey(result) ){ ans[0] = map.get(result); ans[1] = i; return ans; } else{ map.put(nums[i], i); } } return ans; }}","link":"/2022/04/03/1-Two-Sum/"},{"title":"121. Best Time to Buy and Sell Stock","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution { public int maxProfit(int[] prices) { int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ ){ difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] ){ difference[i] = difference[i] + difference[i - 1]; } if (difference[i] &gt; best){ best = difference[i]; } } return best; }}","link":"/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/"},{"title":"283. Move Zeroes","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = 0; while ( j &lt; nums.length ){ if ( nums[j] != 0 ){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; } j++; } }}","link":"/2022/04/05/283-Move-Zeroes/"},{"title":"189. Rotate Array","text":"Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution { public void rotate(int[] nums, int k) { if (k != 0){ int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) { int i = n + k; i %= nums.length; int temp = nums[n]; while( true ){ int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n){ nums[n] = temp; break; } } } } } private int gcd(int a, int b){ int max = a; int min = b; if (max == min){ return min; } if ( a &lt; b ){ max = b; min = a; } return gcd(max - min, min); }}","link":"/2022/04/03/189-Rotate-Array/"},{"title":"31. Next Permutation","text":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2].Similarly, the next permutation of arr = [2,3,1] is [3,1,2].While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution { public void nextPermutation(int[] nums) { int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1){ int i = nums.length -2; while (i &gt;= 0){ if (nums[i + 1] &lt;= nums[i]) { //从尾部开始，比较元素是否是大到小 i--; continue; } else { //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--){ if (nums[j] &lt;= nums[i]){ continue; } int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; } break; } } if (flag == 0 ){ //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); } } }}","link":"/2022/04/04/31-Next-Permutation/"},{"title":"88. Merge Sorted Array","text":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) { if ( nums1[i] &lt; nums2[j] ){ nums1[k] = nums2[j]; j--; k--; } else { nums1[k] = nums1[i]; i--; k--; } } if ( i &lt; 0 ){ while ( j &gt;= 0 ){ nums1[k] = nums2[j]; j--; k--; } } }}","link":"/2022/04/03/88-Merge-Sorted-Array/"},{"title":"350. Intersection of Two Arrays II","text":"问题描述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution { public int[] intersect(int[] nums1, int[] nums2) { HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ ){ if (!map.containsKey(nums1[i])){ map.put(nums1[i],1); } else{ map.put(nums1[i],map.get(nums1[i])+1); } } for ( int i = 0 ; i &lt; nums2.length ; i++ ){ if (map.containsKey(nums2[i])){ if (map.get(nums2[i]) &gt; 0){ count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); } } } int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++){ ans[i] = arr.get(i); } return ans; }}","link":"/2022/04/04/350-Intersection-of-Two-Arrays-II/"},{"title":"977. Squares of a Sorted Array","text":"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution { public int[] sortedSquares(int[] nums) { int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) { if ( nums[left] &lt; 0 ){ if ( (-nums[left]) &lt; nums[right] ){ ans[i] = nums[right] * nums[right]; right--; } else { ans[i] = nums[left] * nums[left]; left++; } i--; } else{ if ( nums[left] &lt; nums[right] ){ ans[i] = nums[right] * nums[right]; right--; } else{ ans[i] = nums[left] * nums[left]; left++; } i--; } } return ans; }}","link":"/2022/04/03/977-Squares-of-a-Sorted-Array/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/30/hello-world/"},{"title":"post title","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","link":"/2022/03/30/post-title/"},{"title":"测试一下","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","link":"/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/"},{"title":"566. Reshape the Matrix","text":"问题概述In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. 根据数组的数学公式得出其位置，一次遍历将原数组中的数字填入。O(r*c) 1234567891011121314151617181920212223class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int[][] ans = new int[r][c]; int oldR = mat.length; int oldC = mat[0].length; if ( oldR * oldC != r * c ){ return mat; } for (int i = 0; i &lt; r*c ; i++ ){ int m = i/oldC; int n = i%oldC; int p = i/c; int q = i%c; ans[p][q] = mat[m][n]; } return ans; }}","link":"/2022/04/05/566-Reshape-the-Matrix/"},{"title":"167. Two Sum II - Input Array Is Sorted","text":"问题描述Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 由于是有序数列，因此可以采用双指针。左右两侧和不等于目标时，根据大小结果移动左右指针。 123456789101112131415161718192021222324class Solution { public int[] twoSum(int[] numbers, int target) { int i = 0; int j = numbers.length - 1; int[] ans = new int[2]; while( i &lt; j ){ int diff = target - numbers[j]; if ( diff == numbers[i]){ ans[0] = i+1; ans[1] = j+1; return ans; } else if ( diff &lt; numbers[i] ) { j--; } else{ i++; } } return ans; }}","link":"/2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/"},{"title":"344. Reverse String","text":"问题简述Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. 双指针，同时更新并交换两个数值。 12345678910111213141516class Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; while( i &lt; j ) { char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }}","link":"/2022/04/05/344-Reverse-String/"},{"title":"11. Container With Most Water","text":"问题You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. 双指针在首尾，二者容量取决于两者中较小的一个。贪心算法，保留两个指针上较大的元素，移动较小一边的指针。由于指针移动时距离只会减小，因此当新的元素比上一个更大时才有可能比之前的容量更大。遍历一次找到最大容量。时间复杂度：O(n) 感觉这个移动有点博弈论的味了，每次都移动自己最差的一边，虽然可能变得更差，但是总比不动（或者减小）强，动最差的部分可能找到更好的结果，但是动另一边总会更差或者不变，兄弟们，这不是题，这是人生，逃离舒适圈！！（这解释我觉得无敌了，哈哈哈） 12345678910111213141516171819202122232425class Solution { public int maxArea(int[] height) { int best = 0; int i = 0; int j = height.length - 1; while ( i &lt; j ){ int product = 0; if (height[i] &lt; height[j]){ product = height[i] * ( j -i ); i++; } else{ product = height[j] * ( j -i ); j--; } if ( product &gt; best){ best = product; } } return best; }}","link":"/2022/04/06/11-Container-With-Most-Water/"},{"title":"118. Pascal&#39;s Triangle","text":"Given an integer numRows, return the first numRows of Pascal’s triangle. 动态规划，直接按照杨辉三角形的定义计算。 123456789101112131415161718192021class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows); for (int i = 0; i &lt; numRows ; i++){ List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(i+1); for (int j = 0; j &lt;= i; j++){ if ( j == 0 || j == i ){ arr.add(1); } else{ arr.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j)); } } ans.add(arr); } return ans; }}","link":"/2022/04/06/118-Pascal-s-Triangle/"},{"title":"923. 3Sum With Multiplicity","text":"Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7. 首先遍历元素，根据元素的值和出现次数建立哈希表。然后再哈希表中选择三个元素，如果和等于target，则计算三个元素出现次数的乘积。最后除以重复计算的次数。由于数值较大，因此中途计算应该采用长整型long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public int threeSumMulti(int[] arr, int target) { //enumberate every element and put them into the map HashMap&lt;Integer, Long&gt; map = new HashMap&lt;Integer, Long&gt;(); long count = 0; for ( int num : arr ){ if (!map.containsKey(num)){ map.put(num, (long)1); } else{ map.put(num, map.get(num)+1); } } //traverse whole elements and select three numbers for ( int a : map.keySet() ){ long totalA = map.get(a); for (int b : map.keySet()){ long totalB = map.get(b); if ( a == b ){ if (totalB &lt; 2){ continue; } totalB = totalB - 1; } int c = target - a - b; if ( map.containsKey(c) ){ long totalC = map.get(c); long total = 0; if ( a == b &amp;&amp; b == c ){ total = totalA * totalB * ( totalC - 2 ) ; } else if ( b == c || a == c ){ total = totalA * totalB * ( totalC - 1 ) ; } else{ total = totalA * totalB * totalC; } if ( total &gt; 0 ){ count += total; } } } } count/=6; int ans = (int) (count % 1000000007); return ans; }}","link":"/2022/04/07/923-3Sum-With-Multiplicity/"},{"title":"36. Valid Sudoku","text":"问题Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. 遍历并创建三组不同的哈希表，每个表内包含一组哈希集合。如果访问的元素已在哈希集合内，则返回false 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public boolean isValidSudoku(char[][] board) { HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; rowMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; colMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; blockMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); for (int i = 0; i &lt; board[0].length; i++ ){ for (int j = 0; j &lt; board.length; j++ ){ char curChar = board[i][j]; if (curChar == '.'){ continue; } if (!rowMap.containsKey(i)){ rowMap.put(i, new HashSet&lt;Character&gt;()); } if (!colMap.containsKey(j)){ colMap.put(j, new HashSet&lt;Character&gt;()); } if (!blockMap.containsKey(j/3*3+i/3)){ blockMap.put(j/3*3+i/3, new HashSet&lt;Character&gt;()); } HashSet&lt;Character&gt; curRow = rowMap.get(i); HashSet&lt;Character&gt; curCol = colMap.get(j); HashSet&lt;Character&gt; curBlock = blockMap.get(j/3*3+i/3); if ( !curRow.contains(curChar) &amp;&amp; !curCol.contains(curChar) &amp;&amp; !curBlock.contains(curChar) ){ curRow.add(curChar); curCol.add(curChar); curBlock.add(curChar); } else{ return false; } } } return true; }}","link":"/2022/04/07/36-Valid-Sudoku/"},{"title":"74. Search a 2D Matrix","text":"问题Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 二分搜索，以整个数组尺寸作为搜索范围。每次搜索中间值，如等于target则返回。 123456789101112131415161718192021class Solution { public boolean searchMatrix(int[][] matrix, int target) { int left = 0; int right = (matrix.length * matrix[0].length) - 1; while(left &lt;= right){ int mid = left + (right - left)/2; int row = mid / matrix[0].length; int col = mid % matrix[0].length; if(matrix[row][col] == target){ return true; } else if(matrix[row][col] &gt; target){ right = mid - 1; } else{ left = mid + 1; } } return false; }} 双指针，先搜索到合适的行。再搜索到合适的列。 1234567891011121314151617181920212223242526272829class Solution { public boolean searchMatrix(int[][] matrix, int target) { int i = 0; int j = 0; while(i &lt; matrix.length){ if(matrix[i][0] == target){ return true; } else if(matrix[i][0] &lt; target){ i++; } else{ break; } } if( i == 0 ){ return false; } i--; while(j &lt; matrix[0].length){ if(matrix[i][j] == target){ return true; } j++; } return false; }}","link":"/2022/04/07/74-Search-a-2D-Matrix/"},{"title":"876. Middle of the Linked List","text":"问题Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 快慢指针，两个指针不同速度遍历链表。当快指针达到链表尾部时候，慢指针正好在中间。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode middleNode(ListNode head) { ListNode slowNode = head; ListNode fastNode = head; while( fastNode != null ){ fastNode = fastNode.next; if (fastNode == null){ return slowNode; } slowNode = slowNode.next; fastNode = fastNode.next; } return slowNode; }}","link":"/2022/04/07/876-Middle-of-the-Linked-List/"},{"title":"19. Remove Nth Node From End of List","text":"问题Given the head of a linked list, remove the nth node from the end of the list and return its head. 双指针，同时记录前n个节点和当前节点。当前指针到链表尾部时，删除前面的指针，注意处理edge cases。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode preNode = null; ListNode removedNode = head; ListNode fastNode = head; for ( int i = 0; i &lt; n; i++ ){ fastNode = fastNode.next; } while ( fastNode != null ){ fastNode = fastNode.next; preNode = removedNode; removedNode = removedNode.next; } if ( removedNode == head ){ head = head.next; } else if ( removedNode.next == null){ preNode.next = null; } else{ preNode.next = removedNode.next; } return head; }}","link":"/2022/04/07/19-Remove-Nth-Node-From-End-of-List/"},{"title":"680. Valid Palindrome II","text":"问题Given a string s, return true if the s can be palindrome after deleting at most one character from it. 双指针，字符串两边对比。如果两边字符不相等，则更新两边指针，并分别传入辅助方法再次对比。两个结果有一个是true则返回true。 1234567891011121314151617181920212223242526272829class Solution { public boolean validPalindrome(String s) { int left = 0; int right = s.length() - 1; while (left &lt; right){ if (s.charAt(left) == s.charAt(right) ){ left++; right--; } else{ return ( checkPalindrome(s, left+1, right) || checkPalindrome(s, left, right-1)); } } return true; } private boolean checkPalindrome(String s, int left, int right){ while (left &lt; right){ if (s.charAt(left)==s.charAt(right)){ left++; right--; } else{ return false; } } return true; } }","link":"/2022/04/07/680-Valid-Palindrome-II/"},{"title":"1046. Last Stone Weight","text":"问题You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0. 采用PriorityQueue队列，将所有元素放入。每次取出两个，将两者的差值放回队列。 12345678910111213141516class Solution { public int lastStoneWeight(int[] stones) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for (int stone : stones){ pq.add(stone); } while ( pq.size() &gt; 1) { int largeStone = pq.poll(); int smallStone = pq.poll(); pq.add( largeStone - smallStone ); } return pq.poll(); }}","link":"/2022/04/07/1046-Last-Stone-Weight/"},{"title":"387. First Unique Character in a String","text":"问题Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. 遍历，建立哈希表，记录出现次数。再次遍历，如果出现次数为1，则返回下标。 1234567891011121314151617181920212223class Solution { public int firstUniqChar(String s) { HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for ( int i = 0; i &lt; s.length(); i++ ){ char curChar = s.charAt(i); if ( !map.containsKey(curChar) ){ map.put(curChar, 1); } else{ map.put(curChar, map.get(curChar)+1); } } for ( int i = 0; i &lt; s.length(); i++ ){ char curChar = s.charAt(i); if ( map.get(curChar) == 1 ){ return i; } } return -1; }}","link":"/2022/04/07/387-First-Unique-Character-in-a-String/"},{"title":"383. Ransom Note","text":"Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. 哈希表，遍历添加字典及次数。然后遍历note，与字典中的字符数量作比较。 可以优化速度，采用数组记录所有英文字母的数量。 12345678910111213141516171819202122232425class Solution { public boolean canConstruct(String ransomNote, String magazine) { HashMap&lt;Character, Integer&gt; dic = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; magazine.length(); i++){ char curChar = magazine.charAt(i); if (!dic.containsKey(curChar)){ dic.put(curChar, 1); } else{ dic.put(curChar, dic.get(curChar)+1); } } for (int i = 0; i &lt; ransomNote.length(); i++){ char curChar = ransomNote.charAt(i); if (dic.containsKey(curChar) &amp;&amp; dic.get(curChar) &gt; 0){ dic.put(curChar, dic.get(curChar)-1); } else{ return false; } } return true; }}","link":"/2022/04/07/383-Ransom-Note/"},{"title":"3. Longest Substring Without Repeating Characters","text":"问题Given a string s, find the length of the longest substring without repeating characters. 滑动窗口，哈希表记录访问过的字符的元素。如果重复，则放弃前一个重复的字符，更新左指针。注意：只有在新指针大于现有指针时才更新！ 1234567891011121314151617181920212223242526272829303132class Solution { public int lengthOfLongestSubstring(String s) { int best = 0; int i = 0; int j = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); while ( j &lt; s.length() ){ char curChar = s.charAt(j); if ( !map.containsKey(curChar) ){ map.put( curChar, j ); } else{ if ( map.get(curChar) + 1 &gt; i){ i = map.get(curChar) + 1; } map.put( curChar, j ); } if ((j - i + 1) &gt; best){ best = (j - i + 1); } j++; } return best; }}","link":"/2022/04/07/3-Longest-Substring-Without-Repeating-Characters/"},{"title":"567. Permutation in String","text":"问题Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2. 将要查找的组合加入数组，数值为字符出现的次数。滑动窗口，入窗口对应的元素数值-1，出窗口对应的元素数值+1。每次移动窗口都检验一次数组的数值是否全部为0，如果是真，则返回真。小技巧：直接用数组来记录字符出现的次数，用字符减去与’a’的差作为下标。 123456789101112131415161718192021222324252627282930313233343536class Solution { public boolean checkInclusion(String s1, String s2) { if (s1.length() &gt; s2.length()){ return false; } int[] dic = new int[26]; for (int i = 0; i &lt; s1.length(); i++){ dic[s1.charAt(i)-'a']++; dic[s2.charAt(i)-'a']--; } int i = 0; int j = s1.length(); while( j &lt; s2.length() ){ if ( allZero(dic) ){ return true; } dic[s2.charAt(i)-'a']++; dic[s2.charAt(j)-'a']--; i++; j++; } return allZero(dic); } private boolean allZero(int[] dic){ for (int num : dic){ if ( num != 0 ){ return false; } } return true; }}","link":"/2022/04/07/567-Permutation-in-String/"},{"title":"242. Valid Anagram","text":"问题Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 两数组相等时，直接遍历两个数组并记录各个字符出现的数量。一个数组遍历时用做加法，另一个做减法。如果最后每个字符出现的数量均为0，则返回真。 12345678910111213141516171819class Solution { public boolean isAnagram(String s, String t) { if (s.length()!=t.length()){ return false; } int[] dic = new int[26]; for (int i = 0; i &lt; s.length(); i++){ dic[s.charAt(i)-'a']++; dic[t.charAt(i)-'a']--; } for(int num : dic){ if ( num != 0 ){ return false; } } return true; }}","link":"/2022/04/07/242-Valid-Anagram/"},{"title":"141. Linked List Cycle","text":"问题Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. 遍历并移动快慢指针。如两个指针最终相遇，则链表中有循环。如快指针移动到链表尾部，则链表无循环。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; if ( head == null){ return false; } else if ( fast.next == null){ return false; } while( fast != null &amp;&amp; fast.next != null ){ slow = slow.next; fast = fast.next.next; if (slow == fast){ return true; } } return false; }}","link":"/2022/04/09/141-Linked-List-Cycle/"},{"title":"703. Kth Largest Element in a Stream","text":"问题Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. 优先级队列，插入所有元素，小元素在前。当队列长度大于k时，poll掉前面的元素。 12345678910111213141516171819202122232425class KthLargest { PriorityQueue&lt;Integer&gt; pq; int kth; public KthLargest(int k, int[] nums) { pq = new PriorityQueue&lt;Integer&gt;(); kth = k; for (int num : nums){ pq.add(num); } } public int add(int val) { pq.add(val); while (pq.size() &gt; kth){ pq.poll(); } return pq.peek(); }}/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","link":"/2022/04/09/703-Kth-Largest-Element-in-a-Stream/"},{"title":"21. Merge Two Sorted Lists","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 先设置空的哨兵节点，然后将尾部指针指向这个节点。遍历两个链表，将尾部节点的下一个值指向两个节点中值较小的一个。然后将指针移动到下一个值。最后返回哨兵节点的下一个节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummyHead = new ListNode(); ListNode tail = dummyHead; while ( list1 != null &amp;&amp; list2 !=null ){ if (list1.val &lt; list2.val){ tail.next = list1; list1 = list1.next; tail = tail.next; } else{ tail.next = list2; list2 = list2.next; tail = tail.next; } } if ( list1 == null){ tail.next = list2; } else { tail.next = list1; } return dummyHead.next; }}","link":"/2022/04/09/21-Merge-Two-Sorted-Lists/"},{"title":"733. Flood Fill","text":"答案An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. Return the modified image after performing the flood fill. 深度优先搜索。如果当前像素颜色等于最初的颜色，则变更为新颜色。然后继续递归四个周围的像素。 1234567891011121314151617181920212223242526272829class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int newColor) { int oldColor = image[sr][sc]; if (oldColor != newColor){ dfs(image,sr,sc,oldColor,newColor); } return image; } private void dfs(int[][] image, int r, int c, int oldColor, int newColor){ if (image[r][c] == oldColor){ image[r][c] = newColor; if (r&gt;=1){ dfs(image,r-1,c,oldColor,newColor); } if (c&gt;=1){ dfs(image,r,c-1,oldColor,newColor); } if (r&lt;image.length-1){ dfs(image,r+1,c,oldColor,newColor); } if (c&lt;image[0].length-1){ dfs(image,r,c+1,oldColor,newColor); } } }}","link":"/2022/04/09/733-Flood-Fill/"},{"title":"203. Remove Linked List Elements","text":"问题Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. 设置哨兵节点，将其next指向头部。设置前节点，将其指向哨兵节点。设置尾部节点，并指向头部。移动当前节点尾部，如尾部的val等于需要删去的val，则将前节点的next指向尾部的next。尾部的next如为null，则前节点的next指向null。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null){ return head; } ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode preNode = dummyHead; ListNode tail = dummyHead.next; while( tail != null ){ if ( tail.next == null &amp;&amp; tail.val == val ){ preNode.next = null; break; } else if (tail.val == val){ preNode.next = tail.next; tail = preNode.next; } else{ preNode = preNode.next; tail = tail.next; } } return dummyHead.next; }}","link":"/2022/04/09/203-Remove-Linked-List-Elements/"},{"title":"206. Reverse Linked List","text":"问题Given the head of a singly linked list, reverse the list, and return the reversed list. 翻转列表，当链表长度不足时，直接返回原链表。将头元素设置到preNode，同时将其next设置为null，作为新链表的尾。将其余的元素设置到curNode。 当当前节点不为null时遍历： 将curNode的next保存在temp。 将curNode的next指向preNode，作为preNode的上一个节点。 将preNode指向curNode，完成交换。 将curNode指向temp，curNode变为原来的curNode的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseList(ListNode head) { if( head == null ){ //if not enough, return head return head; } if ( head.next == null ){ return head; } ListNode preNode = head; //set head to preNode, it will be the last node in the end ListNode curNode = head.next; //curNode move to next preNode.next = null; //only preserve one head node ListNode temp; while( curNode != null ){ temp = curNode.next; //preserve nodes after curNode curNode.next = preNode; //cur -&gt; pre preNode = curNode; //set back reversed list to preNode curNode = temp; //put back preserved nodes, curNode move to the next } return preNode; }}","link":"/2022/04/10/206-Reverse-Linked-List/"},{"title":"347. Top K Frequent Elements","text":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. 遍历，使用哈希表保存遍历次数。再次遍历，根据元素出现的次数将其填入大根堆。遍历取出k个最大值。 getOrDefault()：方便的遍历并生成哈希表。 lambda： （）内表示传入的数值。-&gt; 后表示返回值。 1234567891011121314151617class Solution { public int[] topKFrequent(int[] nums, int k) { int[] ans = new int[k]; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for (int num : nums){ map.put( num, map.getOrDefault(num , 0) + 1 ); } PriorityQueue&lt;Integer&gt; pq = new PriorityQueue((a,b) -&gt; map.get(b) - map.get(a)); for (int key : map.keySet()){ pq.add(key); } for (int i = 0; i &lt; k ; i++){ ans[i] = pq.poll(); } return ans; }}","link":"/2022/04/10/347-Top-K-Frequent-Elements/"},{"title":"695. Max Area of Island","text":"问题You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. DFS, 遍历每个等于1的地图块。递归周围四个地图块，当超越数组范围时返回0。进行搜索时将搜索过的地图块设为0。否则运行BFS时将全局变量count增加。执行完毕后BFS时将全局变量count清零。 count计算的是BFS执行的次数 12345678910111213141516171819202122232425262728293031class Solution { int count = 0; public int maxAreaOfIsland(int[][] grid) { int best = 0; for(int i = 0; i &lt; grid.length ; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if ( grid[i][j] == 1 ){ best = Math.max(best, dfs(grid,i,j)); count = 0; } } } return best; } private int dfs(int[][] grid, int i, int j){ if((i &lt; 0 || i &gt; grid.length -1) || (j &lt; 0 || j &gt; grid[0].length -1 ) || grid[i][j] == 0){ return 0; } grid[i][j] = 0; count++; dfs(grid,i-1,j); dfs(grid,i,j-1); dfs(grid,i+1,j); dfs(grid,i,j+1); return count; }}","link":"/2022/04/10/695-Max-Area-of-Island/"},{"title":"83. Remove Duplicates from Sorted List","text":"问题Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 设置前一个节点和当前节点两个指针。由于是有数的链表，遍历时可以直接比较两个节点。如相等则前一个节点的next指向当前节点的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { if ( head == null){ return head; } if ( head.next == null){ return head; } ListNode prev = head; ListNode curr = head.next; while(curr != null){ if(prev.val != curr.val){ curr = curr.next; prev = prev.next; } else{ prev.next = curr.next; curr = curr.next; } } return head; }}","link":"/2022/04/10/83-Remove-Duplicates-from-Sorted-List/"},{"title":"617. Merge Two Binary Trees","text":"问题You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. 递归。将root1和root2合并到root1。如果一个节点为null，则返回另一个节点。否则root1的值为root1 + root2的值。root1.left递归root1和root2的left。root2.right递归root1和root2的right。返回root1。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if( root1 == null ){ return root2; } if( root2 == null ){ return root1; } root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; }}","link":"/2022/04/10/617-Merge-Two-Binary-Trees/"},{"title":"20. Valid Parentheses","text":"问题Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 用栈储存遍历中的字符。如果是“（”，“{”或“[”，则入栈。如果是其他字符，且不与栈顶的字符成对，则返回false。其他情况需要pop掉栈顶。 toCharArray(): 将字符串转换为字符数组，便于遍历。 123456789101112131415161718192021class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack(); for (char c : s.toCharArray()){ if ( c == '(' || c == '{' || c == '[' ){ stack.push(c); } else if ( stack.size() == 0 || c == ')' &amp;&amp; stack.peek() != '(' || c == '}' &amp;&amp; stack.peek() != '{' || c == ']' &amp;&amp; stack.peek() != '[') { return false; } else{ stack.pop(); } } return stack.isEmpty(); }}","link":"/2022/04/10/20-Valid-Parentheses/"},{"title":"116. Populating Next Right Pointers in Each Node","text":"问题You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456 struct Node { int val; Node *left; Node *right; Node *next;&gt;} Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 递归，当root为null时返回。如果root有右节点，则左节点next指向右节点。如果root有右节点同时next已经指向了一个节点，则将其右节点next指向该节点的左子节点。递归左右子节点，并返回root。 1234567891011121314151617181920212223242526272829303132333435363738/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/class Solution { public Node connect(Node root) { if (root==null){return root;} if (root.right!=null){ root.left.next = root.right; if (root.next!=null){ root.right.next = root.next.left; } } connect(root.left); connect(root.right); return root; }} BFS搜索每一个节点，将节点指向队列中next下一个节点。当计数器达到2的指数时，将节点指向null。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public Node connect(Node root) { if (root == null){ return root; } int count = 1; Queue&lt;Node&gt; q = new LinkedList(); q.offer(root); while (!q.isEmpty()){ count++; Node curr = q.poll(); if ( isPow(count) ){ curr.next = null; } else{ curr.next = q.peek(); } if(curr.left!=null){ q.add(curr.left); } if(curr.right!=null){ q.add(curr.right); } } return root; } private boolean isPow(int val){ if(val == 0 || val == 1){ return false; } while ( val % 2 == 0 ){ val = val / 2; } if (val == 1){ return true; } return false; }}","link":"/2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/"},{"title":"542. 01 Matrix","text":"问题Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.The distance between two adjacent cells is 1. 由于是搜索最近的距离，因此可以采用BFS搜索。首先创建一个距离矩阵，将所有原矩阵为0的位置填上距离0，将其他位置填上无穷大。使用BFS搜索，将所有0的坐标放入队列。取出队列头元素，将其周围的距离矩阵的元素与自身距离矩阵的元素+1比较，将较小的值设置在周围的距离矩阵上。同时，将改变数值的坐标再次放入队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution{ public int[][] updateMatrix(int[][] mat) { Queue&lt;Integer&gt; q = new LinkedList(); int row = mat.length; int col = mat[0].length; int[][] ans = new int[row][col]; for ( int i = 0; i &lt; row; i++ ){ for (int j = 0; j &lt; col; j++){ if (mat[i][j] == 0){ ans[i][j] = 0; q.add(i*col + j); } else{ ans[i][j] = Integer.MAX_VALUE; } } } while(!q.isEmpty()){ int i = q.peek() / col; int j = q.poll() % col; if(i-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i-1][j]){ ans[i-1][j] = ans[i][j]+1; q.add((i-1)*col + j); } if(i+1 &lt; row &amp;&amp; ans[i][j]+1 &lt; ans[i+1][j]){ ans[i+1][j] = ans[i][j]+1; q.add((i+1)*col + j); } if(j-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i][j-1]){ ans[i][j-1] = ans[i][j]+1; q.add(i*col + (j-1)); } if(j+1 &lt; col &amp;&amp; ans[i][j]+1 &lt; ans[i][j+1]){ ans[i][j+1] = ans[i][j]+1; q.add(i*col + (j+1)); } } return ans; }}","link":"/2022/04/10/542-01-Matrix/"},{"title":"994. Rotting Oranges","text":"问题You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. 由于腐烂的橘子每次都只能影响周围的橘子，因此采用BFS。将所有腐烂的橘子加入队列。如果没有新鲜的橘子，则返回0。每次出队列，如果周围有新鲜的橘子存在，则将新鲜的橘子替换为腐烂并加入队列。每个level结束后，time+1。 最后遍历一遍，如果还有新鲜的橘子，返回-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution { public int orangesRotting(int[][] grid) { Queue&lt;Integer&gt; q = new LinkedList(); int row = grid.length; int col = grid[0].length; int fresh = 0; for (int i = 0; i &lt; row; i++){ for(int j = 0; j &lt; col; j++){ if ( grid[i][j] == 2){ q.add(i * col + j); } else if (grid[i][j] == 1){ fresh++; } } } if(fresh == 0){return 0;} int count = q.size()-1; int temp = 0; int time = -1; while(!q.isEmpty()){ int i = q.peek() / col; int j = q.poll() % col; if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == 1){ grid[i-1][j] = 2; q.add((i-1)*col+j); temp++; } if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == 1){ grid[i][j-1] = 2; q.add(i*col+(j-1)); temp++; } if(i+1&lt;row &amp;&amp; grid[i+1][j] == 1){ grid[i+1][j] = 2; q.add((i+1)*col+j); temp++; } if(j+1&lt;col &amp;&amp; grid[i][j+1] == 1){ grid[i][j+1] = 2; q.add(i*col+(j+1)); temp++; } if(count == 0){ count = temp; temp = 0; time++; } count--; } for (int i = 0; i &lt; row; i++){ for(int j = 0; j &lt; col; j++){ if ( grid[i][j] == 1){ return -1; } } } return time; }}","link":"/2022/04/10/994-Rotting-Oranges/"},{"title":"682. Baseball Game","text":"问题You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds’ scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x. “+” - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. “D” - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. “C” - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. 遍历选项，根据内容决定对ArrayList的操作。然后遍历将ArrayList加和，返回。 123456789101112131415161718192021222324252627class Solution { public int calPoints(String[] ops) { int ans = 0; List&lt;Integer&gt; records = new ArrayList(); for (String op : ops){ switch(op){ case &quot;+&quot;: records.add(records.get(records.size()-1)+records.get(records.size()-2)); break; case &quot;D&quot;: records.add(records.get(records.size()-1)*2); break; case &quot;C&quot;: records.remove(records.size()-1); break; default: records.add(Integer.parseInt(op)); } } for (int record : records){ ans += record; } return ans; }}","link":"/2022/04/11/682-Baseball-Game/"},{"title":"1260. Shift 2D Grid","text":"问题Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1].Element at grid[i][n - 1] moves to grid[i + 1][0].Element at grid[m - 1][n - 1] moves to grid[0][0].Return the 2D grid after applying shift operation k times. 遍历整个数组，将索引值加上移动的次数，得到新的位置。 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int row = grid.length; int col = grid[0].length; int size = row * col; Integer[][] mat = new Integer[row][col]; for (int i = 0; i &lt; size; i++){ int j = i + k; if ( j &gt; size - 1){ j %= size; } int nr = j / col; int nc = j % col; int or = i / col; int oc = i % col; mat[nr][nc] = grid[or][oc]; } for (int i = 0; i &lt; row; i++){ List&lt;Integer&gt; nums = Arrays.asList(mat[i]); ans.add(nums); } return ans; }}","link":"/2022/04/11/1260-Shift-2D-Grid/"},{"title":"232. Implement Queue using Stacks","text":"问题Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise.Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. 创建两个栈。当入队列时，将元素压入第一个栈。当出队列或进行其他操作时，如第二个栈为空，则将第一个栈的元素倒出到第二个栈。此时第二个栈内的内容为顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyQueue { Stack&lt;Integer&gt; s1; Stack&lt;Integer&gt; s2; public MyQueue() { s1 = new Stack(); s2 = new Stack(); } public void push(int x) { s1.add(x); } public int pop() { if (s2.isEmpty()){ while (!s1.isEmpty()){ s2.add(s1.pop()); } return s2.pop(); } else{ return s2.pop(); } } public int peek() { if (s2.isEmpty()){ while (!s1.isEmpty()){ s2.add(s1.pop()); } return s2.peek(); } else{ return s2.peek(); } } public boolean empty() { return s1.isEmpty() &amp;&amp; s2.isEmpty(); }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/2022/04/12/232-Implement-Queue-using-Stacks/"},{"title":"144. Binary Tree Preorder Traversal","text":"问题Given the root of a binary tree, return the preorder traversal of its nodes’ values. 先序遍历。先将当前节点加入数组。然后递归左子节点。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ans = new ArrayList(); traversal(root); return ans; } private void traversal(TreeNode root){ if (root == null){ return; } ans.add(root.val); traversal(root.left); traversal(root.right); return; }}","link":"/2022/04/12/144-Binary-Tree-Preorder-Traversal/"},{"title":"145. Binary Tree Postorder Traversal","text":"问题Given the root of a binary tree, return the postorder traversal of its nodes’ values. 后序遍历。先递归左子节点。然后递归右子节点。最后将当前节点加入数组。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; postorderTraversal(TreeNode root) { ans = new ArrayList(); traversal(root); return ans; } private void traversal(TreeNode root){ if (root == null){ return; } traversal(root.left); traversal(root.right); ans.add(root.val); return; }}","link":"/2022/04/12/145-Binary-Tree-Postorder-Traversal/"},{"title":"94. Binary Tree Inorder Traversal","text":"问题Given the root of a binary tree, return the inorder traversal of its nodes’ values. 中序遍历。先递归左子节点。然后将当前节点加入数组。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; inorderTraversal(TreeNode root) { ans = new ArrayList(); traversal(root); return ans; } private void traversal(TreeNode root){ if (root == null){ return; } traversal(root.left); ans.add(root.val); traversal(root.right); return; }}","link":"/2022/04/12/94-Binary-Tree-Inorder-Traversal/"},{"title":"289. Game of Life","text":"问题According to Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.” The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. 辅助方法，计算每个位置四周有生命的总和。根据规则填写到新数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public void gameOfLife(int[][] board) { int[][] ans = new int[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++){ for (int j = 0; j &lt; board[0].length; j++){ int neighbors = countNeighbors(board, i, j); if ( neighbors &lt; 2 &amp;&amp; board[i][j] == 1 ){ ans[i][j] = 0; } else if( neighbors &lt;= 3 &amp;&amp; board[i][j] == 1 ){ ans[i][j] = 1; } else if( neighbors &gt; 3 &amp;&amp; board[i][j] == 1 ){ ans[i][j] = 0; } else if( neighbors == 3 &amp;&amp; board[i][j] == 0){ ans[i][j] = 1; } } } for (int i = 0; i &lt; board.length; i++){ for (int j = 0; j &lt; board[0].length; j++){ board[i][j] = ans[i][j]; } } } private int countNeighbors(int[][] board, int r, int c){ int neighbors = 0; int row = board.length; int col = board[0].length; if(r + 1 &lt; row &amp;&amp; board[r+1][c] == 1){ neighbors++; } if(r - 1 &gt;= 0 &amp;&amp; board[r-1][c] == 1){ neighbors++; } if(c + 1 &lt; col &amp;&amp; board[r][c+1] == 1){ neighbors++; } if(c - 1 &gt;= 0 &amp;&amp; board[r][c-1] == 1){ neighbors++; } if(r + 1 &lt; row &amp;&amp; c + 1 &lt; col &amp;&amp; board[r+1][c+1] == 1){ neighbors++; } if(r + 1 &lt; row &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r+1][c-1] == 1 ){ neighbors++; } if(r - 1 &gt;= 0 &amp;&amp; c + 1 &lt; col &amp;&amp; board[r-1][c+1] == 1 ){ neighbors++; } if(r - 1 &gt;= 0 &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r-1][c-1] == 1 ){ neighbors++; } return neighbors; }}","link":"/2022/04/12/289-Game-of-Life/"},{"title":"59. Spiral Matrix II","text":"问题Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. 循环，创建一个上界和一个下界。当达到界限时，改变方向。更新上界和下界的数值。当上界小于下界时返回。 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int[][] generateMatrix(int n) { int[][] ans = new int[n][n]; int upperBound = n; int lowerBound = 0; int i = 0; int j = 0; int count = 1; ans[0][0] = 1; while ( lowerBound &lt; upperBound ){ while ( j &lt; upperBound-1 ){ j++; count++; ans[i][j] = count; } while ( i &lt; upperBound-1 ){ i++; count++; ans[i][j] = count; } while ( j &gt; lowerBound ){ j--; count++; ans[i][j] = count; } upperBound--; lowerBound++; while ( i &gt; lowerBound ){ i--; count++; ans[i][j] = count; } } return ans; }}","link":"/2022/04/13/59-Spiral-Matrix-II/"},{"title":"77. Combinations","text":"问题Given two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order. 回溯，构建搜索树。子节点取出的数值应大于父节点中取出的数值。直到树高度达到k后返回。 返回时，要new一个List，将原有list传入。否则添加到ans的值只是list的内存地址。ArrayList换成LinkedList可以优化一些速度，因为可以直接removeLast。（22ms -&gt; 16ms）i的范围限制在start到n-k+1，后面的限制容易被忽略，可以大幅度减枝，优化速度。（16ms -&gt; 1ms） 123456789101112131415161718192021class Solution { List&lt;List&lt;Integer&gt;&gt; ans; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { ans = new ArrayList&lt;&gt;(); backTrack(new LinkedList(),1,n,k); return ans; } private void backTrack(LinkedList&lt;Integer&gt; list, int start, int n, int k){ if (k == 0){ ans.add(new ArrayList(list)); return; } for (int i = start; i &lt;= n-k+1; i++){ list.add(i); backTrack(list, i+1, n, k-1); list.removeLast(); } }}","link":"/2022/04/13/77-Combinations/"},{"title":"102. Binary Tree Level Order Traversal","text":"问题Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). BFS搜索，用队列储存树节点。每次循环情到出一个层级所有的节点并放入列表。注意：需要记录队列的size，否则在for each循环时队列size会改变。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); if(root == null){ return ans; } Queue&lt;TreeNode&gt; q = new LinkedList(); q.add(root); while(!q.isEmpty()){ List&lt;Integer&gt; temp = new ArrayList(); int size = q.size(); for(int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); temp.add(curr.val); if(curr.left!=null){q.offer(curr.left);} if(curr.right!=null){q.offer(curr.right);} } ans.add(temp); } return ans; }}","link":"/2022/04/13/102-Binary-Tree-Level-Order-Traversal/"},{"title":"104. Maximum Depth of Binary Tree","text":"问题Given the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 递归，每次返回左子节点和右子节点中较大的结果+1。当节点为null时返回0。 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int maxDepth(TreeNode root) { if(root == null){ return 0; } return Math.max(maxDepth(root.left),maxDepth(root.right))+1; }} BFS搜索，每次倾倒出队列里所有的元素并将level+1。搜索完毕返回level。 1234567891011121314151617181920class Solution { public int maxDepth(TreeNode root) { if(root == null){ return 0; } Queue&lt;TreeNode&gt; q = new LinkedList(); q.offer(root); int level = 0; while(!q.isEmpty()){ int size = q.size(); for (int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); if(curr.left!=null){q.offer(curr.left);} if(curr.right!=null){q.offer(curr.right);} } level++; } return level; }}","link":"/2022/04/13/104-Maximum-Depth-of-Binary-Tree/"},{"title":"101. Symmetric Tree","text":"问题Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). 递归root1的左子节点和root2的右子节点以及root2的左子节点以及root1的右子节点。如两者不相等则返回false。如果传入的两个数值有一个为null，则两者不相等时返回false。反之返回true。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean isSymmetric(TreeNode root) { return isSymmetric(root,root); } public boolean isSymmetric(TreeNode root1, TreeNode root2){ if ( root1 == null || root2 == null ){ if(root1 == root2){return true;} else{return false;} } if ( root1.val == root2.val ){ return isSymmetric(root1.left,root2.right) &amp;&amp; isSymmetric(root1.right,root2.left); } else{ return false; } }}","link":"/2022/04/13/101-Symmetric-Tree/"},{"title":"46. Permutations","text":"问题Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. 回溯，建立搜索树。每次遍历nums中的元素。如果未遍历过该元素，则向链表及set中添加。向下递归，链表长度达到nums的长度时返回。然后从set和链表中移除上一个值，回溯到上一个节点。 1234567891011121314151617181920212223242526class Solution { List&lt;List&lt;Integer&gt;&gt; ans; HashSet&lt;Integer&gt; set; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { ans = new ArrayList(); set = new HashSet(); backTrack(new LinkedList(), nums, nums.length, nums.length); return ans; } private void backTrack(LinkedList&lt;Integer&gt; list,int[] nums, int n, int k){ if(k == 0){ ans.add(new ArrayList(list)); return; } for(int i = 0; i &lt; n ; i++){ if(!set.contains(nums[i])){ list.add(nums[i]); set.add(nums[i]); backTrack(list, nums , n, k-1); set.remove(nums[i]); list.removeLast(); } } }}","link":"/2022/04/13/46-Permutations/"},{"title":"784. Letter Case Permutation","text":"答案Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Return the output in any order. 当前字符如果为数字，则直接添加并递归。（将字符隐式转换为整数判断是否为数字，可提升速度。）当前字符如果为字母，则大小写分别添加到递归。（类似于回溯。）当字符串长度与搜寻字符串相等时，添加到列表。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { List&lt;String&gt; ans; String _s; public List&lt;String&gt; letterCasePermutation(String s) { ans = new ArrayList(); _s = s; backTrack(new StringBuilder(),0); return ans; } private void backTrack(StringBuilder sb, int i){ if(i == _s.length()){ ans.add(sb.toString()); return; } char curr = _s.charAt(i); if ( isNums(curr) ){ sb.append(curr); backTrack(sb, i+1); } else{ StringBuilder sb2 = new StringBuilder(sb); sb.append(Character.toLowerCase(curr)); backTrack(sb, i+1); sb2.append(Character.toUpperCase(curr)); backTrack(sb2, i+1); } } private boolean isNums(char c){ if ( (int)c &gt;= (int)'0' &amp;&amp; (int)c &lt;= (int)'9' ){ return true; } return false; }}","link":"/2022/04/13/784-Letter-Case-Permutation/"},{"title":"226. Invert Binary Tree","text":"问题Given the root of a binary tree, invert the tree, and return its root. 翻转二叉树。交换当前节点的左右子节点。分别递归其左右子节点。当当前节点的两个节点均为null时返回。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode invertTree(TreeNode root) { if (root == null){ return root; } invert(root); return root; } private void invert(TreeNode root){ if ( root.left == null &amp;&amp; root.right == null){ return; } TreeNode temp = root.left; root.left = root.right; root.right = temp; if ( root.left != null ){ invert(root.left); } if ( root.right != null ){ invert(root.right); } }}","link":"/2022/04/13/226-Invert-Binary-Tree/"},{"title":"70. Climbing Stairs","text":"问题You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 递归，传入根节点，进行BFS搜索。如果当前节点小于搜索的最低点，则抛弃该节点，继续搜索其右子节点。（由于是BST，右子节点大于节点本身）如果当前节点大于搜索的最高点，则抛弃该节点，继续搜索其左子节点。如果当前节点在搜索范围内，则保留该节点，继续递归该节点的两个子节点。最后返回根节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null){ return null; } if(root.val &lt; low){ return trimBST(root.right, low, high); } if(root.val &gt; high){ return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }}","link":"/2022/04/15/70-Climbing-Stairs/"},{"title":"198. House Robber","text":"问题You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. 动态规划。dp数组记录经过i个房子后可以获得的最大值。dp[i+1]的值等于dp[i-1]加上现有房子的钱（抢这个房子）与dp[i]的值（不抢这个房子）中的较大值。 12345678910111213141516class Solution { public int rob(int[] nums) { int[] money = new int[nums.length+1]; money[0] = 0; money[1] = nums[0]; for (int i = 1; i &lt; nums.length; i++){ money[i+1] = Math.max(money[i-1]+nums[i],money[i]); } return money[nums.length]; }}","link":"/2022/04/14/198-House-Robber/"},{"title":"120. Triangle","text":"问题Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. 动态规划，先将最左侧一列的值算出。然后[i+1][j+1]根据[i][j+1]和[i][j]得出。该动态规划表应是为三角形。因此当i等于j时，[i+1][i+j]的数值只根据[i][j]得出。 例子：代码里插入了一个print方法打印动态规划表。当输入列表 [[2],[3,4],[6,5,7],[4,1,8,3]] 时：其动态规划表为： 2, 0, 0, 0, 5, 6, 0, 0, 11, 10, 13, 0, 15, 11, 18, 16, 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int[][] dp = new int[triangle.size()][triangle.size()]; int min = Integer.MAX_VALUE; dp[0][0] = triangle.get(0).get(0); for (int i = 0; i &lt; triangle.size()-1; i++){ dp[i+1][0] = dp[i][0] + triangle.get(i+1).get(0); } for (int i = 0; i &lt; triangle.size()-1; i++){ for (int j = 0; j &lt;= i; j++){ if ( i == j ){ dp[i+1][j+1] = dp[i][j] + triangle.get(i+1).get(j+1); } else{ dp[i+1][j+1] = Math.min(dp[i][j] + triangle.get(i+1).get(j+1), dp[i][j+1] + triangle.get(i+1).get(j+1)); } } } //print(dp); for (int k = 0; k &lt; triangle.size(); k++){ min = Math.min(dp[triangle.size()-1][k],min); } return min; } private void print(int[][] text){ for (int i = 0; i &lt;text.length; i++){ for (int j = 0; j &lt; text[0].length; j++){ System.out.print(text[i][j]+&quot;, &quot;); } System.out.println(); } }}","link":"/2022/04/14/120-Triangle/"},{"title":"700. Search in a Binary Search Tree","text":"问题You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. 搜索二叉树。递归，如果现有根节点为空则返回空。如果根节点的值大于搜索值则搜索其左子节点。如果根节点的值小于搜索值则搜索其左右节点。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null){ return null; } else if (root.val &lt; val){ return searchBST(root.right,val); } else if (root.val &gt; val){ return searchBST(root.left,val); } else{ return root; } }}","link":"/2022/04/14/700-Search-in-a-Binary-Search-Tree/"},{"title":"701. Insert into a Binary Search Tree","text":"问题You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. 如果root为空则将值直接添加到根节点。辅助方法比较当前节点的值。如当前值大于添加的值，则检测左子节点是否为空。如不为空则递归左子节点。如当前值小于添加的值，则检测右子节点是否为空。如不为空则递归右子节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null){ root = new TreeNode(val); } insert(root,val); return root; } private void insert(TreeNode root, int val){ if (root.val &lt; val){ if (root.right == null){ root.right = new TreeNode(val); } insert(root.right, val); } else if (root.val &gt; val){ if (root.left == null){ root.left = new TreeNode(val); } insert(root.left, val); } return; }}","link":"/2022/04/14/701-Insert-into-a-Binary-Search-Tree/"},{"title":"112. Path Sum","text":"问题Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 递归，如果当前节点为null则返回false。计算并更新当前节点的值。如果当前节点为叶节点，且当前节点的值等于target，则返回true。递归左子节点和右子节点，返回两者的或运算。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { return hasPathSum(root,0,targetSum); } private boolean hasPathSum(TreeNode root, int parentVal, int target){ if (root == null){return false;} root.val = root.val + parentVal; if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target){ return true; } return ( hasPathSum(root.left, root.val, target) || hasPathSum(root.right, root.val, target)); }}","link":"/2022/04/14/112-Path-Sum/"},{"title":"191. Number of 1 Bits","text":"问题Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. 位运算，[n-1]的二进制数字为[n]的二进制数字退一位。二者的与运算结果相当于二进制下[n]减少最右侧的1。例如0100100的0100011两者的与运算结果为0100000。相当于减少了一位1。计算循环次数就可以得出1的总数。 1234567891011public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int count = 0; while(n != 0){ n = (n &amp; (n-1)); count++; } return count; }}","link":"/2022/04/14/191-Number-of-1-Bits/"},{"title":"231. Power of Two","text":"问题Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. 位运算，由于2^n^的二进制为[100…00]，当2^n^-1时，其二进制为[11..11]（少一位）。两者进行按位与（&amp;）运算，得到[000…00]，与0相等。 12345678class Solution { public boolean isPowerOfTwo(int n) { if (n &lt;= 0){ return false; } return (n &amp; (n - 1)) == 0; }} 递归，当（n &lt;= 0）时，返回false。当n等于1时，返回true。当（n % 2）有余数时，返回false。递归（n / 2）。 1234567891011121314class Solution { public boolean isPowerOfTwo(int n) { if (n &lt;= 0){ return false; } if (n == 1){ return true; } if (n%2 != 0){ return false; } return isPowerOfTwo(n/2); }}","link":"/2022/04/14/231-Power-of-Two/"},{"title":"669. Trim a Binary Search Tree","text":"问题Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds. DFS搜索，每次递归带上搜索的范围值。如果当前节点小于搜索范围，递归当前节点的右子节点。反之递归当前节点的左子节点。如果当前节点在搜索范围中，则其左子节点等于递归后的左子节点，右子节点等于递归后的右子节点。然后返回当前节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null){ return null; } if(root.val &lt; low){ return trimBST(root.right, low, high); } if(root.val &gt; high){ return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }}","link":"/2022/04/16/669-Trim-a-Binary-Search-Tree/"},{"title":"538. Convert BST to Greater Tree","text":"问题Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only &gt;-&gt;- nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */DFS搜索，设置一个成员变量记录上一个节点的值。先递归右侧节点。设置当前节点的值为自身的值加上temp中的值。更新temp中的值，再递归左侧节点。class Solution { int temp; public TreeNode convertBST(TreeNode root) { temp = 0; dfs(root); return root; } private void dfs(TreeNode root){ if(root == null){ return; } dfs(root.right); root.val += temp; temp = root.val; dfs(root.left); }}","link":"/2022/04/16/538-Convert-BST-to-Greater-Tree/"},{"title":"235. Lowest Common Ancestor of a BST","text":"问题Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” DFS搜索，如果当前节点为null，则返回null。如果当前节点小于p和q的值，则递归其左子节点。反之递归其右子节点。如果当前节点在p与q之间，则返回当前节点。该节点是p与q的Lowest Common Ancestor。 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null){ return null; } if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val){ return lowestCommonAncestor(root.left, p, q); } if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val){ return lowestCommonAncestor(root.right, p, q); } return root; }}","link":"/2022/04/16/235-Lowest-Common-Ancestor-of-a-BST/"},{"title":"653. Two Sum IV - Input is a BST","text":"问题Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. DFS搜索，每次递归时检查HashSet中是否有当前节点的值。如没有则将目标值减去当前节点的值加入HashSet。如有则返回true。递归左侧节点和右侧节点，并返回二者的或运算。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { HashSet&lt;Integer&gt; set; public boolean findTarget(TreeNode root, int k) { set = new HashSet(); return dfs(root,k); } private boolean dfs(TreeNode root, int k){ if(root == null){ return false; } if(set.contains(root.val)){ return true; } set.add(k - root.val); return dfs(root.left,k) || dfs(root.right,k); }}","link":"/2022/04/16/653-Two-Sum-IV-Input-is-a-BST/"},{"title":"136. Single Number","text":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. 位运算，对所有数值做二进制异或运算。两个同样的值异或运算会等于0，最后和与单独的数字相等。 123456789class Solution { public int singleNumber(int[] nums) { int ans = 0; for(int num : nums){ ans = ans ^ num; } return ans; }} 排序，然后遍历数组，如果第i个值不等于第i+1个则返回。 1234567891011class Solution { public int singleNumber(int[] nums) { Arrays.sort(nums); for(int i = 0; i &lt; nums.length-1; i+=2){ if(nums[i] != nums[i+1]){ return nums[i]; } } return nums[nums.length-1]; }}","link":"/2022/04/16/136-Single-Number/"},{"title":"169. Majority Element","text":"问题Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Boyer-Moore投票算法基本思想：众数的值为+1，非众数的值为-1。其加和作为投票值。遍历整个数组，由于众数数量大于非众数，因此最后结果一定为正数。 设置count记录票数，遍历数组。当count为0时，则将当前的数组设为众数。当之后的数字与其相等，则count+1，反之则-1。遍历完成后返回当前的众数。 根据以上规则，每次我们选择的众数，都是已遍历数组范围内出现最多次数的数值之一。 由于给定的数组的众数超过半数，因此遍历到最后的众数，一定是整个数组中出现最多次的数值。 核心就是对拼消耗。玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。 那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。 最后能剩下的必定是自己人。 12345678910111213141516171819class Solution { public int majorityElement(int[] nums) { int count = 0; int major = 0; for(int num : nums){ if(count == 0){ major = num; } if(major == num){ count++; } else{ count--; } } return major; }} 遍历数组，并将各个数值出现的次数记录在哈希表中。当出现的次数大于数组的一半，则该数值是众数。 123456789101112class Solution { public int majorityElement(int[] nums) { HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int num : nums){ map.put(num, map.getOrDefault(num,0)+1); if(map.get(num) &gt; nums.length/2){ return num; } } return -1; }}","link":"/2022/04/16/169-Majority-Element/"},{"title":"190. Reverse Bits","text":"问题Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. 创建返回值ans。每次向左移动一位ans，然后取n的尾数进行二进制或运算（相当于在尾部进行不进位的加和）。然后将n向左移动一位。 二进制下的或运算只保留两数间较大的位。(0011 | 0110 = 0111) 二进制下的与运算只保留两数间皆为1的位。(0011 &amp; 0110 = 0010) 掩码（Mask）是在二进制下进行与运算。以1作为掩码时，前面的31为皆为0，因此进行与运算后只保留最后一位。 因此(n &amp; 1)相当于n的二进制与000…001运算，只保留n的尾数。然后(ans &lt;&lt; 1)向左移动一位，用 | 操作将n的尾数加入ans。 1234567891011public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { int ans = 0; for(int i = 0; i &lt; 32; i++){ ans = (ans &lt;&lt; 1) | (n &amp; 1); n &gt;&gt;= 1; } return ans; }}","link":"/2022/04/16/190-Reverse-Bits/"},{"title":"34. Find First and Last Position in Sorted Array","text":"问题Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. 二分搜索，搜索中间项。中间项等于左侧和右侧指针的中点，根据搜索左侧边界和右侧边界选择二分向下舍去或是二分向上补足。当中间项小于目标，则更新左侧边界。若中间项大于目标，则更新右侧边界。当中间项等于目标时，根据搜索左侧边界还是右侧边界选择更新左侧或右侧。由于有可能有重复元素存在，因此需要继续二分搜索下去，直到右侧边界大于左侧边界。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int[] searchRange(int[] nums, int target) { return new int[]{searchLeft(nums,target),searchRight(nums,target)}; } private int searchRight(int[] nums, int target){ int left = 0; int right = nums.length-1; int mid = 0; int result = -1; while(left &lt;= right){ mid = (right-left)/2+left; if(nums[mid] &lt; target){ left = mid+1; } else if(nums[mid] &gt; target){ right = mid-1; } else{ result = mid; left = mid+1; } } return result; } private int searchLeft(int[] nums, int target){ int left = 0; int right = nums.length-1; int mid = 0; int result = -1; while(left &lt;= right){ mid = (right-left+1)/2+left; if(nums[mid] &lt; target){ left = mid+1; } else if(nums[mid] &gt; target){ right = mid-1; } else{ result = mid; right = mid-1; } } return result; }}","link":"/2022/04/16/34-Find-First-and-Last-Position-in-Sorted-Array/"},{"title":"15. 3Sum","text":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. 三数之和，重点是如何遍历后去除重复的数组。首先对数组进行排序。遍历数组，三个数中最小的数字为nums[i]。此时需要去除重复的nums[i]。如重复则继续下一次循环。此时设置双指针left和right，分别在nums[i]右侧的子数组的首尾。 当nums[i] + nums[left] + nums[right] &gt; 0时，后两个数的和需要减小，right指针向左移动。 当nums[i] + nums[left] + nums[right] &lt; 0时，后两个数的和需要增大，left指针向右移动。 当nums[i] + nums[left] + nums[right] = 0时，找到一个组合。 此时需要去除重复的nums[left]和nums[right]。如重复则更新left或right的指针。 将组合添加到返回列表。 最后返回列表。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i++){ int left = i+1; int right = nums.length-1; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]){ continue; } while(left &lt; right){ if(nums[i]+nums[left]+nums[right]==0){ while(left+1 &lt; nums.length &amp;&amp; nums[left] == nums[left+1]){ left++; } while(right-1 &gt; i &amp;&amp; nums[right] == nums[right-1]){ right--; } List&lt;Integer&gt; list = new ArrayList(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); left++; right--; } else if(nums[i]+nums[left]+nums[right]&gt;0){ right--; } else{ left++; } } } return ans; }}","link":"/2022/04/17/15-3Sum/"},{"title":"33. Search in Rotated Sorted Array","text":"There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. 二分搜索，二分后将会形成两个区间，一个区间是顺序的，另一个是无序的。如果target等于中间值则返回。分别处理两种情况下移动指针的方式。当顺序区间在左半边时：当target在顺序区间内，则更新右指针的位置。否则更新左指针位置。当顺序区间在右半边时：当target在顺序区间内，则更新左指针的位置。否则更新右指针位置。 123456789101112131415161718192021222324252627282930313233class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while(left &lt;= right){ int mid = (right - left) / 2 + left; if(nums[mid] == target){ return mid; } if( nums[mid] &gt;= nums[0] ){ if(target &gt;= nums[0] &amp;&amp; target &lt; nums[mid] ){ right = mid - 1; } else{ left = mid + 1; } } else{ if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[nums.length-1]){ left = mid + 1; } else{ right = mid -1; } } } return -1; }}","link":"/2022/04/17/33-Search-in-Rotated-Sorted-Array/"},{"title":"75. Sort Colors","text":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function. 快速排序是原地排序，因此此问题可以采用快速排序解决。 选择left上的元素pivot，设置一个指针index为left+1。遍历left+1至right的数组，如果遍历的值小于pivot则将nums[i]与nums[index]交换，然后将index向右移动。 因此index左侧的元素均小于pivot，index右侧的元素均大于pivot。最后将nums[index]与pivot交换，此时pivot左侧元素均小于它，右侧元素均大于它，因此index不需要再动。然后分别向下递归left至index-1，index+1至right。 12345678910111213141516171819202122232425262728class Solution { public void sortColors(int[] nums) { quickSort(nums, 0, nums.length-1); } private void quickSort(int[] nums, int left, int right){ if( right - left &lt; 1 ){ return; } int pivot = nums[left]; int index = left+1; for(int i = index; i &lt;= right; i++){ if(nums[i] &lt; pivot){ int temp = nums[index]; nums[index] = nums[i]; nums[i] = temp; index++; } } index--; nums[left] = nums[index]; nums[index] = pivot; quickSort(nums,left,index-1); quickSort(nums,index+1,right); }}","link":"/2022/04/17/75-Sort-Colors/"},{"title":"897. Increasing Order Search Tree","text":"Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. DFS搜索，在递归时将in-order遍历节点，并将其加入队列。从队列中挤出节点，将上一个节点的右子节点设置为下一个节点。同时需要将下一个节点的左子节点设置为null。` 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { Queue&lt;TreeNode&gt; q; public TreeNode increasingBST(TreeNode root) { q = new LinkedList(); dfs(root); TreeNode head = q.poll(); TreeNode curr = head; while(!q.isEmpty()){ curr.left = null; curr.right = q.poll(); curr = curr.right; } curr.left = null; return head; } private void dfs(TreeNode root){ if(root == null){ return; } dfs(root.left); q.offer(root); dfs(root.right); }}","link":"/2022/04/17/897-Increasing-Order-Search-Tree/"},{"title":"153. Find Minimum in Rotated Sorted Array","text":"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. 二分搜索，寻找断裂点。当left小于right时循环。每次计算出mid，分为两种情况： 如果nums[mid]小于nums[nums.length-1]，则右半侧为顺序的。 反之则左半侧为顺序，右半侧为无序的。以此来更新搜索范围。由于mid计算公式向下取整。当更新left时更新为mid+1，向前一格。当更新right时更新为mid。最后返回nums[left]。 12345678910111213141516171819class Solution { public int findMin(int[] nums) { return findBreakPoint(nums,0,nums.length-1); } private int findBreakPoint(int[] nums, int left, int right){ while(left &lt; right){ int mid = (right - left)/2 + left; if(nums[mid] &lt; nums[nums.length-1]){ right = mid; } else if(nums[mid] &gt;= nums[0]){ left = mid+1; } } return nums[left]; }}","link":"/2022/04/17/153-Find-Minimum-in-Rotated-Sorted-Array/"},{"title":"162. Find Peak Element","text":"A peak element is an element that is strictly greater than its neighbors. Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. You must write an algorithm that runs in O(log n) time. 二分搜索，由于只需要搜索任意一个山峰，因此只要向上走，一定可以走到一个峰。当中值的下一个值是增长时（向上爬山），则更新左侧指针的位置为中值+1。继续搜索下一个中值。否则更新右侧指针的位置为当前中值，等于向左侧进行搜索。最后返回左侧指针停留的位置。时间复杂度为O(logn)。 12345678910111213141516class Solution { public int findPeakElement(int[] num) { int left = 0; int right = num.length - 1; while (left &lt; right) { int mid1 = (right - left) / 2 + left; int mid2 = mid1 + 1; if (num[mid1] &lt; num[mid2]) left = mid1+1; else right = mid1; } return left; }} 一次遍历，找到峰值，返回其index。时间复杂度为O(n)。 123456789101112class Solution { public int findPeakElement(int[] nums) { int peak = 0; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &gt; nums[peak]){ peak = i; } } return peak; }} 分治法，每次将数组分为两组，向下递归。当数组长度为1时返回元素，比较返回来的两个数值的大小。返回其中的峰值index。此解法时间为O(nlogn)。 123456789101112131415161718192021class Solution { public int findPeakElement(int[] nums) { return findPeak(nums,0,nums.length-1); } private int findPeak(int[] nums, int left, int right){ if(left == right){ return left; } int mid = left + (right - left) / 2; int i = findPeak(nums, left, mid); int j = findPeak(nums, mid+1, right); if(nums[i] &gt; nums[j]){ return i; } else{ return j; } }}","link":"/2022/04/18/162-Find-Peak-Element/"},{"title":"82. Remove Duplicates from Sorted List II","text":"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. 使用队列暂存遍历的节点。初始化prev为一个dummy节点。如果当前节点不等于队列里节点的值，则倾倒出队列里的值。如果队列此时只有一个值，则将其添加到prev.next。遍历完毕后如果队列内只有一个值则将其设置到prev.next。最后返回dummy.next。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { Queue&lt;ListNode&gt; q = new LinkedList(); ListNode dummy = new ListNode(0); ListNode prev = dummy; ListNode curr = head; while(curr != null){ if(q.isEmpty() || curr.val == q.peek().val){ q.offer(curr); curr = curr.next; } else{ if(q.size()==1){ prev.next = q.poll(); prev = prev.next; prev.next = null; } else{ q.clear(); } } } if(q.size()==1){ prev.next = q.poll(); } return dummy.next; }}","link":"/2022/04/18/82-Remove-Duplicates-from-Sorted-List-II/"},{"title":"56. Merge Intervals","text":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. 先对数组进行排序。遍历数组，当前一个子数组与后一个子数组有重叠时，合并数组。 1234567891011121314151617181920212223class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[0],b[0])); int i = 0; List&lt;int[]&gt; ans = new ArrayList(); while( i &lt; intervals.length-1 ){ if(intervals[i][1] &gt;= intervals[i+1][0]){ intervals[i+1][0] = intervals[i][0]; intervals[i+1][1] = Math.max(intervals[i][1], intervals[i+1][1]); intervals[i] = null; } i++; } for(int[] interval : intervals){ if(interval != null){ ans.add(interval); } } return ans.toArray(new int[ans.size()][2]); }}","link":"/2022/04/18/56-Merge-Intervals/"},{"title":"706. Design HashMap","text":"Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map.void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. 哈希表，先设置一个素数Prime作为map的尺寸。（这里设置成素数是为了减少可能的碰撞。）创建一个Pair类记录key和value。 map初始化时需要生成一个LinkedList数组。 hash方法计算哈希值。用key % Prime并返回。 put方法，根据key计算其哈希值h。如果列表中有则重新设置当前Pair的value。 get方法，根据哈希值h搜索并查找链表中的Pair，如果找到则返回Pair，否则返回-1。 remove方法，根据哈希值h搜索并remove链表中的Pair。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class MyHashMap { final int PRIME = 1009; List&lt;Pair&gt;[] map; public MyHashMap() { map = new LinkedList[PRIME]; for(int i = 0; i &lt; PRIME; i++){ map[i] = new LinkedList&lt;Pair&gt;(); } } public void put(int key, int value) { int h = hash(key); for(Pair p : map[h]){ if(p.getKey() == key){ p.setValue(value); return; } } Pair p = new Pair(key, value); map[h].add(p); } public int get(int key) { int h = hash(key); for(Pair p : map[h]){ if(p.getKey() == key){ return p.value; } } return -1; } public void remove(int key) { int h = hash(key); for(Pair p : map[h]){ if(p.getKey() == key){ map[h].remove(p); return; } } } private int hash(int key){ return key % PRIME; }}class Pair { int key; int value; public Pair(int k, int v){ key = k; value = v; } public int getKey(){ return key; } public int getValue(){ return value; } public void setValue(int v){ value = v; }}/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */","link":"/2022/04/18/706-Design-HashMap/"},{"title":"119. Pascal&#39;s Triangle II","text":"Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: 根据杨辉三角形的规则递归。每次递归行数-1。根据上一行的返回值，生成新行的列表，然后返回。如果生成行数为0则返回{1}。 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { if(rowIndex == 0){ List&lt;Integer&gt; ret = new ArrayList(); ret.add(1); return ret; } List&lt;Integer&gt; arr = getRow(rowIndex - 1); List&lt;Integer&gt; ret = new ArrayList(); for(int i = 0; i &lt; arr.size()+1; i++){ if(i == 0 || i == arr.size()){ ret.add(1); } else{ ret.add(arr.get(i) + arr.get(i-1)); } } return ret; }}","link":"/2022/04/18/119-Pascal-s-Triangle-II/"},{"title":"48. Rotate Image","text":"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. 辅助方法getPixel计算旋转后的像素位置。旋转时候矩阵内的四个分区的像素会互相替换。因此需要将需要旋转的初始位置记录进入队列。旋转图像时根据getPixel方法计算出需要替换的位置。然后依次替换像素。 12345678910111213141516171819202122232425262728293031323334class Solution { public void rotate(int[][] matrix) { int n = matrix.length; Queue&lt;Integer&gt; queue = new LinkedList(); for (int p = 0; p &lt; n/2; p++){ for(int q = 0; q &lt; (n+1)/2; q++){ queue.offer(p * n + q); } } while(!queue.isEmpty()){ int i = queue.poll(); int INDEX = i; boolean flag = true; int temp = matrix[i/n][i%n]; while(i != INDEX || flag ){ flag = false; int j = getPixel(n, i); int swap = matrix[j / n][j % n]; matrix[j / n][j % n] = temp; temp = swap; i = j; } } } private int getPixel(int n, int o){ int row = o / n; int col = o % n; int newRow = col; int newCol = n - (row + 1); return (newRow * n) + newCol; }}","link":"/2022/04/18/48-Rotate-Image/"},{"title":"230. Kth Smallest Element in a BST","text":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. DFS搜索，遍历的时候更新全局变量count。采用中序搜索，当count等于k时，将全局变量ans设置为root.val。搜索完毕返回ans。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int ans; int count; public int kthSmallest(TreeNode root, int k) { ans = -1; count = 0; dfs(root,k); return ans; } private void dfs(TreeNode root, int k){ if(root == null){ return; } dfs(root.left,k); count++; if (k == count){ ans = root.val; } dfs(root.right,k); }}","link":"/2022/04/18/230-Kth-Smallest-Element-in-a-BST/"},{"title":"240. Search a 2D Matrix II","text":"Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. 将起始点设置为第一行的最后一列。如果搜寻目标大于该点则向下搜索。如果搜寻目标小于该点则向左搜索。 12345678910111213141516171819class Solution { public boolean searchMatrix(int[][] matrix, int target) { int i = 0; int j = matrix[0].length - 1; while(i &lt; matrix.length &amp;&amp; j &gt;= 0){ if(matrix[i][j] == target){ return true; } else if(matrix[i][j] &lt; target){ i++; } else{ j--; } } return false; }}","link":"/2022/04/19/240-Search-a-2D-Matrix-II/"},{"title":"99. Recover Binary Search Tree","text":"You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. DFS中序搜索，额外记录访问的前一个节点。如果当前节点与前一个节点的顺序不对，则暂且认为先后两个节点的位置均不正确。（前一个大于后一个的值，由于是第一个不满足递增条件的位置，因此前一个的位置一定是错误的。但此时当前值不一定是错误的。）继续递归，如果发现新的节点位置不正确，则后一个节点位置正确，更新当前节点为不正确的节点。（由于是第二个不满足递增条件的位置，因此当前值是错误的。）交换两个位置不正确的节点的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { TreeNode prev; boolean flag; TreeNode[] wrong; public void recoverTree(TreeNode root) { wrong = new TreeNode[2]; prev = new TreeNode(Integer.MIN_VALUE); flag = true; dfs(root); int swap = wrong[0].val; wrong[0].val = wrong[1].val; wrong[1].val = swap; } private void dfs(TreeNode root){ if(root == null){ return; } dfs(root.left); if(prev.val &gt; root.val){ if(flag){ wrong[0] = prev; flag = false; } wrong[1] = root; } prev = root; dfs(root.right); }}","link":"/2022/04/19/99-Recover-Binary-Search-Tree/"},{"title":"435. Non-overlapping Intervals","text":"Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. 首先对intervals按照后一项的大小进行排序。（直接将两数字相减作为比较值比Integer.compare方法更快。）贪心算法，将已取得的最大值max设置为最小整数值。遍历intervals，如果当前interval的左侧小于max，则不能选择该interval，计数加一。反之则可以选择interval，更新max的值为interval的最大值。返回总数。 12345678910111213141516class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a,b) -&gt; a[1] - b[1]); int max = Integer.MIN_VALUE; int count = 0; for(int[] interval : intervals){ if(interval[0] &lt; max){ count++; } else{ max = interval[1]; } } return count; }}","link":"/2022/04/19/435-Non-overlapping-Intervals/"},{"title":"844. Backspace String Compare","text":"辅助方法getNextValid，返回下一个有效值。将两个指针分别设置在两个字符串的尾部。当两指针有一个大于0时，进行循环。每次都搜索两个指针的下一个有效值。如果两个指针上的字符不同则返回false。 最后返回两个指针的停留位置是否相同。 注意：如果有一个字符串指针先更新到0以下，另一个指针仍有可能更新到一个“#”字符位置。此时最后的结应该是两个空字符串。因此需要继续循环一次，得出其是否会归到零以下。如果此时归零则两者的指针位置仍然相等。 因此即使getNextValid返回的下一个值为负数也应该保留其数值。 1234567891011121314151617181920212223242526272829303132class Solution { public boolean backspaceCompare(String s, String t) { int i = s.length()-1; int j = t.length()-1; while(i &gt;= 0 || j &gt;= 0){ i = getNextValid(s, i); j = getNextValid(t, j); if( i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; s.charAt(i) != t.charAt(j)){ return false; } i--; j--; } return (i == j); } private int getNextValid(String s, int start){ int i = start; int count = 0; while(i &gt;= 0 &amp;&amp; (s.charAt(i) == '#' || count != 0)){ if(s.charAt(i) == '#'){ count++; } else{ count--; } i--; } return i; }}","link":"/2022/04/19/844-Backspace-String-Compare/"},{"title":"986. Interval List Intersections","text":"You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3]. 设置两个指针，分别指向两个intervals的头部。循环，相交的left等于两者左端的较大值。right等于两者右端的较小值。只有在left小于right时，两个interval才相交，填入列表。然后更新两个interval中右端较小的指针。 12345678910111213141516171819202122class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { List&lt;int[]&gt; ans = new ArrayList(); int i = 0; int j = 0; while(i &lt; firstList.length &amp;&amp; j &lt; secondList.length){ int left = Math.max( firstList[i][0], secondList[j][0] ); int right = Math.min( firstList[i][1], secondList[j][1] ); if(left &lt;= right){ ans.add(new int[]{left, right}); } if(firstList[i][1] &lt; secondList[j][1]) i++; else j++; } int[][] ret = new int[ans.size()][2]; ans.toArray(ret); return ret; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { int i = 0; int j = 0; ArrayList&lt;int[]&gt; ans = new ArrayList(); int[] holdA; int[] holdB; while(i &lt; firstList.length &amp;&amp; j &lt; secondList.length){ holdA = firstList[i]; holdB = secondList[j]; int[] arr = new int[2]; if(holdA[0] &lt;= holdB[0] &amp;&amp; holdA[1] &gt;= holdB[1]){ ans.add(holdB); j++; } else if(holdA[0] &gt;= holdB[0] &amp;&amp; holdA[1] &lt;= holdB[1]){ ans.add(holdA); i++; } else if(holdA[0] &lt;= holdB[0] &amp;&amp; holdA[1] &gt;= holdB[0]){ arr[0] = holdB[0]; arr[1] = holdA[1]; ans.add(arr); i++; } else if(holdA[0] &gt;= holdB[0] &amp;&amp; holdB[1] &gt;= holdA[0]){ arr[0] = holdA[0]; arr[1] = holdB[1]; ans.add(arr); j++; } else if(holdA[1] &lt;= holdB[1]){ i++; } else{ j++; } } int[][] ret = new int[ans.size()][2]; ans.toArray(ret); return ret; }}","link":"/2022/04/19/986-Interval-List-Intersections/"},{"title":"173. Binary Search Tree Iterator","text":"Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.int next() Moves the pointer to the right, then returns the number at the pointer.Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. 此方法不用将所有节点一次性入栈，而是在获得next时更新栈内的节点，因此更省时间。将根节点的所有左子节点入栈，此时栈顶为最小值。next方法：返回当前的栈顶节点。如果栈顶节点存在右子节点，则将其所有的左子节点入栈。hasNext方法：返回栈是否为空的非值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class BSTIterator { Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) { stack = new Stack(); updateStack(root); } public int next() { TreeNode node = stack.pop(); updateStack(node.right); return node.val; } public boolean hasNext() { return !stack.isEmpty(); } private void updateStack(TreeNode root){ while(root != null){ stack.push(root); root = root.left; } }}/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ DFS搜索，中序搜索，从右子节点至左子节点，先将所有元素入栈。next方法：挤出栈顶并返回。hasNext方法： 返回栈是否为空的非值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class BSTIterator { Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) { stack = new Stack(); initiateStack(root); } public int next() { return stack.pop().val; } public boolean hasNext() { return !stack.isEmpty(); } private void initiateStack(TreeNode root){ if(root == null){ return; } initiateStack(root.right); stack.push(root); initiateStack(root.left); }}/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */","link":"/2022/04/20/173-Binary-Search-Tree-Iterator/"},{"title":"334. Increasing Triplet Subsequence","text":"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false. 贪心算法。将first与second初始化为最大值。first保存遍历过的最小值。second保存遍历过的大于之前最小值的最小值。 遍历数组。条件一：如果数字小于现在第一个值，则更新第一个值。（此时一定不满足条件二，因此可以安全地更新更小的数字。）条件二：如果数字大于第一个值，且小于第二个值，则更新第二个值。（此时第一个值已经被更新过了，满足第一个值小于第二个值。）条件三：如果数字大于第二个值，则返回true。（此时两个值一定都被更新过了，满足第一个值小于第二个值小于第三个值。） 注意：更新first后，second不会更新，但是second的存在可以确保曾经存在first小于second。如果此时数字大于second，则数组中存在Triplet Subsequence。 12345678910111213141516171819class Solution { public boolean increasingTriplet(int[] nums) { int first = Integer.MAX_VALUE; int second = Integer.MAX_VALUE; for(int num : nums){ if(num &lt; first){ first = num; } else if(num &gt; first &amp;&amp; num &lt; second){ second = num; } else if(num &gt; second){ return true; } } return false; }} 双向遍历，逐渐收紧搜索窗口。设置i，k两个指针分别在头尾。当nums[j] &lt;= nums[i]，则更新i指针为j。当nums[j] &gt;= nums[k]，则更新k指针为j。如果找到符合条件的nums[i] &lt; nums[j] &lt; nums[k]则返回。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public boolean increasingTriplet(int[] nums) { boolean flag = true; int i = 0; int k = nums.length -1 ; int j; int count = 1; while(i &lt; k &amp;&amp; i + count &lt; k){ if(flag){ j = i + count; if(nums[i] &gt;= nums[j]){ i = j; count = 1; flag = true; continue; } else if(nums[j] &lt; nums[k]){ return true; } flag = !flag; } else{ j = k - count; if(nums[k] &lt;= nums[j]){ k = j; count = 1; flag = true; continue; } else if(nums[j] &gt; nums[i]){ return true; } else{ count++; } flag = !flag; } } return false; }}","link":"/2022/04/20/334-Increasing-Triplet-Subsequence/"},{"title":"438. Find All Anagrams in a String","text":"Given two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 滑动窗口。采用两个数组分别计算两个字符串中字符出现的数量。 滑动窗口时，维护数组中字符串中字符出现的次数。循环，判断两个字符串是否相等，如果相等，则将当前的左指针添加进答案。移动窗口的左右指针，在数组中减少前一项出现的次数，增加后一项出现的次数。 通过维护一个表示两个字符串中字符差值的数组，可以将算法优化算法，而不必进行两个数组的比较。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { List&lt;Integer&gt; ans = new ArrayList(); if(p.length()&gt;s.length()){ return ans; } int[] alphabet = new int[26]; int[] window = new int[26]; for(int i = 0; i &lt; p.length(); i++){ alphabet[p.charAt(i) - 'a']++; window[s.charAt(i) - 'a']++; } int i = 0; int j = p.length(); while(j &lt; s.length()){ if(Arrays.equals(alphabet, window)){ ans.add(i); } window[s.charAt(i) - 'a']--; window[s.charAt(j) - 'a']++; i++; j++; } if(Arrays.equals(alphabet, window)){ ans.add(i); } return ans; }}","link":"/2022/04/20/438-Find-All-Anagrams-in-a-String/"},{"title":"238. Product of Array Except Self","text":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. 当前数字之外的积等于左边所有数字的积乘以右边所有数字的积。因此可以维护两个数组，分别计算从左到右的乘积，和从右到左的乘积。 由于返回答案不算占用空间，因此可以将左侧乘积的数组保存在答案数组上。然后在遍历时，从右至左遍历，使用一个变量储存右边的乘积，直接将两者的乘积更新在答案数组上。此时空间复杂度为O(1)。 123456789101112131415161718class Solution { public int[] productExceptSelf(int[] nums) { int[] ans = new int[nums.length]; ans[0] = 1; for(int i = 1; i &lt; nums.length; i++){ ans[i] = ans[i-1] * nums[i-1]; } int rightProduct = 1; for(int j = nums.length-1; j &gt;=0; j--){ ans[j] = ans[j] * rightProduct; rightProduct *= nums[j]; } return ans; }}","link":"/2022/04/20/238-Product-of-Array-Except-Self/"},{"title":"560. Subarray Sum Equals K","text":"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. 对于数组中每个数字，计算其前缀的和。前缀[i]减去前缀[j]的差，等于[j]-[i]之间数字的和。（类似一种DP，数组可以用一个变量代替。） 因此，原题目等于寻找找 前缀[i]-前缀[j] = k。用哈希表储存已经遍历过的前缀和出现的次数。每次遍历时先查看哈希表内是否有当前[前缀和-k]的键在。如果有则加入到count中。（哈希表中需要提前放入一个0键，值等于1，为了计算[前缀和-k]等于0的情况。） 1234567891011121314151617class Solution { public int subarraySum(int[] nums, int k) { int[] sum = new int[nums.length + 1]; HashMap&lt;Integer, Integer&gt; map = new HashMap(); int count = 0; map.put(0, 1); for(int i = 1; i &lt;= nums.length; i++){ sum[i] = sum[i-1] + nums[i-1]; count += map.getOrDefault(sum[i]-k, 0); map.put(sum[i], map.getOrDefault(sum[i], 0) + 1); } return count; }}","link":"/2022/04/20/560-Subarray-Sum-Equals-K/"},{"title":"209. Minimum Size Subarray Sum","text":"Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, …, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 滑动窗口，先取最左侧数字。记录窗口的最小值。如果小于目标值，则右侧窗口向右移动，扩大窗口。更新窗口内的值。如果大于等于目标值，则左侧窗口向右移动，缩小窗口。更新窗口内的值。同时如果窗口大小小于最小值则更新窗口最小值。 1234567891011121314151617181920class Solution { public int minSubArrayLen(int target, int[] nums) { int min = Integer.MAX_VALUE; int left = 0; int right = 0; int sum = nums[0]; while(right &lt; nums.length){ if(sum &gt;= target){ min = Math.min(min, right - left + 1); sum -= nums[left]; left++; } else{ right++; if(right &lt; nums.length) sum += nums[right]; } } return min == Integer.MAX_VALUE ? 0 : min; }} 计算前缀和。前缀和[j]与前缀和的[i]的差就是i+1到j的和。因此需要找到sum[j] - sum[i] &gt;= k。暴力枚举的话需要O(n^2^)的时间复杂度。 由于前缀和是有序的，因此我们可以采用二分搜索。寻找sum[j] - k &gt;= sum[i]。Arrays.binarySearch方法可以返回查找到的目录。如果没有该值，方法会返回一个负数，其取反（x取反相当于[-(x+1)]）的值就是应该插入的目录。将ans设置为无限大，如果(index - i)小于最小值则更新到ans。 时间复杂度O(nlogn)。 123456789101112131415161718192021class Solution { public int minSubArrayLen(int target, int[] nums) { int[] sum = new int[nums.length+1]; for(int i = 1; i &lt;= nums.length; i++){ sum[i] = sum[i-1] + nums[i-1]; } int ans = Integer.MAX_VALUE; for(int i = 0; i &lt; sum.length; i++){ int search = sum[i] + target; int index = Arrays.binarySearch(sum, search); if(index &lt; 0){ index = ~index; } if(index &lt; sum.length){ ans = Math.min(ans, index - i); } } return ans == Integer.MAX_VALUE ? 0 : ans; }}","link":"/2022/04/20/209-Minimum-Size-Subarray-Sum/"},{"title":"713. Subarray Product Less Than K","text":"Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. 滑动窗口，维护一个窗口内的乘积。当乘积小于目标值时，窗口右侧向右移动。每加入一个新数值，可以增加(j-i+1)个组合。当乘积大于目标时，窗口左侧向右移动。 123456789101112131415161718192021class Solution { public int numSubarrayProductLessThanK(int[] nums, int k) { int i = 0; int j = 0; int product = nums[0]; int count = 0; while(i &lt; nums.length &amp;&amp; j &lt; nums.length){ if(product &lt; k){ count += (j - i) + 1; j++; if(j &lt; nums.length ) product *= nums[j]; } else{ product /= nums[i]; i++; } } return count; }}","link":"/2022/04/20/713-Subarray-Product-Less-Than-K/"},{"title":"705. Design HashSet","text":"Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. 计算哈希值，使用数组实现Hash Set。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyHashSet { int PRIME = 1009; List&lt;Integer&gt;[] data; public MyHashSet() { data = new List[PRIME]; for(int i = 0; i &lt; PRIME; i++){ data[i] = new LinkedList&lt;Integer&gt;(); } } public void add(int key) { if(!contains(key)){ int h = getHash(key); data[h].add(key); } } public void remove(int key) { int h = getHash(key); data[h].remove(new Integer(key)); } public boolean contains(int key) { int h = getHash(key); for( int num : data[h] ){ if( num == key ){ return true; } } return false; } private int getHash(int o){ return o % PRIME; }}/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */","link":"/2022/04/21/705-Design-HashSet/"},{"title":"200. Number of Islands","text":"Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 遍历所有点，如果等于1则对其进行DFS搜索。在搜索的同时将1设为0。如果等于0则递归返回。 12345678910111213141516171819202122232425262728293031323334353637class Solution { char[][] area; public int numIslands(char[][] grid) { area = grid; int count = 0; for(int i = 0; i &lt; area.length; i++){ for(int j = 0; j &lt; area[0].length; j++){ if(area[i][j] == '1'){ dfs(i, j); count++; } } } return count; } private void dfs(int i, int j){ if(area[i][j] == '0'){ return; } area[i][j] = '0'; if( i+1 &lt; area.length ){ dfs(i+1, j); } if( i-1 &gt;= 0 ){ dfs(i-1, j); } if( j+1 &lt; area[0].length ){ dfs(i, j+1); } if( j-1 &gt;= 0 ){ dfs(i, j-1); } }}","link":"/2022/04/21/200-Number-of-Islands/"},{"title":"547. Number of Provinces","text":"There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. DFS搜索，当map[i][i] = 1时加入搜索。搜索时将map[i][i]设为0。遍历并递归其数列。当map[i][i]等于0时，返回。 123456789101112131415161718192021222324252627class Solution { int[][] map; public int findCircleNum(int[][] isConnected) { map = isConnected; int count = 0; for(int i = 0; i &lt; isConnected.length; i++){ if(map[i][i] == 1){ count++; dfs(i); } } return count; } private void dfs(int i){ if(map[i][i] == 0){ return; } map[i][i] = 0; for(int j = 0; j &lt; map[0].length; j++){ if(map[i][j] == 1){ dfs(j); } } }}","link":"/2022/04/21/547-Number-of-Provinces/"},{"title":"409. Longest Palindrome","text":"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, “Aa” is not considered a palindrome here. 1234567891011121314151617181920212223class Solution { public int longestPalindrome(String s) { int[] alphabet = new int['z' - 'A' + 1]; int count = 0; int total = s.length(); for(int i = 0; i &lt; s.length(); i++){ int index = s.charAt(i) - 'A'; alphabet[index]+=1; if( alphabet[index] == 2 ){ total -= 2; count += 2; alphabet[index] = 0; } } if(total != 0){ count++; } return count; }}","link":"/2022/04/21/409-Longest-Palindrome/"},{"title":"415. Add Strings","text":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. 按照正常加法计算方法即可。先将指针设置在两个String的末尾。每次计算位置上加和的结果。最后需要将字符串翻转过来。 1234567891011121314151617181920212223class Solution { public String addStrings(String num1, String num2) { int i = num1.length() - 1; int j = num2.length() - 1; int carry = 0; StringBuffer ans = new StringBuffer(); while( i &gt;= 0 || j &gt;= 0 || carry &gt; 0){ int x = i &gt;= 0 ? num1.charAt(i) - '0' : 0; int y = j &gt;= 0 ? num2.charAt(j) - '0' : 0; int result = x + y + carry; ans.append(result % 10); carry = result / 10; i--; j--; } ans.reverse(); return ans.toString(); }}","link":"/2022/04/21/415-Add-Strings/"},{"title":"290. Word Pattern","text":"Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. 先将s分割成数组。如果words的长度和pattern的长度不同则返回false。用长度为26的数组储存pattern的字符。同时遍历words和pattern，将pattern的字符换算成数字作为index，将words[i]填入数组。如果数组中已经有word存在，则检查新的word和数组内的word是否相等。如果不相等，则返回false。 最后遍历数组，比对各个字符中对应的word是否相等，如果有相等的，则返回false。由于数组长度固定，因此这个操作的时间复杂度是O(1)。 1234567891011121314151617181920212223242526272829303132333435class Solution { public boolean wordPattern(String pattern, String s) { String[] words = s.split(&quot; &quot;); String[] alphabet = new String[26]; if(words.length != pattern.length()){ return false; } for(int i = 0; i &lt; pattern.length(); i++){ if( alphabet[pattern.charAt(i) - 'a'] != null){ if(!alphabet[pattern.charAt(i) - 'a'].equals(words[i])){ return false; } } else{ alphabet[pattern.charAt(i) - 'a'] = words[i]; } } for(int i = 0; i &lt; alphabet.length; i++){ for(int j = i+1; j &lt; alphabet.length; j++){ if(alphabet[i] == null || alphabet[j] == null){ continue; } if(alphabet[i].equals(alphabet[j])){ return false; } } } return true; }}","link":"/2022/04/21/290-Word-Pattern/"},{"title":"763. Partition Labels","text":"You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts. 将英文字母出现的首尾作为intervals看待。根据字符创建数组并填入左右的index。根据左侧index排序数组。 从左至右，如果intervals有交集，则合并。否则在答案中添加当前interval的长度。 12345678910111213141516171819202122232425262728class Solution { public List&lt;Integer&gt; partitionLabels(String s) { int[][] alphabet = new int[26][2]; int head = s.charAt(0) - 'a'; for(int i = 0; i &lt; s.length(); i++){ int index = s.charAt(i) - 'a'; if(head != index &amp;&amp; alphabet[index][0] == 0) alphabet[index][0] = i; alphabet[index][1] = i; } Arrays.sort(alphabet, (a,b) -&gt; a[0] - b[0]); List&lt;Integer&gt; ans = new ArrayList(); int[] hold = alphabet[0]; for(int i = 1; i &lt; alphabet.length; i++){ if(alphabet[i][0] &lt;= hold[1]){ hold[1] = Math.max(hold[1], alphabet[i][1]); } else{ ans.add(hold[1]-hold[0]+1); hold = alphabet[i]; } } ans.add(hold[1]-hold[0]+1); return ans; }}","link":"/2022/04/21/763-Partition-Labels/"},{"title":"117. Populating Next Pointers in Each Node II","text":"Given a binary tree 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 struct Node { int val; Node *left; Node *right; Node *next;}```javaPopulate each next pointer to point to its next right node. If &gt; there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL.BFS搜索，从右至左将每层节点放入队列。用一个size记录该层级放入节点的数量，每次循环将size-1，当size归零时放入新一层级的节点。```java/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/class Solution { public Node connect(Node root) { if(root == null) return root; Queue&lt;Node&gt; q = new LinkedList(); q.add(root); while(!q.isEmpty()){ int size = q.size(); Node next = null; while(size &gt; 0){ size--; Node curr = q.poll(); curr.next = next; next = curr; if(curr.right != null) q.add(curr.right); if(curr.left != null) q.add(curr.left); } } return root; }}","link":"/2022/04/21/117-Populating-Next-Pointers-in-Each-Node-II/"},{"title":"572. Subtree of Another Tree","text":"Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself. 帮助方法isEqual，DFS搜索判断两个节点的子节点是否完全相同。DFS搜索，如果两个根节点的值相等则返回，且调用isEqual方法，如果子节点都相同则返回。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { return dfs(root, subRoot) != null; } private TreeNode dfs(TreeNode root, TreeNode subRoot){ if(root == null) return null; if(root.val == subRoot.val &amp;&amp; isEqual(root, subRoot)) return root; if(dfs(root.left, subRoot) != null ) return dfs(root.left, subRoot); else return dfs(root.right, subRoot); } private boolean isEqual(TreeNode root, TreeNode subRoot){ if(root == null || subRoot == null) return root == subRoot; if(root.val != subRoot.val) return false; return isEqual(root.left, subRoot.left) &amp;&amp; isEqual(root.right, subRoot.right); }}","link":"/2022/04/22/572-Subtree-of-Another-Tree/"},{"title":"1091. Shortest Path in Binary Matrix","text":"Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0.All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).The length of a clear path is the number of visited cells of this path. 由于不能重复搜索，且需要在搜索时将搜索过的位置改变，因此需要采用BFS逐一层级的搜索。逐层级搜索并记录层级。最后返回层级+1即可。（还有更快的优化算法A*） 整体没有改变太多，基本还是方法二那种。启发式函数改为切比雪夫距离距离。距离计算方法有很多，常用启发式函数有这几种。选择合适的启发式函数有利于速度的提升。这题可以用好几种启发式函数，初学都可以试着都写一下。 曼哈顿距离（Manhattan Distance）一般只能在四个方向上移动时用（右、左、上、下） 对角线距离（Diagonal Distance）：当我们只允许向八个方向移动时用（国际象棋中的王移动方式那种） 欧几里得距离（Euclidean Distance）：不受限制，允许向任何方向移动时。 切比雪夫距离（Chebyshev Distance）：可参考：[https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/](LeetCode 1266) 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int shortestPathBinaryMatrix(int[][] grid) { int n = grid[0].length; int m = grid.length; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int count = 0; q.add(0); int size = q.size(); while(!q.isEmpty()){ for(int k = 0; k &lt; size; k++){ int curr = q.poll(); int i = curr / n; int j = curr % n; if(grid[i][j] ==1) continue; if(i == m-1 &amp;&amp; j == n-1 &amp;&amp; grid[i][j] == 0) return count+1; if(grid[i][j] == 0){ grid[i][j] = 1; if(i+1&lt;n &amp;&amp; j+1&lt;n) q.add((i+1) * n + (j+1)); if(i+1&lt;n &amp;&amp; j-1&gt;=0) q.add((i+1) * n + (j-1)); if(i+1&lt;n) q.add((i+1) * n + j); if(i-1&gt;=0 &amp;&amp; j-1&gt;=0) q.add((i-1) * n + (j-1)); if(i-1&gt;=0 &amp;&amp; j+1&lt;n) q.add((i-1) * n + (j+1)); if(j+1&lt;n) q.add(i * n + (j+1)); if(j-1&gt;=0) q.add(i * n + (j-1)); if(i-1&gt;=0) q.add((i-1) * n + j); } } size = q.size(); count++; } return -1; }}","link":"/2022/04/23/1091-Shortest-Path-in-Binary-Matrix/"},{"title":"535. Encode and Decode TinyURL","text":"Note: This is a companion problem to the System Design problem: Design TinyURL.TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the Solution class: Solution() Initializes the object of the system. String encode(String longUrl) Returns a tiny URL for the given longUrl. String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object. 计算传入连接的哈希值。将其作为key放入map中。解码时将url转换为key，取出map中的value。 12345678910111213141516171819public class Codec { HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); // Encodes a URL to a shortened URL. public String encode(String longUrl) { int key = longUrl.hashCode(); map.put(key, longUrl); return Integer.toString(key); } // Decodes a shortened URL to its original URL. public String decode(String shortUrl) { return map.get(Integer.parseInt(shortUrl)); }}// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(url));","link":"/2022/04/23/535-Encode-and-Decode-TinyURL/"},{"title":"797. All Paths From Source to Target","text":"Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]). 回溯。DFS搜索所有的路径。当搜索到最后一个位置时，保存动态数组并返回。（此处需要深拷贝数组。）回到上一层，取走动态数组的最后一个节点。 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) { List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;(); dfs(ret, new ArrayList&lt;&gt;(), graph, 0); return ret; } private void dfs(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[][] graph, int i){ if( i == graph.length - 1){ arr.add(i); ret.add(new ArrayList(arr)); return; } arr.add(i); for( int j : graph[i] ){ dfs(ret, arr, graph, j); arr.remove(arr.size()-1); } }}","link":"/2022/04/23/797-All-Paths-From-Source-to-Target/"},{"title":"49. Group Anagrams","text":"Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 利用JAVA中字符串会固定内存地址。（因此在进行字符串操作时是生成了新的对象。）遍历每个单词，记录26个字母出现的次数，并映射到字符数组上。将字符数组转换成字符串，生成一个新的字符串。 将字符串作为key放入map中，value储存原有单词。（字符串的内存地址固定，因此同样的字符串可以被搜索到。） 123456789101112131415161718192021class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { List&lt;List&lt;String&gt;&gt; ret = new ArrayList&lt;&gt;(); HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String word : strs){ char[] alphabet = new char[26]; for(int j = 0; j &lt; word.length(); j++){ alphabet[word.charAt(j)-'a']++; } String s = new String(alphabet); List&lt;String&gt; str = map.getOrDefault(s, new ArrayList&lt;String&gt;()); str.add(word); map.put(s, str); } for(String key : map.keySet()){ ret.add(map.get(key)); } return ret; }}","link":"/2022/04/23/49-Group-Anagrams/"},{"title":"43. Multiply Strings","text":"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. 两个字符串的位数做乘法，每次计算进位。当前位等于自身加上计算结果的个位（由于有之前的进位存在。），下一位等于计算结果的十位。 123456789101112131415161718192021222324252627282930class Solution { public String multiply(String num1, String num2) { int m = num1.length(); int n = num2.length(); if( num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)){ return &quot;0&quot;; } int[] product = new int[m+n]; char[] arr1 = num1.toCharArray(); char[] arr2 = num2.toCharArray(); for(int i = m-1; i &gt;= 0; i--){ for(int j = n-1; j &gt;=0; j--){ int sum = product[i+j+1] + (arr1[i] - '0') * (arr2[j] - '0'); int curr = sum % 10; int carry = sum / 10; product[i+j] += carry; product[i+j+1] = curr; } } StringBuffer sb = new StringBuffer(); for(int k = 0; k &lt; m+n; k++ ){ if(k == 0 &amp;&amp; product[k] == 0 ) continue; sb.append(product[k]); } return sb.toString(); }}","link":"/2022/04/23/43-Multiply-Strings/"},{"title":"78. Subsets","text":"Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. 回溯，先添加一个空集，然后回溯各个单独节点。递归时传入数组内当前数字之后的节点。 1234567891011121314151617181920212223242526class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); ret.add(new ArrayList&lt;&gt;()); for(int i = 0; i &lt; nums.length ; i++){ backtrack(ret, new ArrayList&lt;&gt;(), nums, i); } return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] nums, int i){ if(i == nums.length-1){ arr.add(nums[i]); ret.add(new ArrayList&lt;&gt;(arr)); return; } arr.add(nums[i]); ret.add(new ArrayList&lt;&gt;(arr)); for(int j = i+1; j &lt; nums.length; j++){ backtrack(ret, arr, nums, j); arr.remove(arr.size()-1); } }}","link":"/2022/04/24/78-Subsets/"},{"title":"1396. Design Underground System","text":"An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the UndergroundSystem class: void checkIn(int id, string stationName, int t) A customer with a card ID equal to id, checks in at the station stationName at time t. A customer can only be checked into one place at a time. void checkOut(int id, string stationName, int t) A customer with a card ID equal to id, checks out from the station stationName at time t. double getAverageTime(string startStation, string endStation) Returns the average time it takes to travel from startStation to endStation. The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation. The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation. There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 &lt; t2. All events happen in chronological order. 两个哈希表，第一个暂存id。第二个用来储存“站点——站点”和路线中的总用时，路线中的总人数。最后返回总用时除以总人数。（一开始采用的算法没有考虑id重复进站，和id出站进站不同的情况。） 12345678910111213141516171819202122232425262728293031323334353637class UndergroundSystem { HashMap&lt;Integer, Pair&lt;String, Integer&gt;&gt; inMap; HashMap&lt;String, int[]&gt; outMap; public UndergroundSystem() { inMap = new HashMap&lt;Integer, Pair&lt;String, Integer&gt;&gt;(); outMap = new HashMap&lt;String, int[]&gt;(); } public void checkIn(int id, String stationName, int t) { Pair&lt;String, Integer&gt; data = new Pair(stationName, t); inMap.put(id, data); } public void checkOut(int id, String stationName, int t) { Pair&lt;String, Integer&gt; data = inMap.get(id); String route = data.getKey() + &quot;-&quot; + stationName; int[] routeData = outMap.getOrDefault(route, new int[2]); routeData[0] += t - data.getValue(); routeData[1]++; outMap.put(route, routeData); } public double getAverageTime(String startStation, String endStation) { String route = startStation + &quot;-&quot; + endStation; return outMap.get(route)[0] / (double) outMap.get(route)[1]; }}/** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem obj = new UndergroundSystem(); * obj.checkIn(id,stationName,t); * obj.checkOut(id,stationName,t); * double param_3 = obj.getAverageTime(startStation,endStation); */","link":"/2022/04/24/1396-Design-Underground-System/"},{"title":"5. Longest Palindromic Substring","text":"Given a string s, return the longest palindromic substring in s. getLength方法，计算每一个字符位置的回文长度。（将left填成i+1，right填成i则可以搜索偶数回文的长度。）如果出现更长的回文，则根据返回的长度，和当前的i计算出字符串的范围。 12345678910111213141516171819202122232425262728class Solution { public String longestPalindrome(String s) { int best = 0; int left = 0; int right = 0; for(int i = 0; i &lt; s.length(); i++){ int length = Math.max(getLength(s,i,i), getLength(s,i+1,i)); if(best &lt; length){ left = i-((length-1)/2-1); right = i+(length/2); best = length; } } return s.substring(left,right); } private int getLength(String s, int left, int right){ while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; left &lt; s.length()){ if(s.charAt(left) == s.charAt(right)){ left--; right++; } else break; } return right - left + 1; }}","link":"/2022/04/24/5-Longest-Palindromic-Substring/"},{"title":"187. Repeated DNA Sequences","text":"The DNA sequence is composed of a series of nucleotides abbreviated as ‘A’, ‘C’, ‘G’, and ‘T’. For example, “ACGAATTCCG” is a DNA sequence.When studying DNA, it is useful to identify repeated sequences within the DNA. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. 哈希表 + 滑动窗口 + 位操作。将四个字符映射到四个二进制字符上。这样字符串就可以用20bit表示。这样就可以用一个整数来表示这四个字符。然后采用哈希表记录出现次数。 12345678910111213141516171819202122232425262728class Solution { static final int L = 10; public List&lt;String&gt; findRepeatedDnaSequences(String s) { List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(s.length() &lt; L) return ret; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0; int right = 10; int[] bin = new int[26]; bin['A'-'A'] = 0; bin['T'-'A'] = 1; bin['C'-'A'] = 2; bin['G'-'A'] = 3; int x = 0; for(int i = 0; i &lt; L-1; i++){ x = (x &lt;&lt; 2) | bin[s.charAt(i)-'A']; } for(int i = 0; i &lt;= s.length() - L; i++){ x = ((x &lt;&lt; 2) | bin[s.charAt(i + L -1)-'A']) &amp; ((1 &lt;&lt; L * 2) - 1); map.put(x, map.getOrDefault(x, 0)+1); if(map.get(x) == 2) ret.add(s.substring(i, i+L)); } return ret; }} 遍历将字字符串加入哈希表并记录出现次数，然后返回出现次数大于1的字符串。注意在循环时就可以直接添加结果到列表，这样可以减少操作。 1234567891011121314151617class Solution { public List&lt;String&gt; findRepeatedDnaSequences(String s) { List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0; int right = 10; while(right &lt;= s.length()){ String sub = s.substring(left, right); map.put(sub, map.getOrDefault(sub, 0)+1); if(map.get(sub) == 2) ret.add(sub); left++; right++; } return ret; }}","link":"/2022/04/24/187-Repeated-DNA-Sequences/"},{"title":"284. Peeking Iterator","text":"Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: PeekingIterator(Iterator nums) Initializes the object with the given integer iterator iterator. int next() Returns the next element in the array and moves the pointer to the next element. boolean hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer. Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions. 使用队列储存迭代器里的数据，根据需要返回队列里的数据。 123456789101112131415161718192021222324252627282930// Java Iterator interface reference:// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.htmlclass PeekingIterator implements Iterator&lt;Integer&gt; { Queue&lt;Integer&gt; q; public PeekingIterator(Iterator&lt;Integer&gt; iterator) { // initialize any member here. q = new LinkedList&lt;&gt;(); while(iterator.hasNext()){ q.add(iterator.next()); } } // Returns the next element in the iteration without advancing the iterator. public Integer peek() { return q.peek(); } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next() { return q.poll(); } @Override public boolean hasNext() { return !q.isEmpty(); }}","link":"/2022/04/25/284-Peeking-Iterator/"},{"title":"47. Permutations II","text":"Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. 首先排序，对于有重复数据的数组，排序可以方便剪枝。回溯，每次遍历数组内的元素。创建一个数组记录元素是否已被遍历。遍历时如果数组已经被记录，或者当前元素与数组中的上一个元素相等，且上一个数组未被选择，则跳过。（如果上一个同样的数字没被选择，则放弃这个排列。即在元素相同时，优先选择前面的元素进行排列） 123456789101112131415161718192021222324252627class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(nums); int[] visited = new int[nums.length]; backtracking(ret, new ArrayList&lt;&gt;(), visited , nums); return ret; } private void backtracking(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] visited, int[] nums){ if(arr.size() == nums.length){ ret.add(new LinkedList&lt;&gt;(arr)); return; } for(int i = 0; i &lt; nums.length; i++){ if(visited[i] == 1) continue; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i-1] == 0) continue; arr.add(nums[i]); visited[i] = 1; backtracking(ret, arr, visited, nums); visited[i] = 0; arr.remove(arr.size()-1); } }}","link":"/2022/04/25/47-Permutations-II/"},{"title":"90. Subsets II","text":"Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. 首先对数组进行排序，这样重复的元素将排列在一起。接下来对每一个层级进行回溯。进入每一个层级都根据上一级传递来的列表创建新列表。然后对层级下的所有元素进行回溯。剪枝，当遍历节点和上一个节点相等时，则跳过。回溯，从列表中去掉最后一个元素。 12345678910111213141516171819class Solution { public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); backtrack(ret, new LinkedList&lt;Integer&gt;(), nums, 0); return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] nums, int level){ ret.add(new LinkedList&lt;&gt;(arr)); for(int i = level; i &lt; nums.length; i++){ if(i != level &amp;&amp; nums[i] == nums[i-1]) continue; arr.add(nums[i]); backtrack(ret, arr, nums, i+1); arr.remove(arr.size()-1); } }}","link":"/2022/04/25/90-Subsets-II/"},{"title":"39. Combination Sum","text":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. 回溯，记录当前加和。遍历所有数组元素，当sum大于target时返回，等于target时加入数组并返回。每次遍历并回溯元素时只递归当前元素和其之后的元素。（防止重复。） 12345678910111213141516171819202122232425class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); backtracking(candidates, ret, new ArrayList&lt;&gt;(), target, 0, 0); return ret; } private void backtracking(int[] candidates, List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int target, int sum, int level){ if(sum &gt; target ){ return; } else if (sum == target){ ret.add(new ArrayList&lt;&gt;(arr)); return; } for(int i = level; i &lt; candidates.length; i++){ arr.add(candidates[i]); sum+= candidates[i]; backtracking(candidates, ret, arr, target, sum, i); sum-= candidates[i]; arr.remove(arr.size()-1); } }}","link":"/2022/04/25/39-Combination-Sum/"},{"title":"40. Combination Sum II","text":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. 由于有重复性元素，因此先将数组排序。储存一个数组，记录元素是否被选择。回溯，遍历选择元素，并计算加和，并记录选择的元素。当选择的元素与上一个元素重复时，则跳过。 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtracking(candidates, ret, new ArrayList&lt;&gt;(), new int[candidates.length], target, 0, 0); return ret; } private void backtracking(int[] candidates, List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] visited, int target, int sum, int level){ if(sum &gt; target ){ return; } else if (sum == target){ ret.add(new ArrayList&lt;&gt;(arr)); return; } for(int i = level; i &lt; candidates.length; i++){ if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; visited[i-1] == 0) continue; visited[i] = 1; arr.add(candidates[i]); sum+= candidates[i]; backtracking(candidates, ret, arr, visited, target, sum, i+1); visited[i] = 0; sum-= candidates[i]; arr.remove(arr.size()-1); } }}","link":"/2022/04/25/40-Combination-Sum-II/"},{"title":"2. Add Two Numbers","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 递归，每次递归时建立root的next节点，然后将root移动到root.next。计算两个节点的和并填入root节点。每次计算时需要计算是否进位。递归两个节点的next节点，并将carry传入。当一个节点为null时，只递归和计算另一个节点。当两个节点为null时，如果有carry需要将其放入新节点，如果没有则返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode root = new ListNode(); addTwo(l1,l2,root,0); return root.next; } private void addTwo(ListNode l1, ListNode l2, ListNode root, int carry){ if(l1 == null &amp;&amp; l2 == null &amp;&amp; carry == 0){ return; } else if(l1 == null &amp;&amp; l2 == null){ root.next = new ListNode(); root = root.next; root.val = carry; return; } else if(l1 == null){ root.next = new ListNode(); root = root.next; root.val = (l2.val + carry) % 10; carry = (l2.val + carry) / 10; addTwo(null, l2.next, root, carry); return; } else if(l2 == null){ root.next = new ListNode(); root = root.next; root.val = (l1.val + carry) % 10; carry = (l1.val + carry) / 10; addTwo(null, l1.next, root, carry); return; } root.next = new ListNode(); root = root.next; root.val = (l1.val + l2.val + carry) % 10; carry = (l1.val + l2.val + carry) / 10; addTwo(l1.next, l2.next, root, carry); }}","link":"/2022/04/25/2-Add-Two-Numbers/"},{"title":"142. Linked List Cycle II","text":"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. 快慢指针。快指针的移动速度是慢指针的两倍。设环外长度为a，b是快指针和慢指针相遇的位置，c是环中剩余位置。可以由此得到公式a + (n + 1)b + nc = 2(a + b)，也就是a = c + (n - 1)(b + c)由于（b + c）是环的长度。因此，当两个指针相遇时，在头部设置一个新节点。慢指针和新指针将在循环入口处相遇，此时返回节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode detectCycle(ListNode head) { if( head == null || head.next == null) return null; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; if(slow.equals(fast)) break; } if(fast == null || fast.next == null){ return null; } ListNode root = head; while(!root.equals(slow)){ slow = slow.next; root = root.next; } return root; }} 哈希表，递归并将节点加入哈希集合，如果重复则返回节点，反之返回null。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { HashSet&lt;ListNode&gt; set; public ListNode detectCycle(ListNode head) { set = new HashSet&lt;&gt;(); return findCycle(head, 0); } private ListNode findCycle(ListNode root, int count){ if(root == null){ return null; } if(set.contains(root)){ return root; } set.add(root); count++; return findCycle(root.next, count); }}","link":"/2022/04/25/142-Linked-List-Cycle-II/"},{"title":"17. Letter Combinations of a Phone Number","text":"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 回溯，每个回溯层级添加数字对应的字符。 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if(digits.equals(&quot;&quot;)) return ret; char[][] bin = new char[8][0]; bin[0] = new char[]{'a', 'b', 'c'}; bin[1] = new char[]{'d', 'e', 'f'}; bin[2] = new char[]{'g', 'h', 'i'}; bin[3] = new char[]{'j', 'k', 'l'}; bin[4] = new char[]{'m', 'n', 'o'}; bin[5] = new char[]{'p', 'q', 'r', 's'}; bin[6] = new char[]{'t', 'u', 'v'}; bin[7] = new char[]{'w', 'x', 'y', 'z'}; backtracking(ret, new StringBuffer(), bin, digits, 0); return ret; } private void backtracking(List&lt;String&gt; ret, StringBuffer sb, char[][] bin, String digits, int i){ if(sb.length() == digits.length() ){ ret.add(sb.toString()); return; } for(char c : bin[digits.charAt(i)-'2']){ sb.append(c); backtracking(ret, sb, bin, digits, i+1); sb.delete(sb.length()-1, sb.length()); } }}","link":"/2022/04/26/17-Letter-Combinations-of-a-Phone-Number/"},{"title":"1584. Min Cost to Connect All Points","text":"You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points. 并查集，最小生成树(Minimum spanning tree)，Kruskal算法。Edge辅助类，保存并计算两点的id和其曼哈顿距离。将edges根据其距离排序。 遍历所有的edge，如果edge的两点没有合并，则合并两点，并取这条边作为结果。加和所有的结果，答案就是最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution { public int minCostConnectPoints(int[][] points) { List&lt;Edge&gt; edges = new ArrayList&lt;Edge&gt;(); int min = 0; for(int i = 0; i &lt; points.length; i++){ for(int j = i+1; j &lt; points.length; j++){ edges.add(new Edge(points, i, j)); } } Collections.sort(edges, (a, b) -&gt; a.length - b.length); UnionFind uf = new UnionFind(points.length); for(Edge e : edges){ if(uf.union(e.id1, e.id2)){ min += e.length; } } return min; } class UnionFind{ private int[] parents; private int[] size; public UnionFind(int n){ size = new int[n]; parents = new int[n]; for(int i = 0; i &lt; n; i++){ parents[i] = i; size[i] = 1; } } public int find(int id){ if(parents[id] == id) return id; return find(parents[id]); } public boolean union(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; if(size[p1] &lt; size[p2]){ parents[p1] = p2; size[p2] += size[p1]; } else{ parents[p2] = p1; size[p1] += size[p2]; } return true; } } class Edge{ int id1; int id2; int length; public Edge(int[][] points, int _id1, int _id2){ id1 = _id1; id2 = _id2; length = Math.abs(points[id1][0] - points[id2][0]) + Math.abs(points[id1][1] - points[id2][1]); } }}","link":"/2022/04/26/1584-Min-Cost-to-Connect-All-Points/"},{"title":"22. Generate Parentheses","text":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. 回溯，记录左右括号的出现次数。每次递归都添加左侧括号。左侧括号的数量大于右侧括号时递归下一级才可以添加右侧括号。当左侧括号和右侧括号达到n时，返回字符串。 12345678910111213141516171819202122232425262728293031class Solution { int N; List&lt;String&gt; ret; StringBuffer sb; public List&lt;String&gt; generateParenthesis(int n) { ret = new ArrayList&lt;&gt;(); sb = new StringBuffer(); N = n; backtracking(0, 0); return ret; } private void backtracking(int left, int right){ if(left &gt; N || right &gt; N){ return; } if(left == N &amp;&amp; right == N){ ret.add(sb.toString()); return; } if(left &gt; right){ sb.append(')'); backtracking(left, right+1); sb.delete(sb.length()-1, sb.length()); } sb.append('('); backtracking(left+1, right); sb.delete(sb.length()-1, sb.length()); }}","link":"/2022/04/26/22-Generate-Parentheses/"},{"title":"79. Word Search","text":"Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. 回溯，遍历所有初始元素。当寻找的字符与当前matrix里的字符相同时，将当前位置记录在visited里，并向下递归搜索四个方向，回溯visited。当越界或者字符已经visited时返回false。当寻找到单词的最后一位时，如果当前matrix里的字符与搜索的字符相等，则返回true。反之返回false。 1234567891011121314151617181920212223242526272829303132333435class Solution { char[][] bd; String wd; int[][] visited; public boolean exist(char[][] board, String word) { boolean ans = false; visited = new int[board.length][board[0].length]; bd = board; wd = word; for(int i = 0; i &lt; board.length; i++){ for(int j = 0; j &lt; board[0].length; j++){ ans = ans || backtracking(i, j, 0); } } return ans; } private boolean backtracking(int i, int j, int n){ if(i &lt; 0 || j &lt; 0 || i &gt;= bd.length || j &gt;= bd[0].length || n &gt;= wd.length()) return false; if(visited[i][j] == 1) return false; if(n == wd.length()-1) return bd[i][j] == wd.charAt(n); if( bd[i][j] == wd.charAt(n) ){ n++; visited[i][j] = 1; boolean a = backtracking(i+1, j, n); boolean b = backtracking(i-1, j, n); boolean c = backtracking(i, j+1, n); boolean d = backtracking(i, j-1, n); visited[i][j] = 0; return a || b || c || d; } return false; }}","link":"/2022/04/26/79-Word-Search/"},{"title":"160. Intersection of Two Linked Lists","text":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1:The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. 计算两个链表的长度。将长的链表向下移动两者长度的差，对齐两个链表的长度。同时向下移动两个链表，如果两个节点的内存地址相同，则返回节点。否则返回null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int sizeA = 0, sizeB = 0; ListNode l1 = headA, l2 = headB; while(l1 != null){ l1 = l1.next; sizeA++; } while(l2 != null){ l2 = l2.next; sizeB++; } if(sizeA &gt; sizeB){ int size = sizeA - sizeB; while(size != 0){ headA = headA.next; size--; } } else{ int size = sizeB - sizeA; while(size != 0){ headB = headB.next; size--; } } while(headA != null){ if(headA == headB) return headA; headA = headA.next; headB = headB.next; } return null; }} 遍历移动一个链表，将其加入哈希集合。然后移动另一个链表，如果哈希集合中有重复节点，则返回该节点。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while(headA != null){ set.add(headA); headA = headA.next; } while(headB != null){ if(set.contains(headB)) return headB; headB = headB.next; } return null; }}","link":"/2022/04/26/160-Intersection-of-Two-Linked-Lists/"},{"title":"24. Swap Nodes in Pairs","text":"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) 先建立一个哨兵节点，next指向head。交换时同时传入前一个节点pre和当前节点root。当当前节点非null且下一个节点非null，则可以交换两个节点。首先保存当前节点的下一个节点next和下一个节点的下一个节点last。 1.将pre指向next。 2.将next指向root。 3.将root指向last。 4.处理下一组节点，root作为pre，root.next作为root递归。最后返回哨兵节点的next。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); swap(dummy, head); return dummy.next; } private void swap(ListNode pre, ListNode root){ if(root == null || root.next == null){ return; } else if(root != null &amp;&amp; root.next != null){ ListNode last = root.next.next; ListNode next = root.next; pre.next = next; next.next = root; root.next = last; } swap(root, root.next); }}","link":"/2022/04/26/24-Swap-Nodes-in-Pairs/"},{"title":"213. House Robber II","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. 动态规划，和普通的动态规划不同的是这道题是首尾相连的。因此分两种情况讨论——如果选择了头，就不选择尾。反之亦然。建立两个动态规划表，分别选择第一个和第二个数字作为第一次抢劫的目标。前一个最多抢劫到倒数第一个房子，后一个最多抢劫到最后一个房子。 12345678910111213141516171819202122class Solution { public int rob(int[] nums) { if(nums.length == 1) return nums[0]; int max = 0; int[] dp = new int[nums.length+1]; int[] dp2 = new int[nums.length+1]; dp[1] = nums[0]; for(int i = 2; i &lt; nums.length; i++){ dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i-1]); } dp2[2] = nums[1]; for(int i = 3; i &lt;= nums.length; i++){ dp2[i] = Math.max(dp2[i-2] + nums[i-1], dp2[i-1]); } return Math.max(dp[dp.length-2], dp2[dp2.length-1]); }}","link":"/2022/04/26/213-House-Robber-II/"},{"title":"55. Jump Game","text":"You are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. 反向查找，动态规划。到达目标点前必须到达上一个节点，且上一个节点能前进的步数必须大于目标点。设置目标点goal，反向遍历goal以外的点。如果该点能前进的步数加上自身的位置i大于目标点，则可以从上一个点到达goal。更新goal的位置到上一个点。如果遍历结束后，能返回到起始点0，则可以到达终点。 123456789class Solution { public boolean canJump(int[] nums) { int goal = nums.length-1; for(int i = nums.length-2; i &gt;=0; i--){ if(nums[i] &gt;= goal - i) goal = i; } return goal == 0; }} 贪心算法，储存一个到i时可以到达的最远值maxJump。遍历数组，如果i大于maxJump，则无法到达下一个点，返回false。在当前点可以到达的最大范围为nums[i]+i，如果大于maxJump则更新该值。遍历完毕返回true。 12345678910class Solution { public boolean canJump(int[] nums) { int maxJump = 0; for(int i = 0; i &lt; nums.length; i++){ if(i &gt; maxJump) return false; maxJump = Math.max(maxJump, nums[i] + i); } return maxJump &gt;= nums.length-1; }} 设置一个数组记录可访问的范围。当遍历时，如果可以访问，则将当前位置可以进一步访问的位置变为1。如果访问范围大于等于数组末尾，则返回真。 1234567891011121314151617class Solution { public boolean canJump(int[] nums) { int[] reach = new int[nums.length]; reach[0] = 1; for(int i = 0; i &lt; nums.length; i++){ if(reach[i] == 1){ if(i == nums.length-1) return true; for(int j = 0; j &lt; nums[i]; j++){ if(i+j+1 &gt;= nums.length) return true; reach[i+j+1] = 1; } } } return false; }}","link":"/2022/04/27/55-Jump-Game/"},{"title":"1202. Smallest String With Swaps","text":"You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps. 并查集，注意要使用路径压缩否则会超时。先将所有配对联通。然后创建一个数组group记录每个字符串位置的分组情况。根据分组，借助优先队列保存字符串。通过哈希表创建group和PriorityQueue的映射。按当前位置的分组情况和优先队列的顺序来添加字符串。最后返回字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) { StringBuffer sb = new StringBuffer(); UnionFind uf = new UnionFind(s.length()); for(List&lt;Integer&gt; pair : pairs){ uf.union(pair.get(0), pair.get(1)); } int[] group = new int[s.length()]; for(int i = 0; i &lt; s.length(); i++){ group[i] = uf.find(i); } HashMap&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++){ PriorityQueue&lt;Character&gt; bin = map.getOrDefault(group[i], new PriorityQueue&lt;Character&gt;()); bin.add(s.charAt(i)); map.put(group[i], bin); } for(int i = 0; i &lt; s.length(); i++){ sb.append(map.get(group[i]).poll()); } return sb.toString(); } class UnionFind { int[] parent; int[] count; public UnionFind(int n){ parent = new int[n]; count = new int[n]; for(int i = 0; i &lt; n; i++){ parent[i] = i; count[i] = 1; } } private int find(int id){ if(parent[id] == id) return id; parent[id] = find(parent[id]); return parent[id]; } private boolean union(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; if(count[p1] &gt; count[p2]) parent[p2] = p1; else parent[p1] = p2; return true; } }}","link":"/2022/04/27/1202-Smallest-String-With-Swaps/"},{"title":"707. Design Linked List","text":"Design your implementation of the linked list. You can choose to use a singly or doubly linked list.A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid. 单链表，设置一个哨兵节点在头部。设置辅助方法，取得index的前一个节点。addAtHead和addAtTail都可以采用addAtIndex实现。 采用双链表速度可以更快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyLinkedList { ListNode head; int size; public MyLinkedList() { ListNode dummy = new ListNode(0); head = dummy; size = 0; } public ListNode getPrev(int index){ ListNode prev = head; for(int i = 0; i &lt; index; i++){ prev = prev.next; } return prev; } public int get(int index) { if(index &gt;= size) return -1; return getPrev(index).next.val; } public void addAtHead(int val) { addAtIndex(0, val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index &gt; size) return; ListNode prev = getPrev(index); ListNode temp = prev.next; prev.next = new ListNode(val); prev.next.next = temp; size++; } public void deleteAtIndex(int index) { if(index &gt;= size) return; if(index == size-1){ ListNode prev = getPrev(index); prev.next = null; size--; return; } ListNode prev = getPrev(index); prev.next = prev.next.next; size--; } private void print(){ ListNode root = head.next; while(root != null){ System.out.print(root.val+&quot; -&gt; &quot;); root = root.next; } System.out.println(&quot;Size: &quot;+size); } class ListNode{ int val; ListNode next; public ListNode(int v){ val = v; } }}/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */","link":"/2022/04/27/707-Design-Linked-List/"},{"title":"25. Reverse Nodes in k-Group","text":"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list’s nodes, only nodes themselves may be changed. 采用直接更改节点的方法可以使用O(1)的空间完成操作。 递归，DFS搜索，首先初始化一个哨兵节点。将哨兵节点记录为first，下一个节点记录为second。 将first与second传入递归方法。向下递归下一个节点，并将长度k-1。当长度k等于1时，则递归到当前所需的栈底。将当前节点指向上一个节点，并将当前节点记录为last，下一个节点记录为next，返回true。当curr为null时，返回false。 当递归返回为true时（即剩余的链表有k个节点以供翻转），上级的节点们都指向其前一个节点。当返回到的栈顶（即k等于最开始的值）时，将first指向last，将second指向next。 继续向下递归first与second。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { int K; ListNode next; ListNode prev; ListNode last; ListNode first; ListNode second; public ListNode reverseKGroup(ListNode head, int k) { if(k == 1) return head; K = k; ListNode dummy = new ListNode(0); dummy.next = head; prev = dummy; next = null; last = null; first = prev; second = prev.next; reverse(prev, dummy.next, k); return dummy.next; } private boolean reverse(ListNode prev, ListNode curr, int k){ if(curr == null) return false; if(k == 1){ last = curr; next = curr.next; curr.next = prev; return true; } if( reverse(curr, curr.next, k-1) ){ curr.next = prev; if(k == K){ first.next = last; second.next = next; first = curr; second = curr.next; reverse(first, second, k); } return true; } return false; } private void print(ListNode root){ while(root != null){ root = root.next; } }}","link":"/2022/04/28/25-Reverse-Nodes-in-k-Group/"},{"title":"45. Jump Game II","text":"Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. 设置一个当前可以访问的最大范围limit，在遍历中对其进行更新。和当前可访问位置中的最远距离end，每次访问到达end时，计算步数。 遍历数组，比较limit和当前i能访问的最远距离i+nums[i]，保留较大值。当i达到end时，更新end为之前记录的可访问最远距离limit。步数+1。 1234567891011121314151617class Solution { public int jump(int[] nums) { int count = 0; int limit = 0; int end = 0; for(int i = 0; i &lt; nums.length-1; i++){ limit = Math.max(limit, i + nums[i]); if(i == end){ end = limit; count++; } } return count; }}","link":"/2022/04/28/45-Jump-Game-II/"},{"title":"1631. Path With Minimum Effort","text":"You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort. A route’s effort is the maximum absolute difference in heights between two consecutive cells of the route. Return the minimum effort required to travel from the top-left cell to the bottom-right cell. A*算法，启发式搜索。BFS搜索结合Priority Queue。采用一个数组储存当前访问点的位置，以及其effort。采用优先队列，优先搜索effort最小的方向。每次循环倾倒出队列中所有的元素。计算上一个节点和当前节点的差值作为nextEffort，并和上一个节点的effort作比较，较大的作为当前节点的effort，将effort作为权重，优先搜索一个层级内effort较小的路径。将所有操作加入队列，并排除越界的位置。当当前节点为最后一个节点时，返回其effort。 1234567891011121314151617181920212223242526272829303132333435class Solution { int min; public int minimumEffortPath(int[][] heights) { int[][] operations = {{1,0},{-1,0},{0,1},{0,-1}}; int m = heights.length, n = heights[0].length; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[2] - b[2]); int[] point = {0, 0, 0}; int size = 1; int[][] visited = new int[m][n]; q.add(point); while(!q.isEmpty()){ for(int k = 0; k &lt; size; k++){ int[] curr = q.poll(); int i = curr[0], j = curr[1], currEffort = curr[2]; if(visited[i][j] == 1) continue; visited[i][j] = 1; if(i == m-1 &amp;&amp; j == n-1) return currEffort; for(int[] operation : operations){ int nextX = i + operation[0]; int nextY = j + operation[1]; if(nextX &lt; 0 || nextY &lt; 0 || nextX &gt;= m || nextY &gt;= n) continue; int nextEffort = Math.max(currEffort, Math.abs(heights[i][j] - heights[nextX][nextY])); int[] next = {nextX, nextY, nextEffort}; q.add(next); } } size = q.size(); } return -1; }}","link":"/2022/04/28/1631-Path-With-Minimum-Effort/"},{"title":"785. Is Graph Bipartite?","text":"There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite. 原题等于问：每个节点与其相连接的节点是否可以颜色不同？通过BFS搜索，将每一层通过开关flag分组。创建一个visited数组，记录分组和遍历情况。当节点被放入错误的分组时，返回false。 注意因为图里的各个节点可能不连接，因此需要遍历对所有节点进行BFS搜索，通过visited的情况进行剪枝。 123456789101112131415161718192021222324252627282930313233343536class Solution { public boolean isBipartite(int[][] graph) { Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); int[] visited = new int[graph.length]; for(int i = 0; i &lt; graph.length; i++){ boolean flag = false; if(graph[i].length == 0 || visited[i] != 0) continue; q.add(graph[i]); visited[i] = 1; int size = 1; while(!q.isEmpty()){ for(int j = 0; j &lt; size; j++){ int[] node = q.poll(); for(int next : node){ if(visited[next] == 0){ q.add(graph[next]); } if(flag){ if(visited[next] == 2) return false; visited[next] = 1; } else{ if(visited[next] == 1) return false; visited[next] = 2; } } } flag = !flag; size = q.size(); } } return true; }}","link":"/2022/04/29/785-Is-Graph-Bipartite/"},{"title":"62. Unique Paths","text":"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. 动态规划，每一个位置的线路都等于其左侧和上侧的两条线路的加和。将初始的两个边值设置为1，然后计算直至终点位置即可。 12345678910111213141516171819class Solution { int count; public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++){ dp[i][0] = 1; } for(int j = 0; j &lt; n; j++){ dp[0][j] = 1; } for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }}","link":"/2022/04/29/62-Unique-Paths/"},{"title":"413. Arithmetic Slices","text":"An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array. 动态规划，遍历一次记录所有数字的差。然后遍历并计算连续相同的数字数量temp。当不相同时，则计算temp长度可以选择的组合数，将其添加到count。 123456789101112131415161718192021222324252627282930class Solution { public int numberOfArithmeticSlices(int[] nums) { if(nums.length == 1) return 0; int[] difference = new int[nums.length-1]; for(int i = 0; i &lt; nums.length-1; i++){ difference[i] = nums[i+1] - nums[i]; } int count = 0; int temp = 1; int prev = difference[0]; for(int j = 1; j &lt; nums.length-1; j++){ if(difference[j] == prev){ temp++; } else{ count += combinations(temp); temp = 1; } prev = difference[j]; } count += combinations(temp); return count; } private int combinations(int n){ return (n * (n-1)) / 2; }}","link":"/2022/04/29/413-Arithmetic-Slices/"},{"title":"155. Min Stack","text":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. 分别将数据保存在一个Priority Queue和一个栈中。pop方法pop掉stack的内容，然后将其从优先队列中移除。top方法返回stack的栈顶。getMin方法返回优先队列的顶。 123456789101112131415161718192021222324252627282930313233343536class MinStack { Queue&lt;Integer&gt; pq; Stack&lt;Integer&gt; stack; public MinStack() { pq = new PriorityQueue&lt;&gt;(); stack = new Stack&lt;&gt;(); } public void push(int val) { pq.add(val); stack.add(val); } public void pop() { int i = stack.pop(); pq.remove(i); } public int top() { return stack.peek(); } public int getMin() { return pq.peek(); }}/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */","link":"/2022/04/30/155-Min-Stack/"},{"title":"1249. Minimum Remove to Make Valid Parentheses","text":"Given a string s of ‘(‘ , ‘)’ and lowercase English characters. Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. 用栈储存括号，按顺序将括号压入栈。如果和上一个括号配对，则挤出上一个括号。 当栈不为空时，如果栈顶的符号为“)”，则优先去掉字符串左侧的括号。如果栈顶的符号为“(”，则优先去掉字符串右侧的括号。最后返回字符串。 1234567891011121314151617181920212223242526class Solution { public String minRemoveToMakeValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); StringBuffer sb = new StringBuffer(s); for(int i = 0; i &lt; s.length(); i++){ if(s.charAt(i) == '(') stack.push('('); else if(s.charAt(i) == ')'){ if(!stack.isEmpty() &amp;&amp; stack.peek() == '(') stack.pop(); else stack.push(')'); } } while(!stack.isEmpty()){ if(stack.pop() == ')'){ int index = sb.indexOf(&quot;)&quot;); sb.delete(index, index+1); } else{ int index = sb.lastIndexOf(&quot;(&quot;); sb.delete(index, index+1); } } return sb.toString(); }}","link":"/2022/04/30/1249-Minimum-Remove-to-Make-Valid-Parentheses/"},{"title":"1823. Find the Winner of the Circular Game","text":"There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 &lt;= i &lt; n, and moving clockwise from the nth friend brings you to the 1st friend. The rules of the game are as follows: 1.Start at the 1st friend. 2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once. 3.The last friend you counted leaves the circle and loses the game. 4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat. 5.Else, the last friend in the circle wins the game.Given the number of friends, n, and an integer k, return the winner of the game. 约瑟夫环问题。根据题目要求，当去除一个成员时，下一个节点的编号为k+1。当新的循环开始时，总人数n-1，同时k+1变为新循环中的1。 因此可以采用递归，当n剩下一个人时，返回其编号1。对应上层这个成员的位置为k+1，向上递归。由于k+1可以越界，因此每次返回需要对其取模。 1234567class Solution { public int findTheWinner(int n, int k) { if(n == 1) return 1; int ans = findTheWinner(n-1, k) + k; return ans % n == 0 ? n : ans % n; }}","link":"/2022/04/30/1823-Find-the-Winner-of-the-Circular-Game/"},{"title":"399. Evaluate Division","text":"You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. 这道题的核心是边上带权的并查集。如何在find以及union时计算并更新权重是最重要的。组合过后，根节点的权重依然为1，以其为标准更新其他节点的权重。 先通过一个哈希表建立字符串与id的映射关系，为每个字符串生成一个单独的id。 然后将一个equation里的两个字符串进行union操作。并查集初始化时，所有权重为1。 在find时，执行路径压缩时需要用当前的权重weight[id]更新为其自身乘以其上一级的权重weight[origin]。这里需要注意计算的顺序需要从根上的权重，以递归的形式计算到当前权重。因此我们需要先单独保存parents[id]的位置。然后find(parents[id])，先计算出其上级的weight。最后再将weight[id]更新为更新后的上一级的权重乘以自身权重。 123int origin = parents[id];parents[id] = find(parents[id]);weight[id] *= weight[origin]; 在union时，将两个集合中的一个的根指向另一个。例如当结合a与b两个节点时，我们已经计算过了(a -&gt; b)的权重关系，以及(d -&gt; c)的权重关系。我们将(b -&gt; d)。这时我们可以通过values[i]得到(a -&gt; d)的权重关系。因此我们可以据此得出以下公式： weight[(b-&gt;c)] = weight[(d-&gt;c)] × values[(a-&gt;d)]/weight[(a-&gt;b)] 12parents[p1] = parents[p2];weight[p1] = weight[id2]*val/weight[id1]; 最后，当所有节点都被合并后，我们可以遍历queries。从哈希表获得对应字符串的id。当有字符串未在哈希表中时，返回-1.0。否则计算两个id对应的权重，并添加到答案中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution { public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) { double[] ret = new double[queries.size()]; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); UnionFind uf = new UnionFind(equations.size() * 2); int id = 0; for(int i = 0; i &lt; equations.size(); i++){ String var1 = equations.get(i).get(0); String var2 = equations.get(i).get(1); if( !map.containsKey( var1 ) ){ map.put( var1, id ); id++; } if( !map.containsKey( var2 ) ){ map.put( var2, id ); id++; } uf.union(map.get(var1), map.get(var2), values[i]); } for(int i = 0 ; i &lt; queries.size(); i++){ String var1 = queries.get(i).get(0); String var2 = queries.get(i).get(1); Integer id1 = map.get(var1); Integer id2 = map.get(var2); if(id1 == null || id2 == null) ret[i] = -1.0; else ret[i] = uf.isConnected(id1, id2); } return ret; } class UnionFind{ int[] parents; double[] weight; public UnionFind(int n){ parents = new int[n]; weight = new double[n]; for(int i = 0; i &lt; parents.length; i++){ parents[i] = i; weight[i] = 1.0; } } public int find(int id){ if (id != parents[id]) { int origin = parents[id]; parents[id] = find(parents[id]); weight[id] *= weight[origin]; } return parents[id]; } public boolean union(int id1, int id2, double val){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; parents[p1] = parents[p2]; weight[p1] = weight[id2]*val/weight[id1]; return true; } public double isConnected(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return weight[id1] / weight[id2]; else return -1.0; } }}","link":"/2022/05/01/399-Evaluate-Division/"},{"title":"91. Decode Ways","text":"A message containing letters from A-Z can be encoded into numbers using the following mapping: ‘A’ -&gt; “1”‘B’ -&gt; “2”…‘Z’ -&gt; “26”To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into: “AAJF” with the grouping (1 1 10 6) “KJF” with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”. Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. 动态规划。转移方程的考虑比较麻烦。当当前的字符不为0时，该为可以自己组成有效编码，因此dp[i] = dp[i-1]。然后考虑上一位可以和当前位组成有效编码的情况，如果上一位和当前位的数字小于26，且上一位不等于0，则可以联合编码。因此dp需要再加上前一位可以组成的编码数，即dp[i] += dp[i-2]。当i等于1时，由于会越界因此我们手动给dp[i]++。 12345678910111213141516171819class Solution { public int numDecodings(String s) { int n = s.length(); if(s.charAt(0) == '0') return 0; int[]dp = new int[n]; dp[0] = 1; for(int i = 1 ; i &lt; n; i++){ if(s.charAt(i) != '0'){ dp[i] = dp[i-1]; } if(s.charAt(i-1) != '0' &amp;&amp; (s.charAt(i-1) - '0') * 10 + (s.charAt(i) - '0') &lt;= 26 ){ if(i &gt; 1) dp[i] += dp[i-2]; else dp[i]++; } } return dp[n-1]; }}","link":"/2022/05/01/91-Decode-Ways/"},{"title":"139. Word Break","text":"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. 动态规划，创建一个数组dp[]，长度为字符串长度+1，记录是否可以达到。将dp[0]设置为1，表示可以达到。 从可取长度为1开始，遍历直到可取长度为字符串的长度。用下一个遍历j将字符串分为两部分。（这里j从i-1下降到0会比从0上升到i-1更快。）当dp[j]可以到达，且当前的哈希表中有(i-j)组成的字符串时，则dp[i]也可以到达。结束第二层循环。继续搜索更长的字符串是否可以达到。最后返回dp中的最后一个元素。 12345678910111213141516171819202122class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); int n = s.length(); int[] dp = new int[n+1]; for(String word : wordDict){ set.add(word); } dp[0] = 1; int temp = 0; for(int i = 1; i &lt;= n; i++){ for(int j = i - 1; j &gt;= 0; j--){ if(dp[j] == 1 &amp;&amp; set.contains(s.substring(j, i))){ dp[i] = 1; break; } } } return dp[n] == 1; }}","link":"/2022/05/01/139-Word-Break/"},{"title":"300. Longest Increasing Subsequence","text":"Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. 此题还有更快的二分查找解法。 动态规划，创建一个数组dp[]用来记录最大长度，创建max记录最大值。遍历，先将数组dp[]上的所有位置都填上1。从0到i-1遍历j。当nums[i] &gt; nums[j]时，更新dp[i]为dp[i]与dp[j]+1中的较大值。当更新dp[i]时将其和max比较，如果比max大则更新max。最后返回max值。 123456789101112131415161718192021class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; int max = 1; for(int i = 0; i &lt; n; i++){ dp[i] = 1; for(int j = i-1; j &gt;= 0; j--){ if(nums[i] &gt; nums[j]){ dp[i] = Math.max(dp[i], dp[j]+1); if(max &lt; dp[i]){ max = dp[i]; break; } } } } return max; }}","link":"/2022/05/01/300-Longest-Increasing-Subsequence/"},{"title":"108. Convert Sorted Array to Binary Search Tree","text":"Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. 以中序遍历的顺序创建节点（代码实现时先序遍历），每次选择范围的中间值mid为根节点。根节点的左子节点递归左侧left直到mid-1的位置。根节点的右子节点递归mid+1直到右侧right的位置。当left &gt; right时，返回null作为二叉树的叶子节点。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode sortedArrayToBST(int[] nums) { return build(nums, 0, nums.length-1); } private TreeNode build(int[] nums, int left, int right){ if(left &gt; right) return null; int mid = left + (right - left) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = build(nums, left, mid-1); root.right = build(nums, mid+1, right); return root; }}","link":"/2022/05/02/108-Convert-Sorted-Array-to-Binary-Search-Tree/"},{"title":"103. Binary Tree Zigzag Level Order Traversal","text":"Given the root of a binary tree, return the zigzag level order traversal of its nodes’ values. (i.e., from left to right, then right to left for the next level and alternate between). BFS搜索，每次遍历挤出整层的节点。根据真值reverse来判断列表顺序。当reverse为真，则每次添加元素到列表头。反之则添加元素到列表尾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int size = 1; boolean reverse = false; while(!q.isEmpty()){ List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); if(reverse){ level.add(0, curr.val); } else{ level.add(curr.val); } if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); } reverse = !reverse; ret.add(level); size = q.size(); } return ret; }} 双端队列，根据真值reverse来判断是取队头还是取队尾。每层级需要遍历所有的节点。注意添加节点时也需要根据reverse来决定加入对头还是队尾。（从一个层级取出时，加入下一个层级元素需要从队列另一边压入。）同时左右节点的加入顺序也需要调整。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Deque&lt;TreeNode&gt; dq = new LinkedList&lt;&gt;(); dq.add(root); int size = 1; boolean reverse = false; while(!dq.isEmpty()){ List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; size; i++){ if(reverse){ TreeNode curr = dq.removeLast(); if(curr.right != null) dq.offerFirst(curr.right); if(curr.left != null) dq.offerFirst(curr.left); temp.add(curr.val); } else{ TreeNode curr = dq.removeFirst(); if(curr.left != null) dq.offerLast(curr.left); if(curr.right != null) dq.offerLast(curr.right); temp.add(curr.val); } } reverse = !reverse; ret.add(temp); size = dq.size(); } return ret; }}","link":"/2022/05/02/103-Binary-Tree-Zigzag-Level-Order-Traversal/"},{"title":"113. Path Sum II","text":"Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. 回溯，每次将root的值添加到list中。并计算新的sum值。分别向左右子节点进行递归，然后回溯。当节点没有左右子节点，且sum等于targetSum则将新建的list添加到结果中。（注意这一步内也需要进行回溯操作。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;List&lt;Integer&gt;&gt; ret; int target; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { ret = new ArrayList&lt;&gt;(); if(root == null) return ret; target = targetSum; backTrack(root, 0, new ArrayList&lt;&gt;()); return ret; } private void backTrack(TreeNode root, int sum, List&lt;Integer&gt; nodes){ if(root.left == null &amp;&amp; root.right == null){ sum += root.val; if(sum == target){ nodes.add(root.val); ret.add(new ArrayList&lt;Integer&gt;(nodes)); nodes.remove(nodes.size()-1); } return; } nodes.add(root.val); sum += root.val; if(root.left != null) backTrack(root.left, sum, nodes); if(root.right != null) backTrack(root.right, sum, nodes); nodes.remove(nodes.size()-1); sum -= root.val; }}","link":"/2022/05/02/113-Path-Sum-II/"},{"title":"199. Binary Tree Right Side View","text":"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. BFS搜索。层级遍历各个节点，当节点为该层级最后一个节点时，将其值加入返回列表。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int size = 1; while(!q.isEmpty()){ for(int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); if(i == size - 1) ret.add(curr.val); if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); } size = q.size(); } return ret; }}","link":"/2022/05/02/199-Binary-Tree-Right-Side-View/"},{"title":"905. Sort Array By Parity","text":"Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. 双指针，右侧指针之后存放奇数项。当左侧指针的元素为奇数时，交换left和right上的元素。然后将右侧指针左移。当左侧指针的元素为偶数时，左侧指针左移。 12345678910111213141516171819202122232425class Solution { int[] arr; public int[] sortArrayByParity(int[] nums) { arr = nums; int left = 0; int right = nums.length-1; while(left &lt; right){ if(nums[left] % 2 == 1){ swap(left, right); right--; } else{ left++; } } return arr; } private void swap(int left, int right){ int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; }}","link":"/2022/05/02/905-Sort-Array-By-Parity/"},{"title":"1143. Longest Common Subsequence","text":"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”.A common subsequence of two strings is a subsequence that is common to both strings. 动态规划，dp的长和宽分别为两个字符串的长度。遍历dp字符串的长和宽。（注意在第一层遍历时先保存当前选择的字符可以提升速度。）当两个字符串相同时，则可以从上一个状态+1。注意状态转移方程的上一个状态应该是从对角线方向+1。当两个字符串不同时，则继续保存之前的最大长度。 123456789101112131415161718192021class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m+1][n+1]; char[] bin1 = text1.toCharArray(); char[] bin2 = text2.toCharArray(); for(int i = 1; i &lt;= m; i++){ int k = bin1[i-1]; for(int j = 1; j &lt;= n ; j++){ if(k == bin2[j-1]){ dp[i][j] = dp[i-1][j-1]+1; } else{ dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; }}","link":"/2022/05/02/1143-Longest-Common-Subsequence/"},{"title":"583. Delete Operation for Two Strings","text":"Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. 动态规划，创建数组dp[][]，长宽分别为两个字符串的长度。在dp中填入子字符串修改成另一个子字符串时需要删除的数量。如果两个字符相同，则相对于上一个状态不需要增加数量。因此可以直接等于对角线方向上的值。如果两个字符串不同，则取上方向和左方向中的较小值，然后+1。（由于题目只允许删除操作，不允许修改操作，因此不能从字符串左上角取值。）最后返回dp中右下角的值。 12345678910111213141516171819202122232425262728class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m+1][n+1]; char[] bin1 = word1.toCharArray(); char[] bin2 = word2.toCharArray(); for(int i = 0; i &lt;= m; i++){ dp[i][0] = i; } for(int j = 0; j &lt;= n; j++){ dp[0][j] = j; } for(int i = 1; i &lt;= m; i++){ char k = bin1[i-1]; for(int j = 1; j &lt;= n; j++){ if(k == bin2[j-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + 1; } } } return dp[m][n]; }}","link":"/2022/05/02/583-Delete-Operation-for-Two-Strings/"},{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. 先序遍历时，访问的顺序是[根节点 - 左子节点 - 右子节点]。中序遍历时，访问的顺序是[左子节点 - 根节点 - 右子节点]。可以注意到根节点与左子节点的顺序是相反的，因此我们可以利用栈将节点储存起来，当挤出时顺序自然是调转的。 按照先序遍历来创建树，遍历先序数组。同时将指针指向中序遍历的数组的头部。先创建根节点，并将其放入栈中。分为两种情况讨论。 情况一，处理当前根节点的左子节点，并将其入栈： 当栈顶的节点值与中序遍历当前的节点值不同时，说明当前的根节点仍有左子节点。 先序：[根节点 - 左子节点 - 右子节点]中序：[左子节点 - 根节点 - 右子节点] 此时将栈顶的节点的左子节点设置为先序数组对应的节点，继续遍历下一个先序数组。 栈内：[根节点 - 左子节点]先序：[根节点 - 左子节点 - 右子节点]中序：[左子节点 - 根节点 - 右子节点] 情况二，寻找栈内节点们的右子节点： 当栈顶的节点与中序遍历当前的节点值相同时，说明我们经过了当前根节点的先序遍历中的最后一个左子节点。当前先序数组指针指向了当前栈内节点一个右子节点。 栈内：[根节点 - 左子节点]先序：[根节点 - 左子节点 - 右子节点]中序：[左子节点 - 根节点 - 右子节点] 此时我们开始向右移动中序遍历的指针，寻找先序遍历指针中的节点应该是当前栈内哪一个节点的右子节点。此时栈内节点的顺序，与中序遍历的左子节点顺序正好相反。当栈顶与中序遍历的指针相等时，挤出栈顶并将中序指针右移，直到两者不相等或栈空。此时将最后挤出的根节点的右子节点设置为当前先序数组对应的节点，继续遍历下一个先序数组。 当遍历完成后，返回根节点即可。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { int j = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode root = new TreeNode(preorder[0]); stack.add(root); for(int i = 1; i &lt; preorder.length; i++){ TreeNode curr = new TreeNode(preorder[i]); TreeNode prev = stack.peek(); if(inorder[j] != prev.val){ prev.left = curr; stack.add(curr); } else{ while(!stack.isEmpty() &amp;&amp; inorder[j] == stack.peek().val){ prev = stack.pop(); j++; } prev.right = curr; stack.add(curr); } } return root; }}","link":"/2022/05/03/105-Binary-Tree-from-Preorder/"},{"title":"Icarus主题增加夜间模式","text":"参考资料：Hexo主题Icarus的自定义 小插曲： 直接复制代码的恶果😅乍一看还以为是旁边有两个星星，还挺像那么回事的。 开了控制台才发现有两个莫名其妙的“+”……","link":"/2022/05/03/Icarus%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","link":"/tags/Hash-Map/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"原地算法","slug":"原地算法","link":"/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"每日一题","slug":"每日一题","link":"/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"回文","slug":"回文","link":"/tags/%E5%9B%9E%E6%96%87/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"快慢指针","slug":"快慢指针","link":"/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"Priority Queue","slug":"Priority-Queue","link":"/tags/Priority-Queue/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"Matrix","slug":"Matrix","link":"/tags/Matrix/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","link":"/tags/Bit-Manipulation/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"投票算法","slug":"投票算法","link":"/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"},{"name":"掩码","slug":"掩码","link":"/tags/%E6%8E%A9%E7%A0%81/"},{"name":"Renamed","slug":"Renamed","link":"/tags/Renamed/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"其他解法？","slug":"其他解法？","link":"/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"},{"name":"intervals","slug":"intervals","link":"/tags/intervals/"},{"name":"双向遍历","slug":"双向遍历","link":"/tags/%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"Backtracking","slug":"Backtracking","link":"/tags/Backtracking/"},{"name":"Disjoint Set","slug":"Disjoint-Set","link":"/tags/Disjoint-Set/"},{"name":"MST","slug":"MST","link":"/tags/MST/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Kruskal","slug":"Kruskal","link":"/tags/Kruskal/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"A*","slug":"A","link":"/tags/A/"},{"name":"Deque","slug":"Deque","link":"/tags/Deque/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","link":"/categories/LeetCode/Easy/"},{"name":"Medium","slug":"LeetCode/Medium","link":"/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Easy/复习","link":"/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"},{"name":"复习","slug":"LeetCode/Medium/复习","link":"/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"Hard","slug":"LeetCode/Hard","link":"/categories/LeetCode/Hard/"},{"name":"复习","slug":"LeetCode/Hard/复习","link":"/categories/LeetCode/Hard/%E5%A4%8D%E4%B9%A0/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Theme","slug":"Hexo/Theme","link":"/categories/Hexo/Theme/"}]}