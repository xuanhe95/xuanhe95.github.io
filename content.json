{"meta":{"title":"XANDER Studio","subtitle":"Xander Studio","description":"Stay Foolish, Stay Hungery...","author":"Xuanhe","url":"https://xuanhe95.github.io","root":"/"},"pages":[],"posts":[{"title":"169. Majority Element","slug":"169-Majority-Element","date":"2022-04-16T11:20:43.000Z","updated":"2022-04-16T11:24:07.730Z","comments":true,"path":"2022/04/16/169-Majority-Element/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/169-Majority-Element/","excerpt":"","text":"问题Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n &#x2F; 2⌋ times. You may assume that the majority element always exists in the array. Boyer-Moore投票算法基本思想：众数的值为+1，非众数的值为-1。其加和作为投票值。遍历整个数组，由于众数数量大于非众数，因此最后结果一定为正数。 设置count记录票数，遍历数组。当count为0时，则将当前的数组设为众数。当之后的数字与其相等，则count+1，反之则-1。遍历完成后返回当前的众数。 根据以上规则，每次我们选择的众数，都是已遍历数组范围内出现最多次数的数值之一。 由于给定的数组的众数超过半数，因此遍历到最后的众数，一定是整个数组中出现最多次的数值。 核心就是对拼消耗。玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。 那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。 最后能剩下的必定是自己人。 12345678910111213141516171819class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 0; int major = 0; for(int num : nums)&#123; if(count == 0)&#123; major = num; &#125; if(major == num)&#123; count++; &#125; else&#123; count--; &#125; &#125; return major; &#125;&#125; 遍历数组，并将各个数值出现的次数记录在哈希表中。当出现的次数大于数组的一半，则该数值是众数。 123456789101112class Solution &#123; public int majorityElement(int[] nums) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int num : nums)&#123; map.put(num, map.getOrDefault(num,0)+1); if(map.get(num) &gt; nums.length/2)&#123; return num; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"算法","slug":"算法","permalink":"https://xuanhe95.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"投票算法","slug":"投票算法","permalink":"https://xuanhe95.github.io/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"}]},{"title":"136. Single Number","slug":"136-Single-Number","date":"2022-04-16T10:18:34.000Z","updated":"2022-04-16T10:18:34.119Z","comments":true,"path":"2022/04/16/136-Single-Number/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/136-Single-Number/","excerpt":"","text":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. 位运算，对所有数值做二进制异或运算。两个同样的值异或运算会等于0，最后和与单独的数字相等。 123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int ans = 0; for(int num : nums)&#123; ans = ans ^ num; &#125; return ans; &#125;&#125; 排序，然后遍历数组，如果第i个值不等于第i+1个则返回。 1234567891011class Solution &#123; public int singleNumber(int[] nums) &#123; Arrays.sort(nums); for(int i = 0; i &lt; nums.length-1; i+=2)&#123; if(nums[i] != nums[i+1])&#123; return nums[i]; &#125; &#125; return nums[nums.length-1]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"}]},{"title":"653. Two Sum IV - Input is a BST","slug":"653-Two-Sum-IV-Input-is-a-BST","date":"2022-04-16T09:12:22.000Z","updated":"2022-04-16T09:12:22.187Z","comments":true,"path":"2022/04/16/653-Two-Sum-IV-Input-is-a-BST/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/653-Two-Sum-IV-Input-is-a-BST/","excerpt":"","text":"问题Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. DFS搜索，每次递归时检查HashSet中是否有当前节点的值。如没有则将目标值减去当前节点的值加入HashSet。如有则返回true。递归左侧节点和右侧节点，并返回二者的或运算。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; HashSet&lt;Integer&gt; set; public boolean findTarget(TreeNode root, int k) &#123; set = new HashSet(); return dfs(root,k); &#125; private boolean dfs(TreeNode root, int k)&#123; if(root == null)&#123; return false; &#125; if(set.contains(root.val))&#123; return true; &#125; set.add(k - root.val); return dfs(root.left,k) || dfs(root.right,k); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"235. Lowest Common Ancestor of a BST","slug":"235-Lowest-Common-Ancestor-of-a-BST","date":"2022-04-16T08:52:15.000Z","updated":"2022-04-16T08:52:15.082Z","comments":true,"path":"2022/04/16/235-Lowest-Common-Ancestor-of-a-BST/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/235-Lowest-Common-Ancestor-of-a-BST/","excerpt":"","text":"问题Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” DFS搜索，如果当前节点为null，则返回null。如果当前节点小于p和q的值，则递归其左子节点。反之递归其右子节点。如果当前节点在p与q之间，则返回当前节点。该节点是p与q的Lowest Common Ancestor。 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)&#123; return null; &#125; if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125; if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125; return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"538. Convert BST to Greater Tree","slug":"538-Convert-BST-to-Greater-Tree","date":"2022-04-16T08:21:22.000Z","updated":"2022-04-16T08:21:22.501Z","comments":true,"path":"2022/04/16/538-Convert-BST-to-Greater-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/538-Convert-BST-to-Greater-Tree/","excerpt":"","text":"问题Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only &gt;-&gt;- nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */DFS搜索，设置一个成员变量记录上一个节点的值。先递归右侧节点。设置当前节点的值为自身的值加上temp中的值。更新temp中的值，再递归左侧节点。class Solution &#123; int temp; public TreeNode convertBST(TreeNode root) &#123; temp = 0; dfs(root); return root; &#125; private void dfs(TreeNode root)&#123; if(root == null)&#123; return; &#125; dfs(root.right); root.val += temp; temp = root.val; dfs(root.left); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"669. Trim a Binary Search Tree","slug":"669-Trim-a-Binary-Search-Tree","date":"2022-04-16T07:30:04.000Z","updated":"2022-04-16T07:30:13.402Z","comments":true,"path":"2022/04/16/669-Trim-a-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/669-Trim-a-Binary-Search-Tree/","excerpt":"","text":"问题Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds. DFS搜索，每次递归带上搜索的范围值。如果当前节点小于搜索范围，递归当前节点的右子节点。反之递归当前节点的左子节点。如果当前节点在搜索范围中，则其左子节点等于递归后的左子节点，右子节点等于递归后的右子节点。然后返回当前节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null)&#123; return null; &#125; if(root.val &lt; low)&#123; return trimBST(root.right, low, high); &#125; if(root.val &gt; high)&#123; return trimBST(root.left, low, high); &#125; root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"70. Climbing Stairs","slug":"70-Climbing-Stairs","date":"2022-04-15T04:23:11.000Z","updated":"2022-04-15T04:23:11.858Z","comments":true,"path":"2022/04/15/70-Climbing-Stairs/","link":"","permalink":"https://xuanhe95.github.io/2022/04/15/70-Climbing-Stairs/","excerpt":"","text":"问题You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 递归，传入根节点，进行BFS搜索。如果当前节点小于搜索的最低点，则抛弃该节点，继续搜索其右子节点。（由于是BST，右子节点大于节点本身）如果当前节点大于搜索的最高点，则抛弃该节点，继续搜索其左子节点。如果当前节点在搜索范围内，则保留该节点，继续递归该节点的两个子节点。最后返回根节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null)&#123; return null; &#125; if(root.val &lt; low)&#123; return trimBST(root.right, low, high); &#125; if(root.val &gt; high)&#123; return trimBST(root.left, low, high); &#125; root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"191. Number of 1 Bits","slug":"191-Number-of-1-Bits","date":"2022-04-14T11:46:17.000Z","updated":"2022-04-14T11:46:18.083Z","comments":true,"path":"2022/04/14/191-Number-of-1-Bits/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/191-Number-of-1-Bits/","excerpt":"","text":"问题Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. 位运算，[n-1]的二进制数字为[n]的二进制数字退一位。二者的与运算结果相当于二进制下[n]减少最右侧的1。例如0100100的0100011两者的与运算结果为0100000。相当于减少了一位1。计算循环次数就可以得出1的总数。 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while(n != 0)&#123; n = (n &amp; (n-1)); count++; &#125; return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"}]},{"title":"231. Power of Two","slug":"231-Power-of-Two","date":"2022-04-14T08:03:00.000Z","updated":"2022-04-14T08:03:00.903Z","comments":true,"path":"2022/04/14/231-Power-of-Two/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/231-Power-of-Two/","excerpt":"","text":"问题Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n &#x3D;&#x3D; 2x. 位运算，由于2^n^的二进制为[100…00]，当2^n^-1时，其二进制为[11..11]（少一位）。两者进行按位与（&amp;）运算，得到[000…00]，与0相等。 12345678class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0)&#123; return false; &#125; return (n &amp; (n - 1)) == 0; &#125;&#125; 递归，当（n &lt;&#x3D; 0）时，返回false。当n等于1时，返回true。当（n % 2）有余数时，返回false。递归（n &#x2F; 2）。 1234567891011121314class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0)&#123; return false; &#125; if (n == 1)&#123; return true; &#125; if (n%2 != 0)&#123; return false; &#125; return isPowerOfTwo(n/2); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"}]},{"title":"112. Path Sum","slug":"112-Path-Sum","date":"2022-04-14T03:46:28.000Z","updated":"2022-04-14T03:46:28.994Z","comments":true,"path":"2022/04/14/112-Path-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/112-Path-Sum/","excerpt":"","text":"问题Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 递归，如果当前节点为null则返回false。计算并更新当前节点的值。如果当前节点为叶节点，且当前节点的值等于target，则返回true。递归左子节点和右子节点，返回两者的或运算。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; return hasPathSum(root,0,targetSum); &#125; private boolean hasPathSum(TreeNode root, int parentVal, int target)&#123; if (root == null)&#123;return false;&#125; root.val = root.val + parentVal; if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target)&#123; return true; &#125; return ( hasPathSum(root.left, root.val, target) || hasPathSum(root.right, root.val, target)); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"复习","slug":"LeetCode/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"701. Insert into a Binary Search Tree","slug":"701-Insert-into-a-Binary-Search-Tree","date":"2022-04-14T00:59:33.000Z","updated":"2022-04-14T00:59:34.017Z","comments":true,"path":"2022/04/14/701-Insert-into-a-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/701-Insert-into-a-Binary-Search-Tree/","excerpt":"","text":"问题You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. 如果root为空则将值直接添加到根节点。辅助方法比较当前节点的值。如当前值大于添加的值，则检测左子节点是否为空。如不为空则递归左子节点。如当前值小于添加的值，则检测右子节点是否为空。如不为空则递归右子节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null)&#123; root = new TreeNode(val); &#125; insert(root,val); return root; &#125; private void insert(TreeNode root, int val)&#123; if (root.val &lt; val)&#123; if (root.right == null)&#123; root.right = new TreeNode(val); &#125; insert(root.right, val); &#125; else if (root.val &gt; val)&#123; if (root.left == null)&#123; root.left = new TreeNode(val); &#125; insert(root.left, val); &#125; return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"700. Search in a Binary Search Tree","slug":"700-Search-in-a-Binary-Search-Tree","date":"2022-04-14T00:27:52.000Z","updated":"2022-04-14T00:28:06.984Z","comments":true,"path":"2022/04/14/700-Search-in-a-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/700-Search-in-a-Binary-Search-Tree/","excerpt":"","text":"问题You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. 搜索二叉树。递归，如果现有根节点为空则返回空。如果根节点的值大于搜索值则搜索其左子节点。如果根节点的值小于搜索值则搜索其左右节点。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; if (root == null)&#123; return null; &#125; else if (root.val &lt; val)&#123; return searchBST(root.right,val); &#125; else if (root.val &gt; val)&#123; return searchBST(root.left,val); &#125; else&#123; return root; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"120. Triangle","slug":"120-Triangle","date":"2022-04-14T00:14:31.000Z","updated":"2022-04-14T00:17:00.013Z","comments":true,"path":"2022/04/14/120-Triangle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/120-Triangle/","excerpt":"","text":"问题Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. 动态规划，先将最左侧一列的值算出。然后[i+1][j+1]根据[i][j+1]和[i][j]得出。该动态规划表应是为三角形。因此当i等于j时，[i+1][i+j]的数值只根据[i][j]得出。 例子：代码里插入了一个print方法打印动态规划表。当输入列表 [[2],[3,4],[6,5,7],[4,1,8,3]] 时：其动态规划表为： 2, 0, 0, 0, 5, 6, 0, 0, 11, 10, 13, 0, 15, 11, 18, 16, 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[][] dp = new int[triangle.size()][triangle.size()]; int min = Integer.MAX_VALUE; dp[0][0] = triangle.get(0).get(0); for (int i = 0; i &lt; triangle.size()-1; i++)&#123; dp[i+1][0] = dp[i][0] + triangle.get(i+1).get(0); &#125; for (int i = 0; i &lt; triangle.size()-1; i++)&#123; for (int j = 0; j &lt;= i; j++)&#123; if ( i == j )&#123; dp[i+1][j+1] = dp[i][j] + triangle.get(i+1).get(j+1); &#125; else&#123; dp[i+1][j+1] = Math.min(dp[i][j] + triangle.get(i+1).get(j+1), dp[i][j+1] + triangle.get(i+1).get(j+1)); &#125; &#125; &#125; //print(dp); for (int k = 0; k &lt; triangle.size(); k++)&#123; min = Math.min(dp[triangle.size()-1][k],min); &#125; return min; &#125; private void print(int[][] text)&#123; for (int i = 0; i &lt;text.length; i++)&#123; for (int j = 0; j &lt; text[0].length; j++)&#123; System.out.print(text[i][j]+&quot;, &quot;); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"198. House Robber","slug":"198-House-Robber","date":"2022-04-13T20:17:19.000Z","updated":"2022-04-13T20:17:19.895Z","comments":true,"path":"2022/04/14/198-House-Robber/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/198-House-Robber/","excerpt":"","text":"问题You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. 动态规划。dp数组记录经过i个房子后可以获得的最大值。dp[i+1]的值等于dp[i-1]加上现有房子的钱（抢这个房子）与dp[i]的值（不抢这个房子）中的较大值。 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; int[] money = new int[nums.length+1]; money[0] = 0; money[1] = nums[0]; for (int i = 1; i &lt; nums.length; i++)&#123; money[i+1] = Math.max(money[i-1]+nums[i],money[i]); &#125; return money[nums.length]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"226. Invert Binary Tree","slug":"226-Invert-Binary-Tree","date":"2022-04-13T09:29:46.000Z","updated":"2022-04-13T09:29:47.073Z","comments":true,"path":"2022/04/13/226-Invert-Binary-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/226-Invert-Binary-Tree/","excerpt":"","text":"问题Given the root of a binary tree, invert the tree, and return its root. 翻转二叉树。交换当前节点的左右子节点。分别递归其左右子节点。当当前节点的两个节点均为null时返回。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null)&#123; return root; &#125; invert(root); return root; &#125; private void invert(TreeNode root)&#123; if ( root.left == null &amp;&amp; root.right == null)&#123; return; &#125; TreeNode temp = root.left; root.left = root.right; root.right = temp; if ( root.left != null )&#123; invert(root.left); &#125; if ( root.right != null )&#123; invert(root.right); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"784. Letter Case Permutation","slug":"784-Letter-Case-Permutation","date":"2022-04-13T09:14:29.000Z","updated":"2022-04-13T09:14:29.149Z","comments":true,"path":"2022/04/13/784-Letter-Case-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/784-Letter-Case-Permutation/","excerpt":"","text":"答案Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Return the output in any order. 当前字符如果为数字，则直接添加并递归。（将字符隐式转换为整数判断是否为数字，可提升速度。）当前字符如果为字母，则大小写分别添加到递归。（类似于回溯。）当字符串长度与搜寻字符串相等时，添加到列表。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;String&gt; ans; String _s; public List&lt;String&gt; letterCasePermutation(String s) &#123; ans = new ArrayList(); _s = s; backTrack(new StringBuilder(),0); return ans; &#125; private void backTrack(StringBuilder sb, int i)&#123; if(i == _s.length())&#123; ans.add(sb.toString()); return; &#125; char curr = _s.charAt(i); if ( isNums(curr) )&#123; sb.append(curr); backTrack(sb, i+1); &#125; else&#123; StringBuilder sb2 = new StringBuilder(sb); sb.append(Character.toLowerCase(curr)); backTrack(sb, i+1); sb2.append(Character.toUpperCase(curr)); backTrack(sb2, i+1); &#125; &#125; private boolean isNums(char c)&#123; if ( (int)c &gt;= (int)&#x27;0&#x27; &amp;&amp; (int)c &lt;= (int)&#x27;9&#x27; )&#123; return true; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"46. Permutations","slug":"46-Permutations","date":"2022-04-13T08:01:13.000Z","updated":"2022-04-13T08:05:15.386Z","comments":true,"path":"2022/04/13/46-Permutations/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/46-Permutations/","excerpt":"","text":"问题Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. 回溯，建立搜索树。每次遍历nums中的元素。如果未遍历过该元素，则向链表及set中添加。向下递归，链表长度达到nums的长度时返回。然后从set和链表中移除上一个值，回溯到上一个节点。 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans; HashSet&lt;Integer&gt; set; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; ans = new ArrayList(); set = new HashSet(); backTrack(new LinkedList(), nums, nums.length, nums.length); return ans; &#125; private void backTrack(LinkedList&lt;Integer&gt; list,int[] nums, int n, int k)&#123; if(k == 0)&#123; ans.add(new ArrayList(list)); return; &#125; for(int i = 0; i &lt; n ; i++)&#123; if(!set.contains(nums[i]))&#123; list.add(nums[i]); set.add(nums[i]); backTrack(list, nums , n, k-1); set.remove(nums[i]); list.removeLast(); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"}]},{"title":"101. Symmetric Tree","slug":"101-Symmetric-Tree","date":"2022-04-13T07:21:05.000Z","updated":"2022-04-13T07:21:05.710Z","comments":true,"path":"2022/04/13/101-Symmetric-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/101-Symmetric-Tree/","excerpt":"","text":"问题Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). 递归root1的左子节点和root2的右子节点以及root2的左子节点以及root1的右子节点。如两者不相等则返回false。如果传入的两个数值有一个为null，则两者不相等时返回false。反之返回true。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return isSymmetric(root,root); &#125; public boolean isSymmetric(TreeNode root1, TreeNode root2)&#123; if ( root1 == null || root2 == null )&#123; if(root1 == root2)&#123;return true;&#125; else&#123;return false;&#125; &#125; if ( root1.val == root2.val )&#123; return isSymmetric(root1.left,root2.right) &amp;&amp; isSymmetric(root1.right,root2.left); &#125; else&#123; return false; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"104. Maximum Depth of Binary Tree","slug":"104-Maximum-Depth-of-Binary-Tree","date":"2022-04-13T07:05:50.000Z","updated":"2022-04-13T07:05:50.671Z","comments":true,"path":"2022/04/13/104-Maximum-Depth-of-Binary-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/104-Maximum-Depth-of-Binary-Tree/","excerpt":"","text":"问题Given the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 递归，每次返回左子节点和右子节点中较大的结果+1。当节点为null时返回0。 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; &#125;&#125; BFS搜索，每次倾倒出队列里所有的元素并将level+1。搜索完毕返回level。 1234567891011121314151617181920class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; Queue&lt;TreeNode&gt; q = new LinkedList(); q.offer(root); int level = 0; while(!q.isEmpty())&#123; int size = q.size(); for (int i = 0; i &lt; size; i++)&#123; TreeNode curr = q.poll(); if(curr.left!=null)&#123;q.offer(curr.left);&#125; if(curr.right!=null)&#123;q.offer(curr.right);&#125; &#125; level++; &#125; return level; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"102. Binary Tree Level Order Traversal","slug":"102-Binary-Tree-Level-Order-Traversal","date":"2022-04-13T06:51:42.000Z","updated":"2022-04-13T06:55:58.540Z","comments":true,"path":"2022/04/13/102-Binary-Tree-Level-Order-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/102-Binary-Tree-Level-Order-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). BFS搜索，用队列储存树节点。每次循环情到出一个层级所有的节点并放入列表。注意：需要记录队列的size，否则在for each循环时队列size会改变。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); if(root == null)&#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList(); q.add(root); while(!q.isEmpty())&#123; List&lt;Integer&gt; temp = new ArrayList(); int size = q.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode curr = q.poll(); temp.add(curr.val); if(curr.left!=null)&#123;q.offer(curr.left);&#125; if(curr.right!=null)&#123;q.offer(curr.right);&#125; &#125; ans.add(temp); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"77. Combinations","slug":"77-Combinations","date":"2022-04-13T05:52:44.000Z","updated":"2022-04-13T05:52:44.486Z","comments":true,"path":"2022/04/13/77-Combinations/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/77-Combinations/","excerpt":"","text":"问题Given two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order. 回溯，构建搜索树。子节点取出的数值应大于父节点中取出的数值。直到树高度达到k后返回。 返回时，要new一个List，将原有list传入。否则添加到ans的值只是list的内存地址。ArrayList换成LinkedList可以优化一些速度，因为可以直接removeLast。（22ms -&gt; 16ms）i的范围限制在start到n-k+1，后面的限制容易被忽略，可以大幅度减枝，优化速度。（16ms -&gt; 1ms） 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; ans = new ArrayList&lt;&gt;(); backTrack(new LinkedList(),1,n,k); return ans; &#125; private void backTrack(LinkedList&lt;Integer&gt; list, int start, int n, int k)&#123; if (k == 0)&#123; ans.add(new ArrayList(list)); return; &#125; for (int i = start; i &lt;= n-k+1; i++)&#123; list.add(i); backTrack(list, i+1, n, k-1); list.removeLast(); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"}]},{"title":"59. Spiral Matrix II","slug":"59-Spiral-Matrix-II","date":"2022-04-13T03:28:17.000Z","updated":"2022-04-13T03:28:17.228Z","comments":true,"path":"2022/04/13/59-Spiral-Matrix-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/59-Spiral-Matrix-II/","excerpt":"","text":"问题Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. 循环，创建一个上界和一个下界。当达到界限时，改变方向。更新上界和下界的数值。当上界小于下界时返回。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int upperBound = n; int lowerBound = 0; int i = 0; int j = 0; int count = 1; ans[0][0] = 1; while ( lowerBound &lt; upperBound )&#123; while ( j &lt; upperBound-1 )&#123; j++; count++; ans[i][j] = count; &#125; while ( i &lt; upperBound-1 )&#123; i++; count++; ans[i][j] = count; &#125; while ( j &gt; lowerBound )&#123; j--; count++; ans[i][j] = count; &#125; upperBound--; lowerBound++; while ( i &gt; lowerBound )&#123; i--; count++; ans[i][j] = count; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"289. Game of Life","slug":"289-Game-of-Life","date":"2022-04-12T07:12:11.000Z","updated":"2022-04-12T07:12:11.118Z","comments":true,"path":"2022/04/12/289-Game-of-Life/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/289-Game-of-Life/","excerpt":"","text":"问题According to Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.” The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. 辅助方法，计算每个位置四周有生命的总和。根据规则填写到新数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public void gameOfLife(int[][] board) &#123; int[][] ans = new int[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++)&#123; for (int j = 0; j &lt; board[0].length; j++)&#123; int neighbors = countNeighbors(board, i, j); if ( neighbors &lt; 2 &amp;&amp; board[i][j] == 1 )&#123; ans[i][j] = 0; &#125; else if( neighbors &lt;= 3 &amp;&amp; board[i][j] == 1 )&#123; ans[i][j] = 1; &#125; else if( neighbors &gt; 3 &amp;&amp; board[i][j] == 1 )&#123; ans[i][j] = 0; &#125; else if( neighbors == 3 &amp;&amp; board[i][j] == 0)&#123; ans[i][j] = 1; &#125; &#125; &#125; for (int i = 0; i &lt; board.length; i++)&#123; for (int j = 0; j &lt; board[0].length; j++)&#123; board[i][j] = ans[i][j]; &#125; &#125; &#125; private int countNeighbors(int[][] board, int r, int c)&#123; int neighbors = 0; int row = board.length; int col = board[0].length; if(r + 1 &lt; row &amp;&amp; board[r+1][c] == 1)&#123; neighbors++; &#125; if(r - 1 &gt;= 0 &amp;&amp; board[r-1][c] == 1)&#123; neighbors++; &#125; if(c + 1 &lt; col &amp;&amp; board[r][c+1] == 1)&#123; neighbors++; &#125; if(c - 1 &gt;= 0 &amp;&amp; board[r][c-1] == 1)&#123; neighbors++; &#125; if(r + 1 &lt; row &amp;&amp; c + 1 &lt; col &amp;&amp; board[r+1][c+1] == 1)&#123; neighbors++; &#125; if(r + 1 &lt; row &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r+1][c-1] == 1 )&#123; neighbors++; &#125; if(r - 1 &gt;= 0 &amp;&amp; c + 1 &lt; col &amp;&amp; board[r-1][c+1] == 1 )&#123; neighbors++; &#125; if(r - 1 &gt;= 0 &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r-1][c-1] == 1 )&#123; neighbors++; &#125; return neighbors; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"145. Binary Tree Postorder Traversal","slug":"145-Binary-Tree-Postorder-Traversal","date":"2022-04-11T21:00:33.000Z","updated":"2022-04-11T21:02:51.752Z","comments":true,"path":"2022/04/12/145-Binary-Tree-Postorder-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/145-Binary-Tree-Postorder-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the postorder traversal of its nodes’ values. 后序遍历。先递归左子节点。然后递归右子节点。最后将当前节点加入数组。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; ans; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; ans = new ArrayList(); traversal(root); return ans; &#125; private void traversal(TreeNode root)&#123; if (root == null)&#123; return; &#125; traversal(root.left); traversal(root.right); ans.add(root.val); return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"94. Binary Tree Inorder Traversal","slug":"94-Binary-Tree-Inorder-Traversal","date":"2022-04-11T20:54:17.000Z","updated":"2022-04-11T21:02:04.723Z","comments":true,"path":"2022/04/12/94-Binary-Tree-Inorder-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/94-Binary-Tree-Inorder-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the inorder traversal of its nodes’ values. 中序遍历。先递归左子节点。然后将当前节点加入数组。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; ans; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; ans = new ArrayList(); traversal(root); return ans; &#125; private void traversal(TreeNode root)&#123; if (root == null)&#123; return; &#125; traversal(root.left); ans.add(root.val); traversal(root.right); return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"144. Binary Tree Preorder Traversal","slug":"144-Binary-Tree-Preorder-Traversal","date":"2022-04-11T20:49:35.000Z","updated":"2022-04-11T21:02:26.977Z","comments":true,"path":"2022/04/12/144-Binary-Tree-Preorder-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/144-Binary-Tree-Preorder-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the preorder traversal of its nodes’ values. 先序遍历。先将当前节点加入数组。然后递归左子节点。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; ans; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; ans = new ArrayList(); traversal(root); return ans; &#125; private void traversal(TreeNode root)&#123; if (root == null)&#123; return; &#125; ans.add(root.val); traversal(root.left); traversal(root.right); return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"232. Implement Queue using Stacks","slug":"232-Implement-Queue-using-Stacks","date":"2022-04-11T20:29:21.000Z","updated":"2022-04-11T20:29:33.992Z","comments":true,"path":"2022/04/12/232-Implement-Queue-using-Stacks/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/232-Implement-Queue-using-Stacks/","excerpt":"","text":"问题Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise.Notes: You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. 创建两个栈。当入队列时，将元素压入第一个栈。当出队列或进行其他操作时，如第二个栈为空，则将第一个栈的元素倒出到第二个栈。此时第二个栈内的内容为顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyQueue &#123; Stack&lt;Integer&gt; s1; Stack&lt;Integer&gt; s2; public MyQueue() &#123; s1 = new Stack(); s2 = new Stack(); &#125; public void push(int x) &#123; s1.add(x); &#125; public int pop() &#123; if (s2.isEmpty())&#123; while (!s1.isEmpty())&#123; s2.add(s1.pop()); &#125; return s2.pop(); &#125; else&#123; return s2.pop(); &#125; &#125; public int peek() &#123; if (s2.isEmpty())&#123; while (!s1.isEmpty())&#123; s2.add(s1.pop()); &#125; return s2.peek(); &#125; else&#123; return s2.peek(); &#125; &#125; public boolean empty() &#123; return s1.isEmpty() &amp;&amp; s2.isEmpty(); &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"https://xuanhe95.github.io/tags/Queue/"}]},{"title":"1260. Shift 2D Grid","slug":"1260-Shift-2D-Grid","date":"2022-04-11T00:50:48.000Z","updated":"2022-04-11T00:50:48.405Z","comments":true,"path":"2022/04/11/1260-Shift-2D-Grid/","link":"","permalink":"https://xuanhe95.github.io/2022/04/11/1260-Shift-2D-Grid/","excerpt":"","text":"问题Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1].Element at grid[i][n - 1] moves to grid[i + 1][0].Element at grid[m - 1][n - 1] moves to grid[0][0].Return the 2D grid after applying shift operation k times. 遍历整个数组，将索引值加上移动的次数，得到新的位置。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int row = grid.length; int col = grid[0].length; int size = row * col; Integer[][] mat = new Integer[row][col]; for (int i = 0; i &lt; size; i++)&#123; int j = i + k; if ( j &gt; size - 1)&#123; j %= size; &#125; int nr = j / col; int nc = j % col; int or = i / col; int oc = i % col; mat[nr][nc] = grid[or][oc]; &#125; for (int i = 0; i &lt; row; i++)&#123; List&lt;Integer&gt; nums = Arrays.asList(mat[i]); ans.add(nums); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"682. Baseball Game","slug":"682-Baseball-Game","date":"2022-04-10T18:04:38.000Z","updated":"2022-04-10T18:04:38.689Z","comments":true,"path":"2022/04/11/682-Baseball-Game/","link":"","permalink":"https://xuanhe95.github.io/2022/04/11/682-Baseball-Game/","excerpt":"","text":"问题You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds’ scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x.“+” - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores.“D” - Record a new score that is double the previous score. It is guaranteed there will always be a previous score.“C” - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score.Return the sum of all the scores on the record. 遍历选项，根据内容决定对ArrayList的操作。然后遍历将ArrayList加和，返回。 123456789101112131415161718192021222324252627class Solution &#123; public int calPoints(String[] ops) &#123; int ans = 0; List&lt;Integer&gt; records = new ArrayList(); for (String op : ops)&#123; switch(op)&#123; case &quot;+&quot;: records.add(records.get(records.size()-1)+records.get(records.size()-2)); break; case &quot;D&quot;: records.add(records.get(records.size()-1)*2); break; case &quot;C&quot;: records.remove(records.size()-1); break; default: records.add(Integer.parseInt(op)); &#125; &#125; for (int record : records)&#123; ans += record; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"994. Rotting Oranges","slug":"994-Rotting-Oranges","date":"2022-04-10T09:58:27.000Z","updated":"2022-04-10T09:58:27.818Z","comments":true,"path":"2022/04/10/994-Rotting-Oranges/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/994-Rotting-Oranges/","excerpt":"","text":"问题You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. 由于腐烂的橘子每次都只能影响周围的橘子，因此采用BFS。将所有腐烂的橘子加入队列。如果没有新鲜的橘子，则返回0。每次出队列，如果周围有新鲜的橘子存在，则将新鲜的橘子替换为腐烂并加入队列。每个level结束后，time+1。 最后遍历一遍，如果还有新鲜的橘子，返回-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public int orangesRotting(int[][] grid) &#123; Queue&lt;Integer&gt; q = new LinkedList(); int row = grid.length; int col = grid[0].length; int fresh = 0; for (int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if ( grid[i][j] == 2)&#123; q.add(i * col + j); &#125; else if (grid[i][j] == 1)&#123; fresh++; &#125; &#125; &#125; if(fresh == 0)&#123;return 0;&#125; int count = q.size()-1; int temp = 0; int time = -1; while(!q.isEmpty())&#123; int i = q.peek() / col; int j = q.poll() % col; if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == 1)&#123; grid[i-1][j] = 2; q.add((i-1)*col+j); temp++; &#125; if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == 1)&#123; grid[i][j-1] = 2; q.add(i*col+(j-1)); temp++; &#125; if(i+1&lt;row &amp;&amp; grid[i+1][j] == 1)&#123; grid[i+1][j] = 2; q.add((i+1)*col+j); temp++; &#125; if(j+1&lt;col &amp;&amp; grid[i][j+1] == 1)&#123; grid[i][j+1] = 2; q.add(i*col+(j+1)); temp++; &#125; if(count == 0)&#123; count = temp; temp = 0; time++; &#125; count--; &#125; for (int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if ( grid[i][j] == 1)&#123; return -1; &#125; &#125; &#125; return time; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"}]},{"title":"542. 01 Matrix","slug":"542-01-Matrix","date":"2022-04-10T09:13:25.000Z","updated":"2022-04-10T09:13:25.756Z","comments":true,"path":"2022/04/10/542-01-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/542-01-Matrix/","excerpt":"","text":"问题Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.The distance between two adjacent cells is 1. 由于是搜索最近的距离，因此可以采用BFS搜索。首先创建一个距离矩阵，将所有原矩阵为0的位置填上距离0，将其他位置填上无穷大。使用BFS搜索，将所有0的坐标放入队列。取出队列头元素，将其周围的距离矩阵的元素与自身距离矩阵的元素+1比较，将较小的值设置在周围的距离矩阵上。同时，将改变数值的坐标再次放入队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123; public int[][] updateMatrix(int[][] mat) &#123; Queue&lt;Integer&gt; q = new LinkedList(); int row = mat.length; int col = mat[0].length; int[][] ans = new int[row][col]; for ( int i = 0; i &lt; row; i++ )&#123; for (int j = 0; j &lt; col; j++)&#123; if (mat[i][j] == 0)&#123; ans[i][j] = 0; q.add(i*col + j); &#125; else&#123; ans[i][j] = Integer.MAX_VALUE; &#125; &#125; &#125; while(!q.isEmpty())&#123; int i = q.peek() / col; int j = q.poll() % col; if(i-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i-1][j])&#123; ans[i-1][j] = ans[i][j]+1; q.add((i-1)*col + j); &#125; if(i+1 &lt; row &amp;&amp; ans[i][j]+1 &lt; ans[i+1][j])&#123; ans[i+1][j] = ans[i][j]+1; q.add((i+1)*col + j); &#125; if(j-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i][j-1])&#123; ans[i][j-1] = ans[i][j]+1; q.add(i*col + (j-1)); &#125; if(j+1 &lt; col &amp;&amp; ans[i][j]+1 &lt; ans[i][j+1])&#123; ans[i][j+1] = ans[i][j]+1; q.add(i*col + (j+1)); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"}]},{"title":"116. Populating Next Right Pointers in Each Node","slug":"116-Populating-Next-Right-Pointers-in-Each-Node","date":"2022-04-10T06:29:14.000Z","updated":"2022-04-10T06:29:14.640Z","comments":true,"path":"2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/","excerpt":"","text":"问题You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456 struct Node &#123; int val; Node *left; Node *right; Node *next;&gt;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 递归，当root为null时返回。如果root有右节点，则左节点next指向右节点。如果root有右节点同时next已经指向了一个节点，则将其右节点next指向该节点的左子节点。递归左右子节点，并返回root。 1234567891011121314151617181920212223242526272829303132333435363738/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root==null)&#123;return root;&#125; if (root.right!=null)&#123; root.left.next = root.right; if (root.next!=null)&#123; root.right.next = root.next.left; &#125; &#125; connect(root.left); connect(root.right); return root; &#125;&#125; BFS搜索每一个节点，将节点指向队列中next下一个节点。当计数器达到2的指数时，将节点指向null。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return root; &#125; int count = 1; Queue&lt;Node&gt; q = new LinkedList(); q.offer(root); while (!q.isEmpty())&#123; count++; Node curr = q.poll(); if ( isPow(count) )&#123; curr.next = null; &#125; else&#123; curr.next = q.peek(); &#125; if(curr.left!=null)&#123; q.add(curr.left); &#125; if(curr.right!=null)&#123; q.add(curr.right); &#125; &#125; return root; &#125; private boolean isPow(int val)&#123; if(val == 0 || val == 1)&#123; return false; &#125; while ( val % 2 == 0 )&#123; val = val / 2; &#125; if (val == 1)&#123; return true; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"20. Valid Parentheses","slug":"20-Valid-Parentheses","date":"2022-04-10T03:19:50.000Z","updated":"2022-04-10T03:19:50.707Z","comments":true,"path":"2022/04/10/20-Valid-Parentheses/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/20-Valid-Parentheses/","excerpt":"","text":"问题Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 用栈储存遍历中的字符。如果是“（”，“{”或“[”，则入栈。如果是其他字符，且不与栈顶的字符成对，则返回false。其他情况需要pop掉栈顶。 toCharArray(): 将字符串转换为字符数组，便于遍历。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack(); for (char c : s.toCharArray())&#123; if ( c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27; )&#123; stack.push(c); &#125; else if ( stack.size() == 0 || c == &#x27;)&#x27; &amp;&amp; stack.peek() != &#x27;(&#x27; || c == &#x27;&#125;&#x27; &amp;&amp; stack.peek() != &#x27;&#123;&#x27; || c == &#x27;]&#x27; &amp;&amp; stack.peek() != &#x27;[&#x27;) &#123; return false; &#125; else&#123; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"}]},{"title":"617. Merge Two Binary Trees","slug":"617-Merge-Two-Binary-Trees","date":"2022-04-10T01:39:03.000Z","updated":"2022-04-10T01:39:03.743Z","comments":true,"path":"2022/04/10/617-Merge-Two-Binary-Trees/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/617-Merge-Two-Binary-Trees/","excerpt":"","text":"问题You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. 递归。将root1和root2合并到root1。如果一个节点为null，则返回另一个节点。否则root1的值为root1 + root2的值。root1.left递归root1和root2的left。root2.right递归root1和root2的right。返回root1。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if( root1 == null )&#123; return root2; &#125; if( root2 == null )&#123; return root1; &#125; root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"83. Remove Duplicates from Sorted List","slug":"83-Remove-Duplicates-from-Sorted-List","date":"2022-04-10T00:38:58.000Z","updated":"2022-04-10T00:41:06.849Z","comments":true,"path":"2022/04/10/83-Remove-Duplicates-from-Sorted-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/83-Remove-Duplicates-from-Sorted-List/","excerpt":"","text":"问题Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 设置前一个节点和当前节点两个指针。由于是有数的链表，遍历时可以直接比较两个节点。如相等则前一个节点的next指向当前节点的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if ( head == null)&#123; return head; &#125; if ( head.next == null)&#123; return head; &#125; ListNode prev = head; ListNode curr = head.next; while(curr != null)&#123; if(prev.val != curr.val)&#123; curr = curr.next; prev = prev.next; &#125; else&#123; prev.next = curr.next; curr = curr.next; &#125; &#125; return head; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"695. Max Area of Island","slug":"695-Max-Area-of-Island","date":"2022-04-10T00:03:12.000Z","updated":"2022-04-10T00:20:50.087Z","comments":true,"path":"2022/04/10/695-Max-Area-of-Island/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/695-Max-Area-of-Island/","excerpt":"","text":"问题You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. DFS, 遍历每个等于1的地图块。递归周围四个地图块，当超越数组范围时返回0。进行搜索时将搜索过的地图块设为0。否则运行BFS时将全局变量count增加。执行完毕后BFS时将全局变量count清零。 count计算的是BFS执行的次数 12345678910111213141516171819202122232425262728293031class Solution &#123; int count = 0; public int maxAreaOfIsland(int[][] grid) &#123; int best = 0; for(int i = 0; i &lt; grid.length ; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if ( grid[i][j] == 1 )&#123; best = Math.max(best, dfs(grid,i,j)); count = 0; &#125; &#125; &#125; return best; &#125; private int dfs(int[][] grid, int i, int j)&#123; if((i &lt; 0 || i &gt; grid.length -1) || (j &lt; 0 || j &gt; grid[0].length -1 ) || grid[i][j] == 0)&#123; return 0; &#125; grid[i][j] = 0; count++; dfs(grid,i-1,j); dfs(grid,i,j-1); dfs(grid,i+1,j); dfs(grid,i,j+1); return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"}]},{"title":"347. Top K Frequent Elements","slug":"347-Top-K-Frequent-Elements","date":"2022-04-09T23:39:16.000Z","updated":"2022-04-09T23:39:16.609Z","comments":true,"path":"2022/04/10/347-Top-K-Frequent-Elements/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/347-Top-K-Frequent-Elements/","excerpt":"","text":"问题Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. 遍历，使用哈希表保存遍历次数。再次遍历，根据元素出现的次数将其填入大根堆。遍历取出k个最大值。 getOrDefault()：方便的遍历并生成哈希表。 lambda： （）内表示传入的数值。-&gt; 后表示返回值。 1234567891011121314151617class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; int[] ans = new int[k]; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for (int num : nums)&#123; map.put( num, map.getOrDefault(num , 0) + 1 ); &#125; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue((a,b) -&gt; map.get(b) - map.get(a)); for (int key : map.keySet())&#123; pq.add(key); &#125; for (int i = 0; i &lt; k ; i++)&#123; ans[i] = pq.poll(); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"}]},{"title":"206. Reverse Linked List","slug":"206-Reverse-Linked-List","date":"2022-04-09T19:49:54.000Z","updated":"2022-04-09T19:49:54.819Z","comments":true,"path":"2022/04/10/206-Reverse-Linked-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/206-Reverse-Linked-List/","excerpt":"","text":"问题Given the head of a singly linked list, reverse the list, and return the reversed list. 翻转列表，当链表长度不足时，直接返回原链表。将头元素设置到preNode，同时将其next设置为null，作为新链表的尾。将其余的元素设置到curNode。 当当前节点不为null时遍历： 将curNode的next保存在temp。 将curNode的next指向preNode，作为preNode的上一个节点。 将preNode指向curNode，完成交换。 将curNode指向temp，curNode变为原来的curNode的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if( head == null )&#123; //if not enough, return head return head; &#125; if ( head.next == null )&#123; return head; &#125; ListNode preNode = head; //set head to preNode, it will be the last node in the end ListNode curNode = head.next; //curNode move to next preNode.next = null; //only preserve one head node ListNode temp; while( curNode != null )&#123; temp = curNode.next; //preserve nodes after curNode curNode.next = preNode; //cur -&gt; pre preNode = curNode; //set back reversed list to preNode curNode = temp; //put back preserved nodes, curNode move to the next &#125; return preNode; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"203. Remove Linked List Elements","slug":"203-Remove-Linked-List-Elements","date":"2022-04-09T02:39:09.000Z","updated":"2022-04-09T02:39:09.603Z","comments":true,"path":"2022/04/09/203-Remove-Linked-List-Elements/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/203-Remove-Linked-List-Elements/","excerpt":"","text":"问题Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head. 设置哨兵节点，将其next指向头部。设置前节点，将其指向哨兵节点。设置尾部节点，并指向头部。移动当前节点尾部，如尾部的val等于需要删去的val，则将前节点的next指向尾部的next。尾部的next如为null，则前节点的next指向null。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null)&#123; return head; &#125; ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode preNode = dummyHead; ListNode tail = dummyHead.next; while( tail != null )&#123; if ( tail.next == null &amp;&amp; tail.val == val )&#123; preNode.next = null; break; &#125; else if (tail.val == val)&#123; preNode.next = tail.next; tail = preNode.next; &#125; else&#123; preNode = preNode.next; tail = tail.next; &#125; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"733. Flood Fill","slug":"733-Flood-Fill","date":"2022-04-09T01:13:45.000Z","updated":"2022-04-09T01:13:45.287Z","comments":true,"path":"2022/04/09/733-Flood-Fill/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/733-Flood-Fill/","excerpt":"","text":"答案An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. Return the modified image after performing the flood fill. 深度优先搜索。如果当前像素颜色等于最初的颜色，则变更为新颜色。然后继续递归四个周围的像素。 1234567891011121314151617181920212223242526272829class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; int oldColor = image[sr][sc]; if (oldColor != newColor)&#123; dfs(image,sr,sc,oldColor,newColor); &#125; return image; &#125; private void dfs(int[][] image, int r, int c, int oldColor, int newColor)&#123; if (image[r][c] == oldColor)&#123; image[r][c] = newColor; if (r&gt;=1)&#123; dfs(image,r-1,c,oldColor,newColor); &#125; if (c&gt;=1)&#123; dfs(image,r,c-1,oldColor,newColor); &#125; if (r&lt;image.length-1)&#123; dfs(image,r+1,c,oldColor,newColor); &#125; if (c&lt;image[0].length-1)&#123; dfs(image,r,c+1,oldColor,newColor); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"}]},{"title":"21. Merge Two Sorted Lists","slug":"21-Merge-Two-Sorted-Lists","date":"2022-04-09T00:19:16.000Z","updated":"2022-04-09T00:19:16.999Z","comments":true,"path":"2022/04/09/21-Merge-Two-Sorted-Lists/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/21-Merge-Two-Sorted-Lists/","excerpt":"","text":"问题You are given the heads of two sorted linked lists list1 and list2.》Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 先设置空的哨兵节点，然后将尾部指针指向这个节点。遍历两个链表，将尾部节点的下一个值指向两个节点中值较小的一个。然后将指针移动到下一个值。最后返回哨兵节点的下一个节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode dummyHead = new ListNode(); ListNode tail = dummyHead; while ( list1 != null &amp;&amp; list2 !=null )&#123; if (list1.val &lt; list2.val)&#123; tail.next = list1; list1 = list1.next; tail = tail.next; &#125; else&#123; tail.next = list2; list2 = list2.next; tail = tail.next; &#125; &#125; if ( list1 == null)&#123; tail.next = list2; &#125; else &#123; tail.next = list1; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"141. Linked List Cycle","slug":"141-Linked-List-Cycle","date":"2022-04-08T21:24:04.000Z","updated":"2022-04-08T21:24:52.458Z","comments":true,"path":"2022/04/09/141-Linked-List-Cycle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/141-Linked-List-Cycle/","excerpt":"","text":"问题Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. 遍历并移动快慢指针。如两个指针最终相遇，则链表中有循环。如快指针移动到链表尾部，则链表无循环。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; if ( head == null)&#123; return false; &#125; else if ( fast.next == null)&#123; return false; &#125; while( fast != null &amp;&amp; fast.next != null )&#123; slow = slow.next; fast = fast.next.next; if (slow == fast)&#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"703. Kth Largest Element in a Stream","slug":"703-Kth-Largest-Element-in-a-Stream","date":"2022-04-08T20:06:37.000Z","updated":"2022-04-08T20:06:37.916Z","comments":true,"path":"2022/04/09/703-Kth-Largest-Element-in-a-Stream/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/703-Kth-Largest-Element-in-a-Stream/","excerpt":"","text":"问题Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. 优先级队列，插入所有元素，小元素在前。当队列长度大于k时，poll掉前面的元素。 12345678910111213141516171819202122232425class KthLargest &#123; PriorityQueue&lt;Integer&gt; pq; int kth; public KthLargest(int k, int[] nums) &#123; pq = new PriorityQueue&lt;Integer&gt;(); kth = k; for (int num : nums)&#123; pq.add(num); &#125; &#125; public int add(int val) &#123; pq.add(val); while (pq.size() &gt; kth)&#123; pq.poll(); &#125; return pq.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"}]},{"title":"242. Valid Anagram","slug":"242-Valid-Anagram","date":"2022-04-07T06:40:19.000Z","updated":"2022-04-07T06:40:19.263Z","comments":true,"path":"2022/04/07/242-Valid-Anagram/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/242-Valid-Anagram/","excerpt":"","text":"问题Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 两数组相等时，直接遍历两个数组并记录各个字符出现的数量。一个数组遍历时用做加法，另一个做减法。如果最后每个字符出现的数量均为0，则返回真。 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length()!=t.length())&#123; return false; &#125; int[] dic = new int[26]; for (int i = 0; i &lt; s.length(); i++)&#123; dic[s.charAt(i)-&#x27;a&#x27;]++; dic[t.charAt(i)-&#x27;a&#x27;]--; &#125; for(int num : dic)&#123; if ( num != 0 )&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[]},{"title":"567. Permutation in String","slug":"567-Permutation-in-String","date":"2022-04-07T06:28:20.000Z","updated":"2022-04-07T06:35:24.973Z","comments":true,"path":"2022/04/07/567-Permutation-in-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/567-Permutation-in-String/","excerpt":"","text":"问题Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2. 将要查找的组合加入数组，数值为字符出现的次数。滑动窗口，入窗口对应的元素数值-1，出窗口对应的元素数值+1。每次移动窗口都检验一次数组的数值是否全部为0，如果是真，则返回真。小技巧：直接用数组来记录字符出现的次数，用字符减去与’a’的差作为下标。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1.length() &gt; s2.length())&#123; return false; &#125; int[] dic = new int[26]; for (int i = 0; i &lt; s1.length(); i++)&#123; dic[s1.charAt(i)-&#x27;a&#x27;]++; dic[s2.charAt(i)-&#x27;a&#x27;]--; &#125; int i = 0; int j = s1.length(); while( j &lt; s2.length() )&#123; if ( allZero(dic) )&#123; return true; &#125; dic[s2.charAt(i)-&#x27;a&#x27;]++; dic[s2.charAt(j)-&#x27;a&#x27;]--; i++; j++; &#125; return allZero(dic); &#125; private boolean allZero(int[] dic)&#123; for (int num : dic)&#123; if ( num != 0 )&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"3-Longest-Substring-Without-Repeating-Characters","date":"2022-04-07T05:50:40.000Z","updated":"2022-04-07T05:54:16.146Z","comments":true,"path":"2022/04/07/3-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/3-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"问题Given a string s, find the length of the longest substring without repeating characters. 滑动窗口，哈希表记录访问过的字符的元素。如果重复，则放弃前一个重复的字符，更新左指针。注意：只有在新指针大于现有指针时才更新！ 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int best = 0; int i = 0; int j = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); while ( j &lt; s.length() )&#123; char curChar = s.charAt(j); if ( !map.containsKey(curChar) )&#123; map.put( curChar, j ); &#125; else&#123; if ( map.get(curChar) + 1 &gt; i)&#123; i = map.get(curChar) + 1; &#125; map.put( curChar, j ); &#125; if ((j - i + 1) &gt; best)&#123; best = (j - i + 1); &#125; j++; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"383. Ransom Note","slug":"383-Ransom-Note","date":"2022-04-07T05:02:15.000Z","updated":"2022-04-07T05:02:15.980Z","comments":true,"path":"2022/04/07/383-Ransom-Note/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/383-Ransom-Note/","excerpt":"","text":"问题Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. 哈希表，遍历添加字典及次数。然后遍历note，与字典中的字符数量作比较。 可以优化速度，采用数组记录所有英文字母的数量。 12345678910111213141516171819202122232425class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; HashMap&lt;Character, Integer&gt; dic = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; magazine.length(); i++)&#123; char curChar = magazine.charAt(i); if (!dic.containsKey(curChar))&#123; dic.put(curChar, 1); &#125; else&#123; dic.put(curChar, dic.get(curChar)+1); &#125; &#125; for (int i = 0; i &lt; ransomNote.length(); i++)&#123; char curChar = ransomNote.charAt(i); if (dic.containsKey(curChar) &amp;&amp; dic.get(curChar) &gt; 0)&#123; dic.put(curChar, dic.get(curChar)-1); &#125; else&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"387. First Unique Character in a String","slug":"387-First-Unique-Character-in-a-String","date":"2022-04-07T04:48:17.000Z","updated":"2022-04-07T04:48:17.959Z","comments":true,"path":"2022/04/07/387-First-Unique-Character-in-a-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/387-First-Unique-Character-in-a-String/","excerpt":"","text":"问题Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. 遍历，建立哈希表，记录出现次数。再次遍历，如果出现次数为1，则返回下标。 1234567891011121314151617181920212223class Solution &#123; public int firstUniqChar(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for ( int i = 0; i &lt; s.length(); i++ )&#123; char curChar = s.charAt(i); if ( !map.containsKey(curChar) )&#123; map.put(curChar, 1); &#125; else&#123; map.put(curChar, map.get(curChar)+1); &#125; &#125; for ( int i = 0; i &lt; s.length(); i++ )&#123; char curChar = s.charAt(i); if ( map.get(curChar) == 1 )&#123; return i; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"1046. Last Stone Weight","slug":"1046-Last-Stone-Weight","date":"2022-04-07T04:09:40.000Z","updated":"2022-04-07T04:09:40.205Z","comments":true,"path":"2022/04/07/1046-Last-Stone-Weight/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/1046-Last-Stone-Weight/","excerpt":"","text":"问题You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;&#x3D; y. The result of this smash is: If x &#x3D;&#x3D; y, both stones are destroyed, and If x !&#x3D; y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0. 采用PriorityQueue队列，将所有元素放入。每次取出两个，将两者的差值放回队列。 12345678910111213141516class Solution &#123; public int lastStoneWeight(int[] stones) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for (int stone : stones)&#123; pq.add(stone); &#125; while ( pq.size() &gt; 1) &#123; int largeStone = pq.poll(); int smallStone = pq.poll(); pq.add( largeStone - smallStone ); &#125; return pq.poll(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"680. Valid Palindrome II","slug":"680-Valid-Palindrome-II","date":"2022-04-07T00:37:01.000Z","updated":"2022-04-07T00:37:01.629Z","comments":true,"path":"2022/04/07/680-Valid-Palindrome-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/680-Valid-Palindrome-II/","excerpt":"","text":"问题Given a string s, return true if the s can be palindrome after deleting at most one character from it. 双指针，字符串两边对比。如果两边字符不相等，则更新两边指针，并分别传入辅助方法再次对比。两个结果有一个是true则返回true。 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0; int right = s.length() - 1; while (left &lt; right)&#123; if (s.charAt(left) == s.charAt(right) )&#123; left++; right--; &#125; else&#123; return ( checkPalindrome(s, left+1, right) || checkPalindrome(s, left, right-1)); &#125; &#125; return true; &#125; private boolean checkPalindrome(String s, int left, int right)&#123; while (left &lt; right)&#123; if (s.charAt(left)==s.charAt(right))&#123; left++; right--; &#125; else&#123; return false; &#125; &#125; return true; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"19. Remove Nth Node From End of List","slug":"19-Remove-Nth-Node-From-End-of-List","date":"2022-04-06T20:18:11.000Z","updated":"2022-04-08T21:26:44.655Z","comments":true,"path":"2022/04/07/19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/19-Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"问题Given the head of a linked list, remove the nth node from the end of the list and return its head. 双指针，同时记录前n个节点和当前节点。当前指针到链表尾部时，删除前面的指针，注意处理edge cases。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode preNode = null; ListNode removedNode = head; ListNode fastNode = head; for ( int i = 0; i &lt; n; i++ )&#123; fastNode = fastNode.next; &#125; while ( fastNode != null )&#123; fastNode = fastNode.next; preNode = removedNode; removedNode = removedNode.next; &#125; if ( removedNode == head )&#123; head = head.next; &#125; else if ( removedNode.next == null)&#123; preNode.next = null; &#125; else&#123; preNode.next = removedNode.next; &#125; return head; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"876. Middle of the Linked List","slug":"876-Middle-of-the-Linked-List","date":"2022-04-06T19:53:17.000Z","updated":"2022-04-08T21:27:14.358Z","comments":true,"path":"2022/04/07/876-Middle-of-the-Linked-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/876-Middle-of-the-Linked-List/","excerpt":"","text":"问题Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 快慢指针，两个指针不同速度遍历链表。当快指针达到链表尾部时候，慢指针正好在中间。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode slowNode = head; ListNode fastNode = head; while( fastNode != null )&#123; fastNode = fastNode.next; if (fastNode == null)&#123; return slowNode; &#125; slowNode = slowNode.next; fastNode = fastNode.next; &#125; return slowNode; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"74. Search a 2D Matrix","slug":"74-Search-a-2D-Matrix","date":"2022-04-06T19:51:13.000Z","updated":"2022-04-06T19:51:14.021Z","comments":true,"path":"2022/04/07/74-Search-a-2D-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/74-Search-a-2D-Matrix/","excerpt":"","text":"问题Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 双指针，先搜索到合适的行。再搜索到合适的列。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0; int j = 0; while ( i &lt; matrix.length ) &#123; int num = matrix[i][j]; if ( num == target )&#123; return true; &#125; else if ( num &lt; target )&#123; i++; &#125; else&#123; break; &#125; &#125; if ( i == 0 )&#123; return false; &#125; i--; while ( j &lt; matrix[0].length )&#123; int num = matrix[i][j]; if ( num == target )&#123; return true; &#125; else if ( num &lt; target )&#123; j++; &#125; else&#123; return false; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"36. Valid Sudoku","slug":"36-Valid-Sudoku","date":"2022-04-06T19:08:49.000Z","updated":"2022-04-06T19:08:49.845Z","comments":true,"path":"2022/04/07/36-Valid-Sudoku/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/36-Valid-Sudoku/","excerpt":"","text":"问题Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. 遍历并创建三组不同的哈希表，每个表内包含一组哈希集合。如果访问的元素已在哈希集合内，则返回false 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; rowMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; colMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; blockMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); for (int i = 0; i &lt; board[0].length; i++ )&#123; for (int j = 0; j &lt; board.length; j++ )&#123; char curChar = board[i][j]; if (curChar == &#x27;.&#x27;)&#123; continue; &#125; if (!rowMap.containsKey(i))&#123; rowMap.put(i, new HashSet&lt;Character&gt;()); &#125; if (!colMap.containsKey(j))&#123; colMap.put(j, new HashSet&lt;Character&gt;()); &#125; if (!blockMap.containsKey(j/3*3+i/3))&#123; blockMap.put(j/3*3+i/3, new HashSet&lt;Character&gt;()); &#125; HashSet&lt;Character&gt; curRow = rowMap.get(i); HashSet&lt;Character&gt; curCol = colMap.get(j); HashSet&lt;Character&gt; curBlock = blockMap.get(j/3*3+i/3); if ( !curRow.contains(curChar) &amp;&amp; !curCol.contains(curChar) &amp;&amp; !curBlock.contains(curChar) )&#123; curRow.add(curChar); curCol.add(curChar); curBlock.add(curChar); &#125; else&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"923. 3Sum With Multiplicity","slug":"923-3Sum-With-Multiplicity","date":"2022-04-06T18:27:00.000Z","updated":"2022-04-06T18:27:00.097Z","comments":true,"path":"2022/04/07/923-3Sum-With-Multiplicity/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/923-3Sum-With-Multiplicity/","excerpt":"","text":"问题Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] &#x3D;&#x3D; target. As the answer can be very large, return it modulo 109 + 7. 首先遍历元素，根据元素的值和出现次数建立哈希表。然后再哈希表中选择三个元素，如果和等于target，则计算三个元素出现次数的乘积。最后除以重复计算的次数。由于数值较大，因此中途计算应该采用长整型long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int threeSumMulti(int[] arr, int target) &#123; //enumberate every element and put them into the map HashMap&lt;Integer, Long&gt; map = new HashMap&lt;Integer, Long&gt;(); long count = 0; for ( int num : arr )&#123; if (!map.containsKey(num))&#123; map.put(num, (long)1); &#125; else&#123; map.put(num, map.get(num)+1); &#125; &#125; //traverse whole elements and select three numbers for ( int a : map.keySet() )&#123; long totalA = map.get(a); for (int b : map.keySet())&#123; long totalB = map.get(b); if ( a == b )&#123; if (totalB &lt; 2)&#123; continue; &#125; totalB = totalB - 1; &#125; int c = target - a - b; if ( map.containsKey(c) )&#123; long totalC = map.get(c); long total = 0; if ( a == b &amp;&amp; b == c )&#123; total = totalA * totalB * ( totalC - 2 ) ; &#125; else if ( b == c || a == c )&#123; total = totalA * totalB * ( totalC - 1 ) ; &#125; else&#123; total = totalA * totalB * totalC; &#125; if ( total &gt; 0 )&#123; count += total; &#125; &#125; &#125; &#125; count/=6; int ans = (int) (count % 1000000007); return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"118. Pascal's Triangle","slug":"118-Pascal-s-Triangle","date":"2022-04-05T18:53:43.000Z","updated":"2022-04-05T19:01:11.012Z","comments":true,"path":"2022/04/06/118-Pascal-s-Triangle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/118-Pascal-s-Triangle/","excerpt":"","text":"问题Given an integer numRows, return the first numRows of Pascal’s triangle. 动态规划，直接按照杨辉三角形的定义计算。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows); for (int i = 0; i &lt; numRows ; i++)&#123; List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(i+1); for (int j = 0; j &lt;= i; j++)&#123; if ( j == 0 || j == i )&#123; arr.add(1); &#125; else&#123; arr.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j)); &#125; &#125; ans.add(arr); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"11. Container With Most Water","slug":"11-Container-With-Most-Water","date":"2022-04-05T16:50:01.000Z","updated":"2022-04-05T19:03:02.604Z","comments":true,"path":"2022/04/06/11-Container-With-Most-Water/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/11-Container-With-Most-Water/","excerpt":"","text":"问题You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. 双指针在首尾，二者容量取决于两者中较小的一个。贪心算法，保留两个指针上较大的元素，移动较小一边的指针。由于指针移动时距离只会减小，因此当新的元素比上一个更大时才有可能比之前的容量更大。遍历一次找到最大容量。时间复杂度：O(n) 感觉这个移动有点博弈论的味了，每次都移动自己最差的一边，虽然可能变得更差，但是总比不动（或者减小）强，动最差的部分可能找到更好的结果，但是动另一边总会更差或者不变，兄弟们，这不是题，这是人生，逃离舒适圈！！（这解释我觉得无敌了，哈哈哈） 12345678910111213141516171819202122232425class Solution &#123; public int maxArea(int[] height) &#123; int best = 0; int i = 0; int j = height.length - 1; while ( i &lt; j )&#123; int product = 0; if (height[i] &lt; height[j])&#123; product = height[i] * ( j -i ); i++; &#125; else&#123; product = height[j] * ( j -i ); j--; &#125; if ( product &gt; best)&#123; best = product; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"344. Reverse String","slug":"344-Reverse-String","date":"2022-04-05T13:56:14.000Z","updated":"2022-04-05T19:06:30.027Z","comments":true,"path":"2022/04/05/344-Reverse-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/344-Reverse-String/","excerpt":"","text":"问题简述Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. 双指针，同时更新并交换两个数值。 12345678910111213141516class Solution &#123; public void reverseString(char[] s) &#123; int i = 0; int j = s.length - 1; while( i &lt; j ) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"167. Two Sum II - Input Array Is Sorted","slug":"167-Two-Sum-II-Input-Array-Is-Sorted","date":"2022-04-05T05:52:45.000Z","updated":"2022-04-05T19:05:47.624Z","comments":true,"path":"2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","excerpt":"","text":"问题描述Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 由于是有序数列，因此可以采用双指针。左右两侧和不等于目标时，根据大小结果移动左右指针。 123456789101112131415161718192021222324class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int i = 0; int j = numbers.length - 1; int[] ans = new int[2]; while( i &lt; j )&#123; int diff = target - numbers[j]; if ( diff == numbers[i])&#123; ans[0] = i+1; ans[1] = j+1; return ans; &#125; else if ( diff &lt; numbers[i] ) &#123; j--; &#125; else&#123; i++; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"566. Reshape the Matrix","slug":"566-Reshape-the-Matrix","date":"2022-04-05T04:40:01.000Z","updated":"2022-04-06T19:53:31.024Z","comments":true,"path":"2022/04/05/566-Reshape-the-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/566-Reshape-the-Matrix/","excerpt":"","text":"问题概述In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. 根据数组的数学公式得出其位置，一次遍历将原数组中的数字填入。O(r*c) 1234567891011121314151617181920212223class Solution &#123; public int[][] matrixReshape(int[][] mat, int r, int c) &#123; int[][] ans = new int[r][c]; int oldR = mat.length; int oldC = mat[0].length; if ( oldR * oldC != r * c )&#123; return mat; &#125; for (int i = 0; i &lt; r*c ; i++ )&#123; int m = i/oldC; int n = i%oldC; int p = i/c; int q = i%c; ans[p][q] = mat[m][n]; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"283. Move Zeroes","slug":"283-Move-Zeroes","date":"2022-04-04T18:11:56.000Z","updated":"2022-04-10T23:11:57.492Z","comments":true,"path":"2022/04/05/283-Move-Zeroes/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/283-Move-Zeroes/","excerpt":"","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int j = 0; while ( j &lt; nums.length )&#123; if ( nums[j] != 0 )&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; &#125; j++; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"121-Best-Time-to-Buy-and-Sell-Stock","date":"2022-04-04T17:50:49.000Z","updated":"2022-04-10T23:11:49.674Z","comments":true,"path":"2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","excerpt":"","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ )&#123; difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] )&#123; difference[i] = difference[i] + difference[i - 1]; &#125; if (difference[i] &gt; best)&#123; best = difference[i]; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"350. Intersection of Two Arrays II","slug":"350-Intersection-of-Two-Arrays-II","date":"2022-04-04T12:42:40.000Z","updated":"2022-04-10T23:11:36.836Z","comments":true,"path":"2022/04/04/350-Intersection-of-Two-Arrays-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/350-Intersection-of-Two-Arrays-II/","excerpt":"","text":"问题描述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ )&#123; if (!map.containsKey(nums1[i]))&#123; map.put(nums1[i],1); &#125; else&#123; map.put(nums1[i],map.get(nums1[i])+1); &#125; &#125; for ( int i = 0 ; i &lt; nums2.length ; i++ )&#123; if (map.containsKey(nums2[i]))&#123; if (map.get(nums2[i]) &gt; 0)&#123; count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); &#125; &#125; &#125; int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++)&#123; ans[i] = arr.get(i); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"31. Next Permutation","slug":"31-Next-Permutation","date":"2022-04-03T20:11:22.000Z","updated":"2022-04-05T05:58:47.787Z","comments":true,"path":"2022/04/04/31-Next-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/31-Next-Permutation/","excerpt":"","text":"问题描述A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr &#x3D; [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr &#x3D; [1,2,3] is [1,3,2].Similarly, the next permutation of arr &#x3D; [2,3,1] is [3,1,2].While the next permutation of arr &#x3D; [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public void nextPermutation(int[] nums) &#123; int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1)&#123; int i = nums.length -2; while (i &gt;= 0)&#123; if (nums[i + 1] &lt;= nums[i]) &#123; //从尾部开始，比较元素是否是大到小 i--; continue; &#125; else &#123; //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--)&#123; if (nums[j] &lt;= nums[i])&#123; continue; &#125; int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; &#125; break; &#125; &#125; if (flag == 0 )&#123; //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"}]},{"title":"88. Merge Sorted Array","slug":"88-Merge-Sorted-Array","date":"2022-04-03T15:26:40.000Z","updated":"2022-04-05T05:58:48.410Z","comments":true,"path":"2022/04/03/88-Merge-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/88-Merge-Sorted-Array/","excerpt":"","text":"问题描述You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) &#123; if ( nums1[i] &lt; nums2[j] )&#123; nums1[k] = nums2[j]; j--; k--; &#125; else &#123; nums1[k] = nums1[i]; i--; k--; &#125; &#125; if ( i &lt; 0 )&#123; while ( j &gt;= 0 )&#123; nums1[k] = nums2[j]; j--; k--; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"}]},{"title":"1. Two Sum","slug":"1-Two-Sum","date":"2022-04-03T14:35:42.000Z","updated":"2022-04-05T05:58:46.865Z","comments":true,"path":"2022/04/03/1-Two-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/1-Two-Sum/","excerpt":"","text":"问题描述Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int result = target - nums[i]; if ( map.containsKey(result) )&#123; ans[0] = map.get(result); ans[1] = i; return ans; &#125; else&#123; map.put(nums[i], i); &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2022-04-03T13:54:39.000Z","updated":"2022-04-05T05:58:57.511Z","comments":true,"path":"2022/04/03/189-Rotate-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/189-Rotate-Array/","excerpt":"","text":"问题描述Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution &#123; public void rotate(int[] nums, int k) &#123; if (k != 0)&#123; int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) &#123; int i = n + k; i %= nums.length; int temp = nums[n]; while( true )&#123; int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n)&#123; nums[n] = temp; break; &#125; &#125; &#125; &#125; &#125; private int gcd(int a, int b)&#123; int max = a; int min = b; if (max == min)&#123; return min; &#125; if ( a &lt; b )&#123; max = b; min = a; &#125; return gcd(max - min, min); &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"977. Squares of a Sorted Array","slug":"977-Squares-of-a-Sorted-Array","date":"2022-04-03T13:35:19.000Z","updated":"2022-04-05T05:59:10.780Z","comments":true,"path":"2022/04/03/977-Squares-of-a-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/977-Squares-of-a-Sorted-Array/","excerpt":"","text":"问题描述Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) &#123; if ( nums[left] &lt; 0 )&#123; if ( (-nums[left]) &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else &#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; else&#123; if ( nums[left] &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else&#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"测试一下","slug":"测试一下","date":"2022-03-30T14:26:17.000Z","updated":"2022-03-30T14:26:17.799Z","comments":true,"path":"2022/03/30/测试一下/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/","excerpt":"","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","categories":[],"tags":[]},{"title":"post title","slug":"post-title","date":"2022-03-30T12:22:27.000Z","updated":"2022-03-30T12:24:40.285Z","comments":true,"path":"2022/03/30/post-title/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/post-title/","excerpt":"","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-30T12:02:37.831Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/03/30/hello-world/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"复习","slug":"LeetCode/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"算法","slug":"算法","permalink":"https://xuanhe95.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"投票算法","slug":"投票算法","permalink":"https://xuanhe95.github.io/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"https://xuanhe95.github.io/tags/Queue/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"}]}