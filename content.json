{"meta":{"title":"XANDER Studio","subtitle":"Xander Studio","description":"Stay Foolish, Stay Hungery...","author":"Xuanhe","url":"https://xuanhe95.github.io","root":"/"},"pages":[],"posts":[{"title":"1091. Shortest Path in Binary Matrix","slug":"1091-Shortest-Path-in-Binary-Matrix","date":"2022-04-22T16:18:58.000Z","updated":"2022-04-22T16:18:58.096Z","comments":true,"path":"2022/04/23/1091-Shortest-Path-in-Binary-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/23/1091-Shortest-Path-in-Binary-Matrix/","excerpt":"","text":"Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0.All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).The length of a clear path is the number of visited cells of this path. 由于不能重复搜索，且需要在搜索时将搜索过的位置改变，因此需要采用BFS逐一层级的搜索。逐层级搜索并记录层级。最后返回层级+1即可。（还有更快的优化算法A*） 整体没有改变太多，基本还是方法二那种。启发式函数改为切比雪夫距离距离。距离计算方法有很多，常用启发式函数有这几种。选择合适的启发式函数有利于速度的提升。这题可以用好几种启发式函数，初学都可以试着都写一下。 曼哈顿距离（Manhattan Distance）一般只能在四个方向上移动时用（右、左、上、下） 对角线距离（Diagonal Distance）：当我们只允许向八个方向移动时用（国际象棋中的王移动方式那种） 欧几里得距离（Euclidean Distance）：不受限制，允许向任何方向移动时。 切比雪夫距离（Chebyshev Distance）：可参考：[https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/](LeetCode 1266) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int shortestPathBinaryMatrix(int[][] grid) &#123; int n = grid[0].length; int m = grid.length; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int count = 0; q.add(0); int size = q.size(); while(!q.isEmpty())&#123; for(int k = 0; k &lt; size; k++)&#123; int curr = q.poll(); int i = curr / n; int j = curr % n; if(grid[i][j] ==1) continue; if(i == m-1 &amp;&amp; j == n-1 &amp;&amp; grid[i][j] == 0) return count+1; if(grid[i][j] == 0)&#123; grid[i][j] = 1; if(i+1&lt;n &amp;&amp; j+1&lt;n) q.add((i+1) * n + (j+1)); if(i+1&lt;n &amp;&amp; j-1&gt;=0) q.add((i+1) * n + (j-1)); if(i+1&lt;n) q.add((i+1) * n + j); if(i-1&gt;=0 &amp;&amp; j-1&gt;=0) q.add((i-1) * n + (j-1)); if(i-1&gt;=0 &amp;&amp; j+1&lt;n) q.add((i-1) * n + (j+1)); if(j+1&lt;n) q.add(i * n + (j+1)); if(j-1&gt;=0) q.add(i * n + (j-1)); if(i-1&gt;=0) q.add((i-1) * n + j); &#125; &#125; size = q.size(); count++; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"},{"name":"其他解法？","slug":"其他解法？","permalink":"https://xuanhe95.github.io/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"}]},{"title":"572. Subtree of Another Tree","slug":"572-Subtree-of-Another-Tree","date":"2022-04-21T17:23:40.000Z","updated":"2022-04-21T17:23:40.358Z","comments":true,"path":"2022/04/22/572-Subtree-of-Another-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/22/572-Subtree-of-Another-Tree/","excerpt":"","text":"Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself. 帮助方法isEqual，DFS搜索判断两个节点的子节点是否完全相同。DFS搜索，如果两个根节点的值相等则返回，且调用isEqual方法，如果子节点都相同则返回。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isSubtree(TreeNode root, TreeNode subRoot) &#123; return dfs(root, subRoot) != null; &#125; private TreeNode dfs(TreeNode root, TreeNode subRoot)&#123; if(root == null) return null; if(root.val == subRoot.val &amp;&amp; isEqual(root, subRoot)) return root; if(dfs(root.left, subRoot) != null ) return dfs(root.left, subRoot); else return dfs(root.right, subRoot); &#125; private boolean isEqual(TreeNode root, TreeNode subRoot)&#123; if(root == null || subRoot == null) return root == subRoot; if(root.val != subRoot.val) return false; return isEqual(root.left, subRoot.left) &amp;&amp; isEqual(root.right, subRoot.right); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"}]},{"title":"117. Populating Next Pointers in Each Node II","slug":"117-Populating-Next-Pointers-in-Each-Node-II","date":"2022-04-21T10:54:00.000Z","updated":"2022-04-21T10:54:00.419Z","comments":true,"path":"2022/04/21/117-Populating-Next-Pointers-in-Each-Node-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/117-Populating-Next-Pointers-in-Each-Node-II/","excerpt":"","text":"Given a binary tree 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 struct Node &#123; int val; Node *left; Node *right; Node *next;&#125;```javaPopulate each next pointer to point to its next right node. If &gt; there is no next right node, the next pointer should be set to NULL.Initially, all next pointers are set to NULL.BFS搜索，从右至左将每层节点放入队列。用一个size记录该层级放入节点的数量，每次循环将size-1，当size归零时放入新一层级的节点。```java/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if(root == null) return root; Queue&lt;Node&gt; q = new LinkedList(); q.add(root); while(!q.isEmpty())&#123; int size = q.size(); Node next = null; while(size &gt; 0)&#123; size--; Node curr = q.poll(); curr.next = next; next = curr; if(curr.right != null) q.add(curr.right); if(curr.left != null) q.add(curr.left); &#125; &#125; return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"763. Partition Labels","slug":"763-Partition-Labels","date":"2022-04-21T10:24:54.000Z","updated":"2022-04-21T10:30:51.770Z","comments":true,"path":"2022/04/21/763-Partition-Labels/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/763-Partition-Labels/","excerpt":"","text":"You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts. 将英文字母出现的首尾作为intervals看待。根据字符创建数组并填入左右的index。根据左侧index排序数组。 从左至右，如果intervals有交集，则合并。否则在答案中添加当前interval的长度。 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; partitionLabels(String s) &#123; int[][] alphabet = new int[26][2]; int head = s.charAt(0) - &#x27;a&#x27;; for(int i = 0; i &lt; s.length(); i++)&#123; int index = s.charAt(i) - &#x27;a&#x27;; if(head != index &amp;&amp; alphabet[index][0] == 0) alphabet[index][0] = i; alphabet[index][1] = i; &#125; Arrays.sort(alphabet, (a,b) -&gt; a[0] - b[0]); List&lt;Integer&gt; ans = new ArrayList(); int[] hold = alphabet[0]; for(int i = 1; i &lt; alphabet.length; i++)&#123; if(alphabet[i][0] &lt;= hold[1])&#123; hold[1] = Math.max(hold[1], alphabet[i][1]); &#125; else&#123; ans.add(hold[1]-hold[0]+1); hold = alphabet[i]; &#125; &#125; ans.add(hold[1]-hold[0]+1); return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"Sort","slug":"Sort","permalink":"https://xuanhe95.github.io/tags/Sort/"},{"name":"intervals","slug":"intervals","permalink":"https://xuanhe95.github.io/tags/intervals/"}]},{"title":"290. Word Pattern","slug":"290-Word-Pattern","date":"2022-04-21T09:02:07.000Z","updated":"2022-04-21T09:02:07.613Z","comments":true,"path":"2022/04/21/290-Word-Pattern/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/290-Word-Pattern/","excerpt":"","text":"Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. 先将s分割成数组。如果words的长度和pattern的长度不同则返回false。用长度为26的数组储存pattern的字符。同时遍历words和pattern，将pattern的字符换算成数字作为index，将words[i]填入数组。如果数组中已经有word存在，则检查新的word和数组内的word是否相等。如果不相等，则返回false。 最后遍历数组，比对各个字符中对应的word是否相等，如果有相等的，则返回false。由于数组长度固定，因此这个操作的时间复杂度是O(1)。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public boolean wordPattern(String pattern, String s) &#123; String[] words = s.split(&quot; &quot;); String[] alphabet = new String[26]; if(words.length != pattern.length())&#123; return false; &#125; for(int i = 0; i &lt; pattern.length(); i++)&#123; if( alphabet[pattern.charAt(i) - &#x27;a&#x27;] != null)&#123; if(!alphabet[pattern.charAt(i) - &#x27;a&#x27;].equals(words[i]))&#123; return false; &#125; &#125; else&#123; alphabet[pattern.charAt(i) - &#x27;a&#x27;] = words[i]; &#125; &#125; for(int i = 0; i &lt; alphabet.length; i++)&#123; for(int j = i+1; j &lt; alphabet.length; j++)&#123; if(alphabet[i] == null || alphabet[j] == null)&#123; continue; &#125; if(alphabet[i].equals(alphabet[j]))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"其他解法？","slug":"其他解法？","permalink":"https://xuanhe95.github.io/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"}]},{"title":"415. Add Strings","slug":"415-Add-Strings","date":"2022-04-21T06:19:01.000Z","updated":"2022-04-21T06:19:01.368Z","comments":true,"path":"2022/04/21/415-Add-Strings/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/415-Add-Strings/","excerpt":"","text":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. 按照正常加法计算方法即可。先将指针设置在两个String的末尾。每次计算位置上加和的结果。最后需要将字符串翻转过来。 1234567891011121314151617181920212223class Solution &#123; public String addStrings(String num1, String num2) &#123; int i = num1.length() - 1; int j = num2.length() - 1; int carry = 0; StringBuffer ans = new StringBuffer(); while( i &gt;= 0 || j &gt;= 0 || carry &gt; 0)&#123; int x = i &gt;= 0 ? num1.charAt(i) - &#x27;0&#x27; : 0; int y = j &gt;= 0 ? num2.charAt(j) - &#x27;0&#x27; : 0; int result = x + y + carry; ans.append(result % 10); carry = result / 10; i--; j--; &#125; ans.reverse(); return ans.toString(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"409. Longest Palindrome","slug":"409-Longest-Palindrome","date":"2022-04-21T05:37:55.000Z","updated":"2022-04-21T05:37:55.259Z","comments":true,"path":"2022/04/21/409-Longest-Palindrome/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/409-Longest-Palindrome/","excerpt":"","text":"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, “Aa” is not considered a palindrome here. 1234567891011121314151617181920212223class Solution &#123; public int longestPalindrome(String s) &#123; int[] alphabet = new int[&#x27;z&#x27; - &#x27;A&#x27; + 1]; int count = 0; int total = s.length(); for(int i = 0; i &lt; s.length(); i++)&#123; int index = s.charAt(i) - &#x27;A&#x27;; alphabet[index]+=1; if( alphabet[index] == 2 )&#123; total -= 2; count += 2; alphabet[index] = 0; &#125; &#125; if(total != 0)&#123; count++; &#125; return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"547. Number of Provinces","slug":"547-Number-of-Provinces","date":"2022-04-21T04:55:21.000Z","updated":"2022-04-21T04:55:21.275Z","comments":true,"path":"2022/04/21/547-Number-of-Provinces/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/547-Number-of-Provinces/","excerpt":"","text":"There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] &#x3D; 1 if the ith city and the jth city are directly connected, and isConnected[i][j] &#x3D; 0 otherwise. Return the total number of provinces. DFS搜索，当map[i][i] &#x3D; 1时加入搜索。搜索时将map[i][i]设为0。遍历并递归其数列。当map[i][i]等于0时，返回。 123456789101112131415161718192021222324252627class Solution &#123; int[][] map; public int findCircleNum(int[][] isConnected) &#123; map = isConnected; int count = 0; for(int i = 0; i &lt; isConnected.length; i++)&#123; if(map[i][i] == 1)&#123; count++; dfs(i); &#125; &#125; return count; &#125; private void dfs(int i)&#123; if(map[i][i] == 0)&#123; return; &#125; map[i][i] = 0; for(int j = 0; j &lt; map[0].length; j++)&#123; if(map[i][j] == 1)&#123; dfs(j); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"200. Number of Islands","slug":"200-Number-of-Islands","date":"2022-04-21T03:49:37.000Z","updated":"2022-04-21T03:49:37.157Z","comments":true,"path":"2022/04/21/200-Number-of-Islands/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/200-Number-of-Islands/","excerpt":"","text":"Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 遍历所有点，如果等于1则对其进行DFS搜索。在搜索的同时将1设为0。如果等于0则递归返回。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; char[][] area; public int numIslands(char[][] grid) &#123; area = grid; int count = 0; for(int i = 0; i &lt; area.length; i++)&#123; for(int j = 0; j &lt; area[0].length; j++)&#123; if(area[i][j] == &#x27;1&#x27;)&#123; dfs(i, j); count++; &#125; &#125; &#125; return count; &#125; private void dfs(int i, int j)&#123; if(area[i][j] == &#x27;0&#x27;)&#123; return; &#125; area[i][j] = &#x27;0&#x27;; if( i+1 &lt; area.length )&#123; dfs(i+1, j); &#125; if( i-1 &gt;= 0 )&#123; dfs(i-1, j); &#125; if( j+1 &lt; area[0].length )&#123; dfs(i, j+1); &#125; if( j-1 &gt;= 0 )&#123; dfs(i, j-1); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"705. Design HashSet","slug":"705-Design-HashSet","date":"2022-04-21T02:11:43.000Z","updated":"2022-04-21T02:11:43.232Z","comments":true,"path":"2022/04/21/705-Design-HashSet/","link":"","permalink":"https://xuanhe95.github.io/2022/04/21/705-Design-HashSet/","excerpt":"","text":"Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. 计算哈希值，使用数组实现Hash Set。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyHashSet &#123; int PRIME = 1009; List&lt;Integer&gt;[] data; public MyHashSet() &#123; data = new List[PRIME]; for(int i = 0; i &lt; PRIME; i++)&#123; data[i] = new LinkedList&lt;Integer&gt;(); &#125; &#125; public void add(int key) &#123; if(!contains(key))&#123; int h = getHash(key); data[h].add(key); &#125; &#125; public void remove(int key) &#123; int h = getHash(key); data[h].remove(new Integer(key)); &#125; public boolean contains(int key) &#123; int h = getHash(key); for( int num : data[h] )&#123; if( num == key )&#123; return true; &#125; &#125; return false; &#125; private int getHash(int o)&#123; return o % PRIME; &#125;&#125;/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */","categories":[{"name":"Medium","slug":"Medium","permalink":"https://xuanhe95.github.io/categories/Medium/"},{"name":"Easy","slug":"Medium/Easy","permalink":"https://xuanhe95.github.io/categories/Medium/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Hash","slug":"Hash","permalink":"https://xuanhe95.github.io/tags/Hash/"}]},{"title":"713. Subarray Product Less Than K","slug":"713-Subarray-Product-Less-Than-K","date":"2022-04-20T15:08:59.000Z","updated":"2022-04-20T15:08:59.533Z","comments":true,"path":"2022/04/20/713-Subarray-Product-Less-Than-K/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/713-Subarray-Product-Less-Than-K/","excerpt":"","text":"Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. 滑动窗口，维护一个窗口内的乘积。当乘积小于目标值时，窗口右侧向右移动。每加入一个新数值，可以增加(j-i+1)个组合。当乘积大于目标时，窗口左侧向右移动。 123456789101112131415161718192021class Solution &#123; public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int i = 0; int j = 0; int product = nums[0]; int count = 0; while(i &lt; nums.length &amp;&amp; j &lt; nums.length)&#123; if(product &lt; k)&#123; count += (j - i) + 1; j++; if(j &lt; nums.length ) product *= nums[j]; &#125; else&#123; product /= nums[i]; i++; &#125; &#125; return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://xuanhe95.github.io/tags/Sliding-Window/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"209. Minimum Size Subarray Sum","slug":"209-Minimum-Size-Subarray-Sum","date":"2022-04-20T12:58:16.000Z","updated":"2022-04-20T13:22:52.961Z","comments":true,"path":"2022/04/20/209-Minimum-Size-Subarray-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/209-Minimum-Size-Subarray-Sum/","excerpt":"","text":"Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, …, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 滑动窗口，先取最左侧数字。记录窗口的最小值。如果小于目标值，则右侧窗口向右移动，扩大窗口。更新窗口内的值。如果大于等于目标值，则左侧窗口向右移动，缩小窗口。更新窗口内的值。同时如果窗口大小小于最小值则更新窗口最小值。 1234567891011121314151617181920class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int min = Integer.MAX_VALUE; int left = 0; int right = 0; int sum = nums[0]; while(right &lt; nums.length)&#123; if(sum &gt;= target)&#123; min = Math.min(min, right - left + 1); sum -= nums[left]; left++; &#125; else&#123; right++; if(right &lt; nums.length) sum += nums[right]; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; 计算前缀和。前缀和[j]与前缀和的[i]的差就是i+1到j的和。因此需要找到sum[j] - sum[i] &gt;&#x3D; k。暴力枚举的话需要O(n^2^)的时间复杂度。 由于前缀和是有序的，因此我们可以采用二分搜索。寻找sum[j] - k &gt;&#x3D; sum[i]。Arrays.binarySearch方法可以返回查找到的目录。如果没有该值，方法会返回一个负数，其取反（x取反相当于[-(x+1)]）的值就是应该插入的目录。将ans设置为无限大，如果(index - i)小于最小值则更新到ans。 时间复杂度O(nlogn)。 123456789101112131415161718192021class Solution &#123; public int minSubArrayLen(int target, int[] nums) &#123; int[] sum = new int[nums.length+1]; for(int i = 1; i &lt;= nums.length; i++)&#123; sum[i] = sum[i-1] + nums[i-1]; &#125; int ans = Integer.MAX_VALUE; for(int i = 0; i &lt; sum.length; i++)&#123; int search = sum[i] + target; int index = Arrays.binarySearch(sum, search); if(index &lt; 0)&#123; index = ~index; &#125; if(index &lt; sum.length)&#123; ans = Math.min(ans, index - i); &#125; &#125; return ans == Integer.MAX_VALUE ? 0 : ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://xuanhe95.github.io/tags/Sliding-Window/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"560. Subarray Sum Equals K","slug":"560-Subarray-Sum-Equals-K","date":"2022-04-20T11:27:12.000Z","updated":"2022-04-20T11:54:32.490Z","comments":true,"path":"2022/04/20/560-Subarray-Sum-Equals-K/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/560-Subarray-Sum-Equals-K/","excerpt":"","text":"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. 对于数组中每个数字，计算其前缀的和。前缀[i]减去前缀[j]的差，等于[j]-[i]之间数字的和。（类似一种DP，数组可以用一个变量代替。） 因此，原题目等于寻找找 前缀[i]-前缀[j] &#x3D; k。用哈希表储存已经遍历过的前缀和出现的次数。每次遍历时先查看哈希表内是否有当前[前缀和-k]的键在。如果有则加入到count中。（哈希表中需要提前放入一个0键，值等于1，为了计算[前缀和-k]等于0的情况。） 1234567891011121314151617class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int[] sum = new int[nums.length + 1]; HashMap&lt;Integer, Integer&gt; map = new HashMap(); int count = 0; map.put(0, 1); for(int i = 1; i &lt;= nums.length; i++)&#123; sum[i] = sum[i-1] + nums[i-1]; count += map.getOrDefault(sum[i]-k, 0); map.put(sum[i], map.getOrDefault(sum[i], 0) + 1); &#125; return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"238. Product of Array Except Self","slug":"238-Product-of-Array-Except-Self","date":"2022-04-20T08:44:45.000Z","updated":"2022-04-20T11:27:23.434Z","comments":true,"path":"2022/04/20/238-Product-of-Array-Except-Self/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/238-Product-of-Array-Except-Self/","excerpt":"","text":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. 当前数字之外的积等于左边所有数字的积乘以右边所有数字的积。因此可以维护两个数组，分别计算从左到右的乘积，和从右到左的乘积。 由于返回答案不算占用空间，因此可以将左侧乘积的数组保存在答案数组上。然后在遍历时，从右至左遍历，使用一个变量储存右边的乘积，直接将两者的乘积更新在答案数组上。此时空间复杂度为O(1)。 123456789101112131415161718class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] ans = new int[nums.length]; ans[0] = 1; for(int i = 1; i &lt; nums.length; i++)&#123; ans[i] = ans[i-1] * nums[i-1]; &#125; int rightProduct = 1; for(int j = nums.length-1; j &gt;=0; j--)&#123; ans[j] = ans[j] * rightProduct; rightProduct *= nums[j]; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"438. Find All Anagrams in a String","slug":"438-Find-All-Anagrams-in-a-String","date":"2022-04-20T08:11:36.000Z","updated":"2022-04-20T08:11:36.859Z","comments":true,"path":"2022/04/20/438-Find-All-Anagrams-in-a-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/438-Find-All-Anagrams-in-a-String/","excerpt":"","text":"Given two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 滑动窗口。采用两个数组分别计算两个字符串中字符出现的数量。 滑动窗口时，维护数组中字符串中字符出现的次数。循环，判断两个字符串是否相等，如果相等，则将当前的左指针添加进答案。移动窗口的左右指针，在数组中减少前一项出现的次数，增加后一项出现的次数。 通过维护一个表示两个字符串中字符差值的数组，可以将算法优化算法，而不必进行两个数组的比较。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; ans = new ArrayList(); if(p.length()&gt;s.length())&#123; return ans; &#125; int[] alphabet = new int[26]; int[] window = new int[26]; for(int i = 0; i &lt; p.length(); i++)&#123; alphabet[p.charAt(i) - &#x27;a&#x27;]++; window[s.charAt(i) - &#x27;a&#x27;]++; &#125; int i = 0; int j = p.length(); while(j &lt; s.length())&#123; if(Arrays.equals(alphabet, window))&#123; ans.add(i); &#125; window[s.charAt(i) - &#x27;a&#x27;]--; window[s.charAt(j) - &#x27;a&#x27;]++; i++; j++; &#125; if(Arrays.equals(alphabet, window))&#123; ans.add(i); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://xuanhe95.github.io/tags/Sliding-Window/"}]},{"title":"334. Increasing Triplet Subsequence","slug":"334-Increasing-Triplet-Subsequence","date":"2022-04-20T05:35:04.000Z","updated":"2022-04-20T11:27:50.839Z","comments":true,"path":"2022/04/20/334-Increasing-Triplet-Subsequence/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/334-Increasing-Triplet-Subsequence/","excerpt":"","text":"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false. 贪心算法。将first与second初始化为最大值。first保存遍历过的最小值。second保存遍历过的大于之前最小值的最小值。 遍历数组。条件一：如果数字小于现在第一个值，则更新第一个值。（此时一定不满足条件二，因此可以安全地更新更小的数字。）条件二：如果数字大于第一个值，且小于第二个值，则更新第二个值。（此时第一个值已经被更新过了，满足第一个值小于第二个值。）条件三：如果数字大于第二个值，则返回true。（此时两个值一定都被更新过了，满足第一个值小于第二个值小于第三个值。） 注意：更新first后，second不会更新，但是second的存在可以确保曾经存在first小于second。如果此时数字大于second，则数组中存在Triplet Subsequence。 12345678910111213141516171819class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; int first = Integer.MAX_VALUE; int second = Integer.MAX_VALUE; for(int num : nums)&#123; if(num &lt; first)&#123; first = num; &#125; else if(num &gt; first &amp;&amp; num &lt; second)&#123; second = num; &#125; else if(num &gt; second)&#123; return true; &#125; &#125; return false; &#125;&#125; 双向遍历，逐渐收紧搜索窗口。设置i，k两个指针分别在头尾。当nums[j] &lt;&#x3D; nums[i]，则更新i指针为j。当nums[j] &gt;&#x3D; nums[k]，则更新k指针为j。如果找到符合条件的nums[i] &lt; nums[j] &lt; nums[k]则返回。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; boolean flag = true; int i = 0; int k = nums.length -1 ; int j; int count = 1; while(i &lt; k &amp;&amp; i + count &lt; k)&#123; if(flag)&#123; j = i + count; if(nums[i] &gt;= nums[j])&#123; i = j; count = 1; flag = true; continue; &#125; else if(nums[j] &lt; nums[k])&#123; return true; &#125; flag = !flag; &#125; else&#123; j = k - count; if(nums[k] &lt;= nums[j])&#123; k = j; count = 1; flag = true; continue; &#125; else if(nums[j] &gt; nums[i])&#123; return true; &#125; else&#123; count++; &#125; flag = !flag; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"双向遍历","slug":"双向遍历","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"173. Binary Search Tree Iterator","slug":"173-Binary-Search-Tree-Iterator","date":"2022-04-20T03:56:38.000Z","updated":"2022-04-20T03:56:39.066Z","comments":true,"path":"2022/04/20/173-Binary-Search-Tree-Iterator/","link":"","permalink":"https://xuanhe95.github.io/2022/04/20/173-Binary-Search-Tree-Iterator/","excerpt":"","text":"Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.int next() Moves the pointer to the right, then returns the number at the pointer.Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. 此方法不用将所有节点一次性入栈，而是在获得next时更新栈内的节点，因此更省时间。将根节点的所有左子节点入栈，此时栈顶为最小值。next方法：返回当前的栈顶节点。如果栈顶节点存在右子节点，则将其所有的左子节点入栈。hasNext方法：返回栈是否为空的非值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class BSTIterator &#123; Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) &#123; stack = new Stack(); updateStack(root); &#125; public int next() &#123; TreeNode node = stack.pop(); updateStack(node.right); return node.val; &#125; public boolean hasNext() &#123; return !stack.isEmpty(); &#125; private void updateStack(TreeNode root)&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; &#125;&#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ DFS搜索，中序搜索，从右子节点至左子节点，先将所有元素入栈。next方法：挤出栈顶并返回。hasNext方法： 返回栈是否为空的非值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class BSTIterator &#123; Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) &#123; stack = new Stack(); initiateStack(root); &#125; public int next() &#123; return stack.pop().val; &#125; public boolean hasNext() &#123; return !stack.isEmpty(); &#125; private void initiateStack(TreeNode root)&#123; if(root == null)&#123; return; &#125; initiateStack(root.right); stack.push(root); initiateStack(root.left); &#125;&#125;/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"986. Interval List Intersections","slug":"986-Interval-List-Intersections","date":"2022-04-19T08:07:06.000Z","updated":"2022-04-19T08:07:06.724Z","comments":true,"path":"2022/04/19/986-Interval-List-Intersections/","link":"","permalink":"https://xuanhe95.github.io/2022/04/19/986-Interval-List-Intersections/","excerpt":"","text":"You are given two lists of closed intervals, firstList and secondList, where firstList[i] &#x3D; [starti, endi] and secondList[j] &#x3D; [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;&#x3D; b) denotes the set of real numbers x with a &lt;&#x3D; x &lt;&#x3D; b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3]. 设置两个指针，分别指向两个intervals的头部。循环，相交的left等于两者左端的较大值。right等于两者右端的较小值。只有在left小于right时，两个interval才相交，填入列表。然后更新两个interval中右端较小的指针。 12345678910111213141516171819202122class Solution &#123; public int[][] intervalIntersection(int[][] firstList, int[][] secondList) &#123; List&lt;int[]&gt; ans = new ArrayList(); int i = 0; int j = 0; while(i &lt; firstList.length &amp;&amp; j &lt; secondList.length)&#123; int left = Math.max( firstList[i][0], secondList[j][0] ); int right = Math.min( firstList[i][1], secondList[j][1] ); if(left &lt;= right)&#123; ans.add(new int[]&#123;left, right&#125;); &#125; if(firstList[i][1] &lt; secondList[j][1]) i++; else j++; &#125; int[][] ret = new int[ans.size()][2]; ans.toArray(ret); return ret; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public int[][] intervalIntersection(int[][] firstList, int[][] secondList) &#123; int i = 0; int j = 0; ArrayList&lt;int[]&gt; ans = new ArrayList(); int[] holdA; int[] holdB; while(i &lt; firstList.length &amp;&amp; j &lt; secondList.length)&#123; holdA = firstList[i]; holdB = secondList[j]; int[] arr = new int[2]; if(holdA[0] &lt;= holdB[0] &amp;&amp; holdA[1] &gt;= holdB[1])&#123; ans.add(holdB); j++; &#125; else if(holdA[0] &gt;= holdB[0] &amp;&amp; holdA[1] &lt;= holdB[1])&#123; ans.add(holdA); i++; &#125; else if(holdA[0] &lt;= holdB[0] &amp;&amp; holdA[1] &gt;= holdB[0])&#123; arr[0] = holdB[0]; arr[1] = holdA[1]; ans.add(arr); i++; &#125; else if(holdA[0] &gt;= holdB[0] &amp;&amp; holdB[1] &gt;= holdA[0])&#123; arr[0] = holdA[0]; arr[1] = holdB[1]; ans.add(arr); j++; &#125; else if(holdA[1] &lt;= holdB[1])&#123; i++; &#125; else&#123; j++; &#125; &#125; int[][] ret = new int[ans.size()][2]; ans.toArray(ret); return ret; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"intervals","slug":"intervals","permalink":"https://xuanhe95.github.io/tags/intervals/"}]},{"title":"844. Backspace String Compare","slug":"844-Backspace-String-Compare","date":"2022-04-19T05:56:49.000Z","updated":"2022-04-19T05:56:49.840Z","comments":true,"path":"2022/04/19/844-Backspace-String-Compare/","link":"","permalink":"https://xuanhe95.github.io/2022/04/19/844-Backspace-String-Compare/","excerpt":"","text":"辅助方法getNextValid，返回下一个有效值。将两个指针分别设置在两个字符串的尾部。当两指针有一个大于0时，进行循环。每次都搜索两个指针的下一个有效值。如果两个指针上的字符不同则返回false。 最后返回两个指针的停留位置是否相同。 注意：如果有一个字符串指针先更新到0以下，另一个指针仍有可能更新到一个“#”字符位置。此时最后的结应该是两个空字符串。因此需要继续循环一次，得出其是否会归到零以下。如果此时归零则两者的指针位置仍然相等。 因此即使getNextValid返回的下一个值为负数也应该保留其数值。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean backspaceCompare(String s, String t) &#123; int i = s.length()-1; int j = t.length()-1; while(i &gt;= 0 || j &gt;= 0)&#123; i = getNextValid(s, i); j = getNextValid(t, j); if( i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; s.charAt(i) != t.charAt(j))&#123; return false; &#125; i--; j--; &#125; return (i == j); &#125; private int getNextValid(String s, int start)&#123; int i = start; int count = 0; while(i &gt;= 0 &amp;&amp; (s.charAt(i) == &#x27;#&#x27; || count != 0))&#123; if(s.charAt(i) == &#x27;#&#x27;)&#123; count++; &#125; else&#123; count--; &#125; i--; &#125; return i; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"435. Non-overlapping Intervals","slug":"435-Non-overlapping-Intervals","date":"2022-04-19T04:28:33.000Z","updated":"2022-04-19T07:13:09.060Z","comments":true,"path":"2022/04/19/435-Non-overlapping-Intervals/","link":"","permalink":"https://xuanhe95.github.io/2022/04/19/435-Non-overlapping-Intervals/","excerpt":"","text":"Given an array of intervals intervals where intervals[i] &#x3D; [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. 首先对intervals按照后一项的大小进行排序。（直接将两数字相减作为比较值比Integer.compare方法更快。）贪心算法，将已取得的最大值max设置为最小整数值。遍历intervals，如果当前interval的左侧小于max，则不能选择该interval，计数加一。反之则可以选择interval，更新max的值为interval的最大值。返回总数。 12345678910111213141516class Solution &#123; public int eraseOverlapIntervals(int[][] intervals) &#123; Arrays.sort(intervals, (a,b) -&gt; a[1] - b[1]); int max = Integer.MIN_VALUE; int count = 0; for(int[] interval : intervals)&#123; if(interval[0] &lt; max)&#123; count++; &#125; else&#123; max = interval[1]; &#125; &#125; return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"},{"name":"Sort","slug":"Sort","permalink":"https://xuanhe95.github.io/tags/Sort/"},{"name":"intervals","slug":"intervals","permalink":"https://xuanhe95.github.io/tags/intervals/"}]},{"title":"99. Recover Binary Search Tree","slug":"99-Recover-Binary-Search-Tree","date":"2022-04-19T04:06:02.000Z","updated":"2022-04-19T04:06:02.456Z","comments":true,"path":"2022/04/19/99-Recover-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/19/99-Recover-Binary-Search-Tree/","excerpt":"","text":"You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. DFS中序搜索，额外记录访问的前一个节点。如果当前节点与前一个节点的顺序不对，则暂且认为先后两个节点的位置均不正确。（前一个大于后一个的值，由于是第一个不满足递增条件的位置，因此前一个的位置一定是错误的。但此时当前值不一定是错误的。）继续递归，如果发现新的节点位置不正确，则后一个节点位置正确，更新当前节点为不正确的节点。（由于是第二个不满足递增条件的位置，因此当前值是错误的。）交换两个位置不正确的节点的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; TreeNode prev; boolean flag; TreeNode[] wrong; public void recoverTree(TreeNode root) &#123; wrong = new TreeNode[2]; prev = new TreeNode(Integer.MIN_VALUE); flag = true; dfs(root); int swap = wrong[0].val; wrong[0].val = wrong[1].val; wrong[1].val = swap; &#125; private void dfs(TreeNode root)&#123; if(root == null)&#123; return; &#125; dfs(root.left); if(prev.val &gt; root.val)&#123; if(flag)&#123; wrong[0] = prev; flag = false; &#125; wrong[1] = root; &#125; prev = root; dfs(root.right); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"240. Search a 2D Matrix II","slug":"240-Search-a-2D-Matrix-II","date":"2022-04-19T02:47:23.000Z","updated":"2022-04-19T02:47:23.693Z","comments":true,"path":"2022/04/19/240-Search-a-2D-Matrix-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/19/240-Search-a-2D-Matrix-II/","excerpt":"","text":"Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. 将起始点设置为第一行的最后一列。如果搜寻目标大于该点则向下搜索。如果搜寻目标小于该点则向左搜索。 12345678910111213141516171819class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0; int j = matrix[0].length - 1; while(i &lt; matrix.length &amp;&amp; j &gt;= 0)&#123; if(matrix[i][j] == target)&#123; return true; &#125; else if(matrix[i][j] &lt; target)&#123; i++; &#125; else&#123; j--; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"230. Kth Smallest Element in a BST","slug":"230-Kth-Smallest-Element-in-a-BST","date":"2022-04-18T13:06:19.000Z","updated":"2022-04-18T13:06:19.956Z","comments":true,"path":"2022/04/18/230-Kth-Smallest-Element-in-a-BST/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/230-Kth-Smallest-Element-in-a-BST/","excerpt":"","text":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. DFS搜索，遍历的时候更新全局变量count。采用中序搜索，当count等于k时，将全局变量ans设置为root.val。搜索完毕返回ans。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; int ans; int count; public int kthSmallest(TreeNode root, int k) &#123; ans = -1; count = 0; dfs(root,k); return ans; &#125; private void dfs(TreeNode root, int k)&#123; if(root == null)&#123; return; &#125; dfs(root.left,k); count++; if (k == count)&#123; ans = root.val; &#125; dfs(root.right,k); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"48. Rotate Image","slug":"48-Rotate-Image","date":"2022-04-18T12:47:44.000Z","updated":"2022-04-19T01:25:55.962Z","comments":true,"path":"2022/04/18/48-Rotate-Image/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/48-Rotate-Image/","excerpt":"","text":"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. 辅助方法getPixel计算旋转后的像素位置。旋转时候矩阵内的四个分区的像素会互相替换。因此需要将需要旋转的初始位置记录进入队列。旋转图像时根据getPixel方法计算出需要替换的位置。然后依次替换像素。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; Queue&lt;Integer&gt; queue = new LinkedList(); for (int p = 0; p &lt; n/2; p++)&#123; for(int q = 0; q &lt; (n+1)/2; q++)&#123; queue.offer(p * n + q); &#125; &#125; while(!queue.isEmpty())&#123; int i = queue.poll(); int INDEX = i; boolean flag = true; int temp = matrix[i/n][i%n]; while(i != INDEX || flag )&#123; flag = false; int j = getPixel(n, i); int swap = matrix[j / n][j % n]; matrix[j / n][j % n] = temp; temp = swap; i = j; &#125; &#125; &#125; private int getPixel(int n, int o)&#123; int row = o / n; int col = o % n; int newRow = col; int newCol = n - (row + 1); return (newRow * n) + newCol; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"},{"name":"其他解法？","slug":"其他解法？","permalink":"https://xuanhe95.github.io/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"}]},{"title":"119. Pascal's Triangle II","slug":"119-Pascal-s-Triangle-II","date":"2022-04-18T11:04:26.000Z","updated":"2022-04-18T11:04:26.142Z","comments":true,"path":"2022/04/18/119-Pascal-s-Triangle-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/119-Pascal-s-Triangle-II/","excerpt":"","text":"Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: 根据杨辉三角形的规则递归。每次递归行数-1。根据上一行的返回值，生成新行的列表，然后返回。如果生成行数为0则返回{1}。 12345678910111213141516171819202122class Solution &#123; public List&lt;Integer&gt; getRow(int rowIndex) &#123; if(rowIndex == 0)&#123; List&lt;Integer&gt; ret = new ArrayList(); ret.add(1); return ret; &#125; List&lt;Integer&gt; arr = getRow(rowIndex - 1); List&lt;Integer&gt; ret = new ArrayList(); for(int i = 0; i &lt; arr.size()+1; i++)&#123; if(i == 0 || i == arr.size())&#123; ret.add(1); &#125; else&#123; ret.add(arr.get(i) + arr.get(i-1)); &#125; &#125; return ret; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"其他解法？","slug":"其他解法？","permalink":"https://xuanhe95.github.io/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"}]},{"title":"706. Design HashMap","slug":"706-Design-HashMap","date":"2022-04-18T10:25:53.000Z","updated":"2022-04-19T07:13:26.286Z","comments":true,"path":"2022/04/18/706-Design-HashMap/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/706-Design-HashMap/","excerpt":"","text":"Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map.void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. 哈希表，先设置一个素数Prime作为map的尺寸。（这里设置成素数是为了减少可能的碰撞。）创建一个Pair类记录key和value。 map初始化时需要生成一个LinkedList数组。 hash方法计算哈希值。用key % Prime并返回。 put方法，根据key计算其哈希值h。如果列表中有则重新设置当前Pair的value。 get方法，根据哈希值h搜索并查找链表中的Pair，如果找到则返回Pair，否则返回-1。 remove方法，根据哈希值h搜索并remove链表中的Pair。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class MyHashMap &#123; final int PRIME = 1009; List&lt;Pair&gt;[] map; public MyHashMap() &#123; map = new LinkedList[PRIME]; for(int i = 0; i &lt; PRIME; i++)&#123; map[i] = new LinkedList&lt;Pair&gt;(); &#125; &#125; public void put(int key, int value) &#123; int h = hash(key); for(Pair p : map[h])&#123; if(p.getKey() == key)&#123; p.setValue(value); return; &#125; &#125; Pair p = new Pair(key, value); map[h].add(p); &#125; public int get(int key) &#123; int h = hash(key); for(Pair p : map[h])&#123; if(p.getKey() == key)&#123; return p.value; &#125; &#125; return -1; &#125; public void remove(int key) &#123; int h = hash(key); for(Pair p : map[h])&#123; if(p.getKey() == key)&#123; map[h].remove(p); return; &#125; &#125; &#125; private int hash(int key)&#123; return key % PRIME; &#125;&#125;class Pair &#123; int key; int value; public Pair(int k, int v)&#123; key = k; value = v; &#125; public int getKey()&#123; return key; &#125; public int getValue()&#123; return value; &#125; public void setValue(int v)&#123; value = v; &#125;&#125;/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"intervals","slug":"intervals","permalink":"https://xuanhe95.github.io/tags/intervals/"}]},{"title":"56. Merge Intervals","slug":"56-Merge-Intervals","date":"2022-04-18T09:15:21.000Z","updated":"2022-04-18T09:15:21.694Z","comments":true,"path":"2022/04/18/56-Merge-Intervals/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/56-Merge-Intervals/","excerpt":"","text":"Given an array of intervals where intervals[i] &#x3D; [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. 先对数组进行排序。遍历数组，当前一个子数组与后一个子数组有重叠时，合并数组。 1234567891011121314151617181920212223class Solution &#123; public int[][] merge(int[][] intervals) &#123; Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[0],b[0])); int i = 0; List&lt;int[]&gt; ans = new ArrayList(); while( i &lt; intervals.length-1 )&#123; if(intervals[i][1] &gt;= intervals[i+1][0])&#123; intervals[i+1][0] = intervals[i][0]; intervals[i+1][1] = Math.max(intervals[i][1], intervals[i+1][1]); intervals[i] = null; &#125; i++; &#125; for(int[] interval : intervals)&#123; if(interval != null)&#123; ans.add(interval); &#125; &#125; return ans.toArray(new int[ans.size()][2]); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"},{"name":"Sort","slug":"Sort","permalink":"https://xuanhe95.github.io/tags/Sort/"}]},{"title":"82. Remove Duplicates from Sorted List II","slug":"82-Remove-Duplicates-from-Sorted-List-II","date":"2022-04-18T04:59:27.000Z","updated":"2022-04-18T04:59:27.380Z","comments":true,"path":"2022/04/18/82-Remove-Duplicates-from-Sorted-List-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/82-Remove-Duplicates-from-Sorted-List-II/","excerpt":"","text":"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. 使用队列暂存遍历的节点。初始化prev为一个dummy节点。如果当前节点不等于队列里节点的值，则倾倒出队列里的值。如果队列此时只有一个值，则将其添加到prev.next。遍历完毕后如果队列内只有一个值则将其设置到prev.next。最后返回dummy.next。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; Queue&lt;ListNode&gt; q = new LinkedList(); ListNode dummy = new ListNode(0); ListNode prev = dummy; ListNode curr = head; while(curr != null)&#123; if(q.isEmpty() || curr.val == q.peek().val)&#123; q.offer(curr); curr = curr.next; &#125; else&#123; if(q.size()==1)&#123; prev.next = q.poll(); prev = prev.next; prev.next = null; &#125; else&#123; q.clear(); &#125; &#125; &#125; if(q.size()==1)&#123; prev.next = q.poll(); &#125; return dummy.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"},{"name":"Queue","slug":"Queue","permalink":"https://xuanhe95.github.io/tags/Queue/"}]},{"title":"162. Find Peak Element","slug":"162-Find-Peak-Element","date":"2022-04-18T01:32:29.000Z","updated":"2022-04-18T01:43:45.542Z","comments":true,"path":"2022/04/18/162-Find-Peak-Element/","link":"","permalink":"https://xuanhe95.github.io/2022/04/18/162-Find-Peak-Element/","excerpt":"","text":"A peak element is an element that is strictly greater than its neighbors. Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] &#x3D; nums[n] &#x3D; -∞. You must write an algorithm that runs in O(log n) time. 二分搜索，由于只需要搜索任意一个山峰，因此只要向上走，一定可以走到一个峰。当中值的下一个值是增长时（向上爬山），则更新左侧指针的位置为中值+1。继续搜索下一个中值。否则更新右侧指针的位置为当前中值，等于向左侧进行搜索。最后返回左侧指针停留的位置。时间复杂度为O(logn)。 12345678910111213141516class Solution &#123; public int findPeakElement(int[] num) &#123; int left = 0; int right = num.length - 1; while (left &lt; right) &#123; int mid1 = (right - left) / 2 + left; int mid2 = mid1 + 1; if (num[mid1] &lt; num[mid2]) left = mid1+1; else right = mid1; &#125; return left; &#125;&#125; 一次遍历，找到峰值，返回其index。时间复杂度为O(n)。 123456789101112class Solution &#123; public int findPeakElement(int[] nums) &#123; int peak = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] &gt; nums[peak])&#123; peak = i; &#125; &#125; return peak; &#125;&#125; 分治法，每次将数组分为两组，向下递归。当数组长度为1时返回元素，比较返回来的两个数值的大小。返回其中的峰值index。此解法时间为O(nlogn)。 123456789101112131415161718192021class Solution &#123; public int findPeakElement(int[] nums) &#123; return findPeak(nums,0,nums.length-1); &#125; private int findPeak(int[] nums, int left, int right)&#123; if(left == right)&#123; return left; &#125; int mid = left + (right - left) / 2; int i = findPeak(nums, left, mid); int j = findPeak(nums, mid+1, right); if(nums[i] &gt; nums[j])&#123; return i; &#125; else&#123; return j; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"}]},{"title":"153. Find Minimum in Rotated Sorted Array","slug":"153-Find-Minimum-in-Rotated-Sorted-Array","date":"2022-04-17T14:16:03.000Z","updated":"2022-04-17T14:16:03.286Z","comments":true,"path":"2022/04/17/153-Find-Minimum-in-Rotated-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/17/153-Find-Minimum-in-Rotated-Sorted-Array/","excerpt":"","text":"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums &#x3D; [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. 二分搜索，寻找断裂点。当left小于right时循环。每次计算出mid，分为两种情况： 如果nums[mid]小于nums[nums.length-1]，则右半侧为顺序的。 反之则左半侧为顺序，右半侧为无序的。以此来更新搜索范围。由于mid计算公式向下取整。当更新left时更新为mid+1，向前一格。当更新right时更新为mid。最后返回nums[left]。 12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; return findBreakPoint(nums,0,nums.length-1); &#125; private int findBreakPoint(int[] nums, int left, int right)&#123; while(left &lt; right)&#123; int mid = (right - left)/2 + left; if(nums[mid] &lt; nums[nums.length-1])&#123; right = mid; &#125; else if(nums[mid] &gt;= nums[0])&#123; left = mid+1; &#125; &#125; return nums[left]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"}]},{"title":"897. Increasing Order Search Tree","slug":"897-Increasing-Order-Search-Tree","date":"2022-04-17T12:02:56.000Z","updated":"2022-04-18T01:30:44.258Z","comments":true,"path":"2022/04/17/897-Increasing-Order-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/17/897-Increasing-Order-Search-Tree/","excerpt":"","text":"Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. DFS搜索，在递归时将in-order遍历节点，并将其加入队列。从队列中挤出节点，将上一个节点的右子节点设置为下一个节点。同时需要将下一个节点的左子节点设置为null。&#96; 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; Queue&lt;TreeNode&gt; q; public TreeNode increasingBST(TreeNode root) &#123; q = new LinkedList(); dfs(root); TreeNode head = q.poll(); TreeNode curr = head; while(!q.isEmpty())&#123; curr.left = null; curr.right = q.poll(); curr = curr.right; &#125; curr.left = null; return head; &#125; private void dfs(TreeNode root)&#123; if(root == null)&#123; return; &#125; dfs(root.left); q.offer(root); dfs(root.right); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"Queue","slug":"Queue","permalink":"https://xuanhe95.github.io/tags/Queue/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"75. Sort Colors","slug":"75-Sort-Colors","date":"2022-04-17T08:50:08.000Z","updated":"2022-04-17T08:50:08.152Z","comments":true,"path":"2022/04/17/75-Sort-Colors/","link":"","permalink":"https://xuanhe95.github.io/2022/04/17/75-Sort-Colors/","excerpt":"","text":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function. 快速排序是原地排序，因此此问题可以采用快速排序解决。 选择left上的元素pivot，设置一个指针index为left+1。遍历left+1至right的数组，如果遍历的值小于pivot则将nums[i]与nums[index]交换，然后将index向右移动。 因此index左侧的元素均小于pivot，index右侧的元素均大于pivot。最后将nums[index]与pivot交换，此时pivot左侧元素均小于它，右侧元素均大于它，因此index不需要再动。然后分别向下递归left至index-1，index+1至right。 12345678910111213141516171819202122232425262728class Solution &#123; public void sortColors(int[] nums) &#123; quickSort(nums, 0, nums.length-1); &#125; private void quickSort(int[] nums, int left, int right)&#123; if( right - left &lt; 1 )&#123; return; &#125; int pivot = nums[left]; int index = left+1; for(int i = index; i &lt;= right; i++)&#123; if(nums[i] &lt; pivot)&#123; int temp = nums[index]; nums[index] = nums[i]; nums[i] = temp; index++; &#125; &#125; index--; nums[left] = nums[index]; nums[index] = pivot; quickSort(nums,left,index-1); quickSort(nums,index+1,right); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"Sort","slug":"Sort","permalink":"https://xuanhe95.github.io/tags/Sort/"}]},{"title":"33. Search in Rotated Sorted Array","slug":"33-Search-in-Rotated-Sorted-Array","date":"2022-04-17T07:14:53.000Z","updated":"2022-04-20T11:28:44.495Z","comments":true,"path":"2022/04/17/33-Search-in-Rotated-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/17/33-Search-in-Rotated-Sorted-Array/","excerpt":"","text":"There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;&#x3D; k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. 二分搜索，二分后将会形成两个区间，一个区间是顺序的，另一个是无序的。如果target等于中间值则返回。分别处理两种情况下移动指针的方式。当顺序区间在左半边时：当target在顺序区间内，则更新右指针的位置。否则更新左指针位置。当顺序区间在右半边时：当target在顺序区间内，则更新左指针的位置。否则更新右指针位置。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; while(left &lt;= right)&#123; int mid = (right - left) / 2 + left; if(nums[mid] == target)&#123; return mid; &#125; if( nums[mid] &gt;= nums[0] )&#123; if(target &gt;= nums[0] &amp;&amp; target &lt; nums[mid] )&#123; right = mid - 1; &#125; else&#123; left = mid + 1; &#125; &#125; else&#123; if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[nums.length-1])&#123; left = mid + 1; &#125; else&#123; right = mid -1; &#125; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"15. 3Sum","slug":"15-3Sum","date":"2022-04-17T01:41:45.000Z","updated":"2022-04-20T11:29:29.788Z","comments":true,"path":"2022/04/17/15-3Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/17/15-3Sum/","excerpt":"","text":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i !&#x3D; j, i !&#x3D; k, and j !&#x3D; k, and nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0. Notice that the solution set must not contain duplicate triplets. 三数之和，重点是如何遍历后去除重复的数组。首先对数组进行排序。遍历数组，三个数中最小的数字为nums[i]。此时需要去除重复的nums[i]。如重复则继续下一次循环。此时设置双指针left和right，分别在nums[i]右侧的子数组的首尾。 当nums[i] + nums[left] + nums[right] &gt; 0时，后两个数的和需要减小，right指针向左移动。 当nums[i] + nums[left] + nums[right] &lt; 0时，后两个数的和需要增大，left指针向右移动。 当nums[i] + nums[left] + nums[right] &#x3D; 0时，找到一个组合。 此时需要去除重复的nums[left]和nums[right]。如重复则更新left或right的指针。 将组合添加到返回列表。 最后返回列表。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i++)&#123; int left = i+1; int right = nums.length-1; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1])&#123; continue; &#125; while(left &lt; right)&#123; if(nums[i]+nums[left]+nums[right]==0)&#123; while(left+1 &lt; nums.length &amp;&amp; nums[left] == nums[left+1])&#123; left++; &#125; while(right-1 &gt; i &amp;&amp; nums[right] == nums[right-1])&#123; right--; &#125; List&lt;Integer&gt; list = new ArrayList(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); left++; right--; &#125; else if(nums[i]+nums[left]+nums[right]&gt;0)&#123; right--; &#125; else&#123; left++; &#125; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"34. Find First and Last Position in Sorted Array","slug":"34-Find-First-and-Last-Position-in-Sorted-Array","date":"2022-04-16T13:57:16.000Z","updated":"2022-04-16T13:57:28.308Z","comments":true,"path":"2022/04/16/34-Find-First-and-Last-Position-in-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/34-Find-First-and-Last-Position-in-Sorted-Array/","excerpt":"","text":"问题Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. 二分搜索，搜索中间项。中间项等于左侧和右侧指针的中点，根据搜索左侧边界和右侧边界选择二分向下舍去或是二分向上补足。当中间项小于目标，则更新左侧边界。若中间项大于目标，则更新右侧边界。当中间项等于目标时，根据搜索左侧边界还是右侧边界选择更新左侧或右侧。由于有可能有重复元素存在，因此需要继续二分搜索下去，直到右侧边界大于左侧边界。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; return new int[]&#123;searchLeft(nums,target),searchRight(nums,target)&#125;; &#125; private int searchRight(int[] nums, int target)&#123; int left = 0; int right = nums.length-1; int mid = 0; int result = -1; while(left &lt;= right)&#123; mid = (right-left)/2+left; if(nums[mid] &lt; target)&#123; left = mid+1; &#125; else if(nums[mid] &gt; target)&#123; right = mid-1; &#125; else&#123; result = mid; left = mid+1; &#125; &#125; return result; &#125; private int searchLeft(int[] nums, int target)&#123; int left = 0; int right = nums.length-1; int mid = 0; int result = -1; while(left &lt;= right)&#123; mid = (right-left+1)/2+left; if(nums[mid] &lt; target)&#123; left = mid+1; &#125; else if(nums[mid] &gt; target)&#123; right = mid-1; &#125; else&#123; result = mid; right = mid-1; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Renamed","slug":"Renamed","permalink":"https://xuanhe95.github.io/tags/Renamed/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"}]},{"title":"190. Reverse Bits","slug":"190-Reverse-Bits","date":"2022-04-16T12:00:37.000Z","updated":"2022-04-16T12:00:37.995Z","comments":true,"path":"2022/04/16/190-Reverse-Bits/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/190-Reverse-Bits/","excerpt":"","text":"问题Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. 创建返回值ans。每次向左移动一位ans，然后取n的尾数进行二进制或运算（相当于在尾部进行不进位的加和）。然后将n向左移动一位。 二进制下的或运算只保留两数间较大的位。(0011 | 0110 &#x3D; 0111) 二进制下的与运算只保留两数间皆为1的位。(0011 &amp; 0110 &#x3D; 0010) 掩码（Mask）是在二进制下进行与运算。以1作为掩码时，前面的31为皆为0，因此进行与运算后只保留最后一位。 因此(n &amp; 1)相当于n的二进制与000…001运算，只保留n的尾数。然后(ans &lt;&lt; 1)向左移动一位，用 | 操作将n的尾数加入ans。 1234567891011public class Solution &#123; // you need treat n as an unsigned value public int reverseBits(int n) &#123; int ans = 0; for(int i = 0; i &lt; 32; i++)&#123; ans = (ans &lt;&lt; 1) | (n &amp; 1); n &gt;&gt;= 1; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"},{"name":"掩码","slug":"掩码","permalink":"https://xuanhe95.github.io/tags/%E6%8E%A9%E7%A0%81/"}]},{"title":"169. Majority Element","slug":"169-Majority-Element","date":"2022-04-16T11:20:43.000Z","updated":"2022-04-16T11:24:07.730Z","comments":true,"path":"2022/04/16/169-Majority-Element/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/169-Majority-Element/","excerpt":"","text":"问题Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n &#x2F; 2⌋ times. You may assume that the majority element always exists in the array. Boyer-Moore投票算法基本思想：众数的值为+1，非众数的值为-1。其加和作为投票值。遍历整个数组，由于众数数量大于非众数，因此最后结果一定为正数。 设置count记录票数，遍历数组。当count为0时，则将当前的数组设为众数。当之后的数字与其相等，则count+1，反之则-1。遍历完成后返回当前的众数。 根据以上规则，每次我们选择的众数，都是已遍历数组范围内出现最多次数的数值之一。 由于给定的数组的众数超过半数，因此遍历到最后的众数，一定是整个数组中出现最多次的数值。 核心就是对拼消耗。玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。 那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。 最后能剩下的必定是自己人。 12345678910111213141516171819class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 0; int major = 0; for(int num : nums)&#123; if(count == 0)&#123; major = num; &#125; if(major == num)&#123; count++; &#125; else&#123; count--; &#125; &#125; return major; &#125;&#125; 遍历数组，并将各个数值出现的次数记录在哈希表中。当出现的次数大于数组的一半，则该数值是众数。 123456789101112class Solution &#123; public int majorityElement(int[] nums) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int num : nums)&#123; map.put(num, map.getOrDefault(num,0)+1); if(map.get(num) &gt; nums.length/2)&#123; return num; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"算法","slug":"算法","permalink":"https://xuanhe95.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"投票算法","slug":"投票算法","permalink":"https://xuanhe95.github.io/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"}]},{"title":"136. Single Number","slug":"136-Single-Number","date":"2022-04-16T10:18:34.000Z","updated":"2022-04-16T10:18:34.119Z","comments":true,"path":"2022/04/16/136-Single-Number/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/136-Single-Number/","excerpt":"","text":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. 位运算，对所有数值做二进制异或运算。两个同样的值异或运算会等于0，最后和与单独的数字相等。 123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int ans = 0; for(int num : nums)&#123; ans = ans ^ num; &#125; return ans; &#125;&#125; 排序，然后遍历数组，如果第i个值不等于第i+1个则返回。 1234567891011class Solution &#123; public int singleNumber(int[] nums) &#123; Arrays.sort(nums); for(int i = 0; i &lt; nums.length-1; i+=2)&#123; if(nums[i] != nums[i+1])&#123; return nums[i]; &#125; &#125; return nums[nums.length-1]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"}]},{"title":"653. Two Sum IV - Input is a BST","slug":"653-Two-Sum-IV-Input-is-a-BST","date":"2022-04-16T09:12:22.000Z","updated":"2022-04-16T09:12:22.187Z","comments":true,"path":"2022/04/16/653-Two-Sum-IV-Input-is-a-BST/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/653-Two-Sum-IV-Input-is-a-BST/","excerpt":"","text":"问题Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. DFS搜索，每次递归时检查HashSet中是否有当前节点的值。如没有则将目标值减去当前节点的值加入HashSet。如有则返回true。递归左侧节点和右侧节点，并返回二者的或运算。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; HashSet&lt;Integer&gt; set; public boolean findTarget(TreeNode root, int k) &#123; set = new HashSet(); return dfs(root,k); &#125; private boolean dfs(TreeNode root, int k)&#123; if(root == null)&#123; return false; &#125; if(set.contains(root.val))&#123; return true; &#125; set.add(k - root.val); return dfs(root.left,k) || dfs(root.right,k); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"235. Lowest Common Ancestor of a BST","slug":"235-Lowest-Common-Ancestor-of-a-BST","date":"2022-04-16T08:52:15.000Z","updated":"2022-04-16T13:57:44.823Z","comments":true,"path":"2022/04/16/235-Lowest-Common-Ancestor-of-a-BST/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/235-Lowest-Common-Ancestor-of-a-BST/","excerpt":"","text":"问题Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” DFS搜索，如果当前节点为null，则返回null。如果当前节点小于p和q的值，则递归其左子节点。反之递归其右子节点。如果当前节点在p与q之间，则返回当前节点。该节点是p与q的Lowest Common Ancestor。 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)&#123; return null; &#125; if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125; if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125; return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"},{"name":"Renamed","slug":"Renamed","permalink":"https://xuanhe95.github.io/tags/Renamed/"}]},{"title":"538. Convert BST to Greater Tree","slug":"538-Convert-BST-to-Greater-Tree","date":"2022-04-16T08:21:22.000Z","updated":"2022-04-16T08:21:22.501Z","comments":true,"path":"2022/04/16/538-Convert-BST-to-Greater-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/538-Convert-BST-to-Greater-Tree/","excerpt":"","text":"问题Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only &gt;-&gt;- nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */DFS搜索，设置一个成员变量记录上一个节点的值。先递归右侧节点。设置当前节点的值为自身的值加上temp中的值。更新temp中的值，再递归左侧节点。class Solution &#123; int temp; public TreeNode convertBST(TreeNode root) &#123; temp = 0; dfs(root); return root; &#125; private void dfs(TreeNode root)&#123; if(root == null)&#123; return; &#125; dfs(root.right); root.val += temp; temp = root.val; dfs(root.left); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"669. Trim a Binary Search Tree","slug":"669-Trim-a-Binary-Search-Tree","date":"2022-04-16T07:30:04.000Z","updated":"2022-04-16T07:30:13.402Z","comments":true,"path":"2022/04/16/669-Trim-a-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/16/669-Trim-a-Binary-Search-Tree/","excerpt":"","text":"问题Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds. DFS搜索，每次递归带上搜索的范围值。如果当前节点小于搜索范围，递归当前节点的右子节点。反之递归当前节点的左子节点。如果当前节点在搜索范围中，则其左子节点等于递归后的左子节点，右子节点等于递归后的右子节点。然后返回当前节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null)&#123; return null; &#125; if(root.val &lt; low)&#123; return trimBST(root.right, low, high); &#125; if(root.val &gt; high)&#123; return trimBST(root.left, low, high); &#125; root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"70. Climbing Stairs","slug":"70-Climbing-Stairs","date":"2022-04-15T04:23:11.000Z","updated":"2022-04-15T04:23:11.858Z","comments":true,"path":"2022/04/15/70-Climbing-Stairs/","link":"","permalink":"https://xuanhe95.github.io/2022/04/15/70-Climbing-Stairs/","excerpt":"","text":"问题You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 递归，传入根节点，进行BFS搜索。如果当前节点小于搜索的最低点，则抛弃该节点，继续搜索其右子节点。（由于是BST，右子节点大于节点本身）如果当前节点大于搜索的最高点，则抛弃该节点，继续搜索其左子节点。如果当前节点在搜索范围内，则保留该节点，继续递归该节点的两个子节点。最后返回根节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null)&#123; return null; &#125; if(root.val &lt; low)&#123; return trimBST(root.right, low, high); &#125; if(root.val &gt; high)&#123; return trimBST(root.left, low, high); &#125; root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"191. Number of 1 Bits","slug":"191-Number-of-1-Bits","date":"2022-04-14T11:46:17.000Z","updated":"2022-04-14T11:46:18.083Z","comments":true,"path":"2022/04/14/191-Number-of-1-Bits/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/191-Number-of-1-Bits/","excerpt":"","text":"问题Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. 位运算，[n-1]的二进制数字为[n]的二进制数字退一位。二者的与运算结果相当于二进制下[n]减少最右侧的1。例如0100100的0100011两者的与运算结果为0100000。相当于减少了一位1。计算循环次数就可以得出1的总数。 1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int count = 0; while(n != 0)&#123; n = (n &amp; (n-1)); count++; &#125; return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"}]},{"title":"231. Power of Two","slug":"231-Power-of-Two","date":"2022-04-14T08:03:00.000Z","updated":"2022-04-14T08:03:00.903Z","comments":true,"path":"2022/04/14/231-Power-of-Two/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/231-Power-of-Two/","excerpt":"","text":"问题Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n &#x3D;&#x3D; 2x. 位运算，由于2^n^的二进制为[100…00]，当2^n^-1时，其二进制为[11..11]（少一位）。两者进行按位与（&amp;）运算，得到[000…00]，与0相等。 12345678class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0)&#123; return false; &#125; return (n &amp; (n - 1)) == 0; &#125;&#125; 递归，当（n &lt;&#x3D; 0）时，返回false。当n等于1时，返回true。当（n % 2）有余数时，返回false。递归（n &#x2F; 2）。 1234567891011121314class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0)&#123; return false; &#125; if (n == 1)&#123; return true; &#125; if (n%2 != 0)&#123; return false; &#125; return isPowerOfTwo(n/2); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"}]},{"title":"112. Path Sum","slug":"112-Path-Sum","date":"2022-04-14T03:46:28.000Z","updated":"2022-04-14T03:46:28.994Z","comments":true,"path":"2022/04/14/112-Path-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/112-Path-Sum/","excerpt":"","text":"问题Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 递归，如果当前节点为null则返回false。计算并更新当前节点的值。如果当前节点为叶节点，且当前节点的值等于target，则返回true。递归左子节点和右子节点，返回两者的或运算。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean hasPathSum(TreeNode root, int targetSum) &#123; return hasPathSum(root,0,targetSum); &#125; private boolean hasPathSum(TreeNode root, int parentVal, int target)&#123; if (root == null)&#123;return false;&#125; root.val = root.val + parentVal; if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target)&#123; return true; &#125; return ( hasPathSum(root.left, root.val, target) || hasPathSum(root.right, root.val, target)); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"复习","slug":"LeetCode/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"701. Insert into a Binary Search Tree","slug":"701-Insert-into-a-Binary-Search-Tree","date":"2022-04-14T00:59:33.000Z","updated":"2022-04-14T00:59:34.017Z","comments":true,"path":"2022/04/14/701-Insert-into-a-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/701-Insert-into-a-Binary-Search-Tree/","excerpt":"","text":"问题You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. 如果root为空则将值直接添加到根节点。辅助方法比较当前节点的值。如当前值大于添加的值，则检测左子节点是否为空。如不为空则递归左子节点。如当前值小于添加的值，则检测右子节点是否为空。如不为空则递归右子节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if (root == null)&#123; root = new TreeNode(val); &#125; insert(root,val); return root; &#125; private void insert(TreeNode root, int val)&#123; if (root.val &lt; val)&#123; if (root.right == null)&#123; root.right = new TreeNode(val); &#125; insert(root.right, val); &#125; else if (root.val &gt; val)&#123; if (root.left == null)&#123; root.left = new TreeNode(val); &#125; insert(root.left, val); &#125; return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"700. Search in a Binary Search Tree","slug":"700-Search-in-a-Binary-Search-Tree","date":"2022-04-14T00:27:52.000Z","updated":"2022-04-14T00:28:06.984Z","comments":true,"path":"2022/04/14/700-Search-in-a-Binary-Search-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/700-Search-in-a-Binary-Search-Tree/","excerpt":"","text":"问题You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. 搜索二叉树。递归，如果现有根节点为空则返回空。如果根节点的值大于搜索值则搜索其左子节点。如果根节点的值小于搜索值则搜索其左右节点。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; if (root == null)&#123; return null; &#125; else if (root.val &lt; val)&#123; return searchBST(root.right,val); &#125; else if (root.val &gt; val)&#123; return searchBST(root.left,val); &#125; else&#123; return root; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"120. Triangle","slug":"120-Triangle","date":"2022-04-14T00:14:31.000Z","updated":"2022-04-14T00:17:00.013Z","comments":true,"path":"2022/04/14/120-Triangle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/120-Triangle/","excerpt":"","text":"问题Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. 动态规划，先将最左侧一列的值算出。然后[i+1][j+1]根据[i][j+1]和[i][j]得出。该动态规划表应是为三角形。因此当i等于j时，[i+1][i+j]的数值只根据[i][j]得出。 例子：代码里插入了一个print方法打印动态规划表。当输入列表 [[2],[3,4],[6,5,7],[4,1,8,3]] 时：其动态规划表为： 2, 0, 0, 0, 5, 6, 0, 0, 11, 10, 13, 0, 15, 11, 18, 16, 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[][] dp = new int[triangle.size()][triangle.size()]; int min = Integer.MAX_VALUE; dp[0][0] = triangle.get(0).get(0); for (int i = 0; i &lt; triangle.size()-1; i++)&#123; dp[i+1][0] = dp[i][0] + triangle.get(i+1).get(0); &#125; for (int i = 0; i &lt; triangle.size()-1; i++)&#123; for (int j = 0; j &lt;= i; j++)&#123; if ( i == j )&#123; dp[i+1][j+1] = dp[i][j] + triangle.get(i+1).get(j+1); &#125; else&#123; dp[i+1][j+1] = Math.min(dp[i][j] + triangle.get(i+1).get(j+1), dp[i][j+1] + triangle.get(i+1).get(j+1)); &#125; &#125; &#125; //print(dp); for (int k = 0; k &lt; triangle.size(); k++)&#123; min = Math.min(dp[triangle.size()-1][k],min); &#125; return min; &#125; private void print(int[][] text)&#123; for (int i = 0; i &lt;text.length; i++)&#123; for (int j = 0; j &lt; text[0].length; j++)&#123; System.out.print(text[i][j]+&quot;, &quot;); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"198. House Robber","slug":"198-House-Robber","date":"2022-04-13T20:17:19.000Z","updated":"2022-04-13T20:17:19.895Z","comments":true,"path":"2022/04/14/198-House-Robber/","link":"","permalink":"https://xuanhe95.github.io/2022/04/14/198-House-Robber/","excerpt":"","text":"问题You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. 动态规划。dp数组记录经过i个房子后可以获得的最大值。dp[i+1]的值等于dp[i-1]加上现有房子的钱（抢这个房子）与dp[i]的值（不抢这个房子）中的较大值。 12345678910111213141516class Solution &#123; public int rob(int[] nums) &#123; int[] money = new int[nums.length+1]; money[0] = 0; money[1] = nums[0]; for (int i = 1; i &lt; nums.length; i++)&#123; money[i+1] = Math.max(money[i-1]+nums[i],money[i]); &#125; return money[nums.length]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"226. Invert Binary Tree","slug":"226-Invert-Binary-Tree","date":"2022-04-13T09:29:46.000Z","updated":"2022-04-13T09:29:47.073Z","comments":true,"path":"2022/04/13/226-Invert-Binary-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/226-Invert-Binary-Tree/","excerpt":"","text":"问题Given the root of a binary tree, invert the tree, and return its root. 翻转二叉树。交换当前节点的左右子节点。分别递归其左右子节点。当当前节点的两个节点均为null时返回。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null)&#123; return root; &#125; invert(root); return root; &#125; private void invert(TreeNode root)&#123; if ( root.left == null &amp;&amp; root.right == null)&#123; return; &#125; TreeNode temp = root.left; root.left = root.right; root.right = temp; if ( root.left != null )&#123; invert(root.left); &#125; if ( root.right != null )&#123; invert(root.right); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"784. Letter Case Permutation","slug":"784-Letter-Case-Permutation","date":"2022-04-13T09:14:29.000Z","updated":"2022-04-17T01:47:39.898Z","comments":true,"path":"2022/04/13/784-Letter-Case-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/784-Letter-Case-Permutation/","excerpt":"","text":"答案Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Return the output in any order. 当前字符如果为数字，则直接添加并递归。（将字符隐式转换为整数判断是否为数字，可提升速度。）当前字符如果为字母，则大小写分别添加到递归。（类似于回溯。）当字符串长度与搜寻字符串相等时，添加到列表。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;String&gt; ans; String _s; public List&lt;String&gt; letterCasePermutation(String s) &#123; ans = new ArrayList(); _s = s; backTrack(new StringBuilder(),0); return ans; &#125; private void backTrack(StringBuilder sb, int i)&#123; if(i == _s.length())&#123; ans.add(sb.toString()); return; &#125; char curr = _s.charAt(i); if ( isNums(curr) )&#123; sb.append(curr); backTrack(sb, i+1); &#125; else&#123; StringBuilder sb2 = new StringBuilder(sb); sb.append(Character.toLowerCase(curr)); backTrack(sb, i+1); sb2.append(Character.toUpperCase(curr)); backTrack(sb2, i+1); &#125; &#125; private boolean isNums(char c)&#123; if ( (int)c &gt;= (int)&#x27;0&#x27; &amp;&amp; (int)c &lt;= (int)&#x27;9&#x27; )&#123; return true; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"Permutation","slug":"Permutation","permalink":"https://xuanhe95.github.io/tags/Permutation/"}]},{"title":"46. Permutations","slug":"46-Permutations","date":"2022-04-13T08:01:13.000Z","updated":"2022-04-17T01:47:12.364Z","comments":true,"path":"2022/04/13/46-Permutations/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/46-Permutations/","excerpt":"","text":"问题Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. 回溯，建立搜索树。每次遍历nums中的元素。如果未遍历过该元素，则向链表及set中添加。向下递归，链表长度达到nums的长度时返回。然后从set和链表中移除上一个值，回溯到上一个节点。 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans; HashSet&lt;Integer&gt; set; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; ans = new ArrayList(); set = new HashSet(); backTrack(new LinkedList(), nums, nums.length, nums.length); return ans; &#125; private void backTrack(LinkedList&lt;Integer&gt; list,int[] nums, int n, int k)&#123; if(k == 0)&#123; ans.add(new ArrayList(list)); return; &#125; for(int i = 0; i &lt; n ; i++)&#123; if(!set.contains(nums[i]))&#123; list.add(nums[i]); set.add(nums[i]); backTrack(list, nums , n, k-1); set.remove(nums[i]); list.removeLast(); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"},{"name":"Permutation","slug":"Permutation","permalink":"https://xuanhe95.github.io/tags/Permutation/"}]},{"title":"101. Symmetric Tree","slug":"101-Symmetric-Tree","date":"2022-04-13T07:21:05.000Z","updated":"2022-04-13T07:21:05.710Z","comments":true,"path":"2022/04/13/101-Symmetric-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/101-Symmetric-Tree/","excerpt":"","text":"问题Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). 递归root1的左子节点和root2的右子节点以及root2的左子节点以及root1的右子节点。如两者不相等则返回false。如果传入的两个数值有一个为null，则两者不相等时返回false。反之返回true。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return isSymmetric(root,root); &#125; public boolean isSymmetric(TreeNode root1, TreeNode root2)&#123; if ( root1 == null || root2 == null )&#123; if(root1 == root2)&#123;return true;&#125; else&#123;return false;&#125; &#125; if ( root1.val == root2.val )&#123; return isSymmetric(root1.left,root2.right) &amp;&amp; isSymmetric(root1.right,root2.left); &#125; else&#123; return false; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"104. Maximum Depth of Binary Tree","slug":"104-Maximum-Depth-of-Binary-Tree","date":"2022-04-13T07:05:50.000Z","updated":"2022-04-13T07:05:50.671Z","comments":true,"path":"2022/04/13/104-Maximum-Depth-of-Binary-Tree/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/104-Maximum-Depth-of-Binary-Tree/","excerpt":"","text":"问题Given the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 递归，每次返回左子节点和右子节点中较大的结果+1。当节点为null时返回0。 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; &#125;&#125; BFS搜索，每次倾倒出队列里所有的元素并将level+1。搜索完毕返回level。 1234567891011121314151617181920class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null)&#123; return 0; &#125; Queue&lt;TreeNode&gt; q = new LinkedList(); q.offer(root); int level = 0; while(!q.isEmpty())&#123; int size = q.size(); for (int i = 0; i &lt; size; i++)&#123; TreeNode curr = q.poll(); if(curr.left!=null)&#123;q.offer(curr.left);&#125; if(curr.right!=null)&#123;q.offer(curr.right);&#125; &#125; level++; &#125; return level; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"102. Binary Tree Level Order Traversal","slug":"102-Binary-Tree-Level-Order-Traversal","date":"2022-04-13T06:51:42.000Z","updated":"2022-04-13T06:55:58.540Z","comments":true,"path":"2022/04/13/102-Binary-Tree-Level-Order-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/102-Binary-Tree-Level-Order-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). BFS搜索，用队列储存树节点。每次循环情到出一个层级所有的节点并放入列表。注意：需要记录队列的size，否则在for each循环时队列size会改变。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); if(root == null)&#123; return ans; &#125; Queue&lt;TreeNode&gt; q = new LinkedList(); q.add(root); while(!q.isEmpty())&#123; List&lt;Integer&gt; temp = new ArrayList(); int size = q.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode curr = q.poll(); temp.add(curr.val); if(curr.left!=null)&#123;q.offer(curr.left);&#125; if(curr.right!=null)&#123;q.offer(curr.right);&#125; &#125; ans.add(temp); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"77. Combinations","slug":"77-Combinations","date":"2022-04-13T05:52:44.000Z","updated":"2022-04-17T01:46:56.785Z","comments":true,"path":"2022/04/13/77-Combinations/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/77-Combinations/","excerpt":"","text":"问题Given two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order. 回溯，构建搜索树。子节点取出的数值应大于父节点中取出的数值。直到树高度达到k后返回。 返回时，要new一个List，将原有list传入。否则添加到ans的值只是list的内存地址。ArrayList换成LinkedList可以优化一些速度，因为可以直接removeLast。（22ms -&gt; 16ms）i的范围限制在start到n-k+1，后面的限制容易被忽略，可以大幅度减枝，优化速度。（16ms -&gt; 1ms） 123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; ans; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; ans = new ArrayList&lt;&gt;(); backTrack(new LinkedList(),1,n,k); return ans; &#125; private void backTrack(LinkedList&lt;Integer&gt; list, int start, int n, int k)&#123; if (k == 0)&#123; ans.add(new ArrayList(list)); return; &#125; for (int i = start; i &lt;= n-k+1; i++)&#123; list.add(i); backTrack(list, i+1, n, k-1); list.removeLast(); &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"},{"name":"Combination","slug":"Combination","permalink":"https://xuanhe95.github.io/tags/Combination/"}]},{"title":"59. Spiral Matrix II","slug":"59-Spiral-Matrix-II","date":"2022-04-13T03:28:17.000Z","updated":"2022-04-13T03:28:17.228Z","comments":true,"path":"2022/04/13/59-Spiral-Matrix-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/13/59-Spiral-Matrix-II/","excerpt":"","text":"问题Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. 循环，创建一个上界和一个下界。当达到界限时，改变方向。更新上界和下界的数值。当上界小于下界时返回。 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] ans = new int[n][n]; int upperBound = n; int lowerBound = 0; int i = 0; int j = 0; int count = 1; ans[0][0] = 1; while ( lowerBound &lt; upperBound )&#123; while ( j &lt; upperBound-1 )&#123; j++; count++; ans[i][j] = count; &#125; while ( i &lt; upperBound-1 )&#123; i++; count++; ans[i][j] = count; &#125; while ( j &gt; lowerBound )&#123; j--; count++; ans[i][j] = count; &#125; upperBound--; lowerBound++; while ( i &gt; lowerBound )&#123; i--; count++; ans[i][j] = count; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"289. Game of Life","slug":"289-Game-of-Life","date":"2022-04-12T07:12:11.000Z","updated":"2022-04-12T07:12:11.118Z","comments":true,"path":"2022/04/12/289-Game-of-Life/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/289-Game-of-Life/","excerpt":"","text":"问题According to Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.” The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. 辅助方法，计算每个位置四周有生命的总和。根据规则填写到新数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public void gameOfLife(int[][] board) &#123; int[][] ans = new int[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++)&#123; for (int j = 0; j &lt; board[0].length; j++)&#123; int neighbors = countNeighbors(board, i, j); if ( neighbors &lt; 2 &amp;&amp; board[i][j] == 1 )&#123; ans[i][j] = 0; &#125; else if( neighbors &lt;= 3 &amp;&amp; board[i][j] == 1 )&#123; ans[i][j] = 1; &#125; else if( neighbors &gt; 3 &amp;&amp; board[i][j] == 1 )&#123; ans[i][j] = 0; &#125; else if( neighbors == 3 &amp;&amp; board[i][j] == 0)&#123; ans[i][j] = 1; &#125; &#125; &#125; for (int i = 0; i &lt; board.length; i++)&#123; for (int j = 0; j &lt; board[0].length; j++)&#123; board[i][j] = ans[i][j]; &#125; &#125; &#125; private int countNeighbors(int[][] board, int r, int c)&#123; int neighbors = 0; int row = board.length; int col = board[0].length; if(r + 1 &lt; row &amp;&amp; board[r+1][c] == 1)&#123; neighbors++; &#125; if(r - 1 &gt;= 0 &amp;&amp; board[r-1][c] == 1)&#123; neighbors++; &#125; if(c + 1 &lt; col &amp;&amp; board[r][c+1] == 1)&#123; neighbors++; &#125; if(c - 1 &gt;= 0 &amp;&amp; board[r][c-1] == 1)&#123; neighbors++; &#125; if(r + 1 &lt; row &amp;&amp; c + 1 &lt; col &amp;&amp; board[r+1][c+1] == 1)&#123; neighbors++; &#125; if(r + 1 &lt; row &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r+1][c-1] == 1 )&#123; neighbors++; &#125; if(r - 1 &gt;= 0 &amp;&amp; c + 1 &lt; col &amp;&amp; board[r-1][c+1] == 1 )&#123; neighbors++; &#125; if(r - 1 &gt;= 0 &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r-1][c-1] == 1 )&#123; neighbors++; &#125; return neighbors; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"145. Binary Tree Postorder Traversal","slug":"145-Binary-Tree-Postorder-Traversal","date":"2022-04-11T21:00:33.000Z","updated":"2022-04-11T21:02:51.752Z","comments":true,"path":"2022/04/12/145-Binary-Tree-Postorder-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/145-Binary-Tree-Postorder-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the postorder traversal of its nodes’ values. 后序遍历。先递归左子节点。然后递归右子节点。最后将当前节点加入数组。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; ans; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; ans = new ArrayList(); traversal(root); return ans; &#125; private void traversal(TreeNode root)&#123; if (root == null)&#123; return; &#125; traversal(root.left); traversal(root.right); ans.add(root.val); return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"94. Binary Tree Inorder Traversal","slug":"94-Binary-Tree-Inorder-Traversal","date":"2022-04-11T20:54:17.000Z","updated":"2022-04-11T21:02:04.723Z","comments":true,"path":"2022/04/12/94-Binary-Tree-Inorder-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/94-Binary-Tree-Inorder-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the inorder traversal of its nodes’ values. 中序遍历。先递归左子节点。然后将当前节点加入数组。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; ans; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; ans = new ArrayList(); traversal(root); return ans; &#125; private void traversal(TreeNode root)&#123; if (root == null)&#123; return; &#125; traversal(root.left); ans.add(root.val); traversal(root.right); return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"144. Binary Tree Preorder Traversal","slug":"144-Binary-Tree-Preorder-Traversal","date":"2022-04-11T20:49:35.000Z","updated":"2022-04-11T21:02:26.977Z","comments":true,"path":"2022/04/12/144-Binary-Tree-Preorder-Traversal/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/144-Binary-Tree-Preorder-Traversal/","excerpt":"","text":"问题Given the root of a binary tree, return the preorder traversal of its nodes’ values. 先序遍历。先将当前节点加入数组。然后递归左子节点。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; List&lt;Integer&gt; ans; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; ans = new ArrayList(); traversal(root); return ans; &#125; private void traversal(TreeNode root)&#123; if (root == null)&#123; return; &#125; ans.add(root.val); traversal(root.left); traversal(root.right); return; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"232. Implement Queue using Stacks","slug":"232-Implement-Queue-using-Stacks","date":"2022-04-11T20:29:21.000Z","updated":"2022-04-11T20:29:33.992Z","comments":true,"path":"2022/04/12/232-Implement-Queue-using-Stacks/","link":"","permalink":"https://xuanhe95.github.io/2022/04/12/232-Implement-Queue-using-Stacks/","excerpt":"","text":"问题Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise.Notes: You must use only standard operations of a stack, which means only push to top, peek&#x2F;pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. 创建两个栈。当入队列时，将元素压入第一个栈。当出队列或进行其他操作时，如第二个栈为空，则将第一个栈的元素倒出到第二个栈。此时第二个栈内的内容为顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyQueue &#123; Stack&lt;Integer&gt; s1; Stack&lt;Integer&gt; s2; public MyQueue() &#123; s1 = new Stack(); s2 = new Stack(); &#125; public void push(int x) &#123; s1.add(x); &#125; public int pop() &#123; if (s2.isEmpty())&#123; while (!s1.isEmpty())&#123; s2.add(s1.pop()); &#125; return s2.pop(); &#125; else&#123; return s2.pop(); &#125; &#125; public int peek() &#123; if (s2.isEmpty())&#123; while (!s1.isEmpty())&#123; s2.add(s1.pop()); &#125; return s2.peek(); &#125; else&#123; return s2.peek(); &#125; &#125; public boolean empty() &#123; return s1.isEmpty() &amp;&amp; s2.isEmpty(); &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"https://xuanhe95.github.io/tags/Queue/"}]},{"title":"1260. Shift 2D Grid","slug":"1260-Shift-2D-Grid","date":"2022-04-11T00:50:48.000Z","updated":"2022-04-11T00:50:48.405Z","comments":true,"path":"2022/04/11/1260-Shift-2D-Grid/","link":"","permalink":"https://xuanhe95.github.io/2022/04/11/1260-Shift-2D-Grid/","excerpt":"","text":"问题Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1].Element at grid[i][n - 1] moves to grid[i + 1][0].Element at grid[m - 1][n - 1] moves to grid[0][0].Return the 2D grid after applying shift operation k times. 遍历整个数组，将索引值加上移动的次数，得到新的位置。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int row = grid.length; int col = grid[0].length; int size = row * col; Integer[][] mat = new Integer[row][col]; for (int i = 0; i &lt; size; i++)&#123; int j = i + k; if ( j &gt; size - 1)&#123; j %= size; &#125; int nr = j / col; int nc = j % col; int or = i / col; int oc = i % col; mat[nr][nc] = grid[or][oc]; &#125; for (int i = 0; i &lt; row; i++)&#123; List&lt;Integer&gt; nums = Arrays.asList(mat[i]); ans.add(nums); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"682. Baseball Game","slug":"682-Baseball-Game","date":"2022-04-10T18:04:38.000Z","updated":"2022-04-20T11:32:32.948Z","comments":true,"path":"2022/04/11/682-Baseball-Game/","link":"","permalink":"https://xuanhe95.github.io/2022/04/11/682-Baseball-Game/","excerpt":"","text":"问题You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds’ scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x. “+” - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. “D” - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. “C” - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. 遍历选项，根据内容决定对ArrayList的操作。然后遍历将ArrayList加和，返回。 123456789101112131415161718192021222324252627class Solution &#123; public int calPoints(String[] ops) &#123; int ans = 0; List&lt;Integer&gt; records = new ArrayList(); for (String op : ops)&#123; switch(op)&#123; case &quot;+&quot;: records.add(records.get(records.size()-1)+records.get(records.size()-2)); break; case &quot;D&quot;: records.add(records.get(records.size()-1)*2); break; case &quot;C&quot;: records.remove(records.size()-1); break; default: records.add(Integer.parseInt(op)); &#125; &#125; for (int record : records)&#123; ans += record; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"}]},{"title":"994. Rotting Oranges","slug":"994-Rotting-Oranges","date":"2022-04-10T09:58:27.000Z","updated":"2022-04-10T09:58:27.818Z","comments":true,"path":"2022/04/10/994-Rotting-Oranges/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/994-Rotting-Oranges/","excerpt":"","text":"问题You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. 由于腐烂的橘子每次都只能影响周围的橘子，因此采用BFS。将所有腐烂的橘子加入队列。如果没有新鲜的橘子，则返回0。每次出队列，如果周围有新鲜的橘子存在，则将新鲜的橘子替换为腐烂并加入队列。每个level结束后，time+1。 最后遍历一遍，如果还有新鲜的橘子，返回-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public int orangesRotting(int[][] grid) &#123; Queue&lt;Integer&gt; q = new LinkedList(); int row = grid.length; int col = grid[0].length; int fresh = 0; for (int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if ( grid[i][j] == 2)&#123; q.add(i * col + j); &#125; else if (grid[i][j] == 1)&#123; fresh++; &#125; &#125; &#125; if(fresh == 0)&#123;return 0;&#125; int count = q.size()-1; int temp = 0; int time = -1; while(!q.isEmpty())&#123; int i = q.peek() / col; int j = q.poll() % col; if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == 1)&#123; grid[i-1][j] = 2; q.add((i-1)*col+j); temp++; &#125; if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == 1)&#123; grid[i][j-1] = 2; q.add(i*col+(j-1)); temp++; &#125; if(i+1&lt;row &amp;&amp; grid[i+1][j] == 1)&#123; grid[i+1][j] = 2; q.add((i+1)*col+j); temp++; &#125; if(j+1&lt;col &amp;&amp; grid[i][j+1] == 1)&#123; grid[i][j+1] = 2; q.add(i*col+(j+1)); temp++; &#125; if(count == 0)&#123; count = temp; temp = 0; time++; &#125; count--; &#125; for (int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if ( grid[i][j] == 1)&#123; return -1; &#125; &#125; &#125; return time; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"}]},{"title":"542. 01 Matrix","slug":"542-01-Matrix","date":"2022-04-10T09:13:25.000Z","updated":"2022-04-10T09:13:25.756Z","comments":true,"path":"2022/04/10/542-01-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/542-01-Matrix/","excerpt":"","text":"问题Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.The distance between two adjacent cells is 1. 由于是搜索最近的距离，因此可以采用BFS搜索。首先创建一个距离矩阵，将所有原矩阵为0的位置填上距离0，将其他位置填上无穷大。使用BFS搜索，将所有0的坐标放入队列。取出队列头元素，将其周围的距离矩阵的元素与自身距离矩阵的元素+1比较，将较小的值设置在周围的距离矩阵上。同时，将改变数值的坐标再次放入队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123; public int[][] updateMatrix(int[][] mat) &#123; Queue&lt;Integer&gt; q = new LinkedList(); int row = mat.length; int col = mat[0].length; int[][] ans = new int[row][col]; for ( int i = 0; i &lt; row; i++ )&#123; for (int j = 0; j &lt; col; j++)&#123; if (mat[i][j] == 0)&#123; ans[i][j] = 0; q.add(i*col + j); &#125; else&#123; ans[i][j] = Integer.MAX_VALUE; &#125; &#125; &#125; while(!q.isEmpty())&#123; int i = q.peek() / col; int j = q.poll() % col; if(i-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i-1][j])&#123; ans[i-1][j] = ans[i][j]+1; q.add((i-1)*col + j); &#125; if(i+1 &lt; row &amp;&amp; ans[i][j]+1 &lt; ans[i+1][j])&#123; ans[i+1][j] = ans[i][j]+1; q.add((i+1)*col + j); &#125; if(j-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i][j-1])&#123; ans[i][j-1] = ans[i][j]+1; q.add(i*col + (j-1)); &#125; if(j+1 &lt; col &amp;&amp; ans[i][j]+1 &lt; ans[i][j+1])&#123; ans[i][j+1] = ans[i][j]+1; q.add(i*col + (j+1)); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"}]},{"title":"116. Populating Next Right Pointers in Each Node","slug":"116-Populating-Next-Right-Pointers-in-Each-Node","date":"2022-04-10T06:29:14.000Z","updated":"2022-04-10T06:29:14.640Z","comments":true,"path":"2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/","excerpt":"","text":"问题You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456 struct Node &#123; int val; Node *left; Node *right; Node *next;&gt;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 递归，当root为null时返回。如果root有右节点，则左节点next指向右节点。如果root有右节点同时next已经指向了一个节点，则将其右节点next指向该节点的左子节点。递归左右子节点，并返回root。 1234567891011121314151617181920212223242526272829303132333435363738/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root==null)&#123;return root;&#125; if (root.right!=null)&#123; root.left.next = root.right; if (root.next!=null)&#123; root.right.next = root.next.left; &#125; &#125; connect(root.left); connect(root.right); return root; &#125;&#125; BFS搜索每一个节点，将节点指向队列中next下一个节点。当计数器达到2的指数时，将节点指向null。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return root; &#125; int count = 1; Queue&lt;Node&gt; q = new LinkedList(); q.offer(root); while (!q.isEmpty())&#123; count++; Node curr = q.poll(); if ( isPow(count) )&#123; curr.next = null; &#125; else&#123; curr.next = q.peek(); &#125; if(curr.left!=null)&#123; q.add(curr.left); &#125; if(curr.right!=null)&#123; q.add(curr.right); &#125; &#125; return root; &#125; private boolean isPow(int val)&#123; if(val == 0 || val == 1)&#123; return false; &#125; while ( val % 2 == 0 )&#123; val = val / 2; &#125; if (val == 1)&#123; return true; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"20. Valid Parentheses","slug":"20-Valid-Parentheses","date":"2022-04-10T03:19:50.000Z","updated":"2022-04-10T03:19:50.707Z","comments":true,"path":"2022/04/10/20-Valid-Parentheses/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/20-Valid-Parentheses/","excerpt":"","text":"问题Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 用栈储存遍历中的字符。如果是“（”，“{”或“[”，则入栈。如果是其他字符，且不与栈顶的字符成对，则返回false。其他情况需要pop掉栈顶。 toCharArray(): 将字符串转换为字符数组，便于遍历。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack(); for (char c : s.toCharArray())&#123; if ( c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27; )&#123; stack.push(c); &#125; else if ( stack.size() == 0 || c == &#x27;)&#x27; &amp;&amp; stack.peek() != &#x27;(&#x27; || c == &#x27;&#125;&#x27; &amp;&amp; stack.peek() != &#x27;&#123;&#x27; || c == &#x27;]&#x27; &amp;&amp; stack.peek() != &#x27;[&#x27;) &#123; return false; &#125; else&#123; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"}]},{"title":"617. Merge Two Binary Trees","slug":"617-Merge-Two-Binary-Trees","date":"2022-04-10T01:39:03.000Z","updated":"2022-04-20T11:32:59.851Z","comments":true,"path":"2022/04/10/617-Merge-Two-Binary-Trees/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/617-Merge-Two-Binary-Trees/","excerpt":"","text":"问题You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. 递归。将root1和root2合并到root1。如果一个节点为null，则返回另一个节点。否则root1的值为root1 + root2的值。root1.left递归root1和root2的left。root2.right递归root1和root2的right。返回root1。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if( root1 == null )&#123; return root2; &#125; if( root2 == null )&#123; return root1; &#125; root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"}]},{"title":"83. Remove Duplicates from Sorted List","slug":"83-Remove-Duplicates-from-Sorted-List","date":"2022-04-10T00:38:58.000Z","updated":"2022-04-10T00:41:06.849Z","comments":true,"path":"2022/04/10/83-Remove-Duplicates-from-Sorted-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/83-Remove-Duplicates-from-Sorted-List/","excerpt":"","text":"问题Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 设置前一个节点和当前节点两个指针。由于是有数的链表，遍历时可以直接比较两个节点。如相等则前一个节点的next指向当前节点的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if ( head == null)&#123; return head; &#125; if ( head.next == null)&#123; return head; &#125; ListNode prev = head; ListNode curr = head.next; while(curr != null)&#123; if(prev.val != curr.val)&#123; curr = curr.next; prev = prev.next; &#125; else&#123; prev.next = curr.next; curr = curr.next; &#125; &#125; return head; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"695. Max Area of Island","slug":"695-Max-Area-of-Island","date":"2022-04-10T00:03:12.000Z","updated":"2022-04-10T00:20:50.087Z","comments":true,"path":"2022/04/10/695-Max-Area-of-Island/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/695-Max-Area-of-Island/","excerpt":"","text":"问题You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. DFS, 遍历每个等于1的地图块。递归周围四个地图块，当超越数组范围时返回0。进行搜索时将搜索过的地图块设为0。否则运行BFS时将全局变量count增加。执行完毕后BFS时将全局变量count清零。 count计算的是BFS执行的次数 12345678910111213141516171819202122232425262728293031class Solution &#123; int count = 0; public int maxAreaOfIsland(int[][] grid) &#123; int best = 0; for(int i = 0; i &lt; grid.length ; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if ( grid[i][j] == 1 )&#123; best = Math.max(best, dfs(grid,i,j)); count = 0; &#125; &#125; &#125; return best; &#125; private int dfs(int[][] grid, int i, int j)&#123; if((i &lt; 0 || i &gt; grid.length -1) || (j &lt; 0 || j &gt; grid[0].length -1 ) || grid[i][j] == 0)&#123; return 0; &#125; grid[i][j] = 0; count++; dfs(grid,i-1,j); dfs(grid,i,j-1); dfs(grid,i+1,j); dfs(grid,i,j+1); return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"}]},{"title":"347. Top K Frequent Elements","slug":"347-Top-K-Frequent-Elements","date":"2022-04-09T23:39:16.000Z","updated":"2022-04-20T11:36:30.188Z","comments":true,"path":"2022/04/10/347-Top-K-Frequent-Elements/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/347-Top-K-Frequent-Elements/","excerpt":"","text":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. 遍历，使用哈希表保存遍历次数。再次遍历，根据元素出现的次数将其填入大根堆。遍历取出k个最大值。 getOrDefault()：方便的遍历并生成哈希表。 lambda： （）内表示传入的数值。-&gt; 后表示返回值。 1234567891011121314151617class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; int[] ans = new int[k]; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for (int num : nums)&#123; map.put( num, map.getOrDefault(num , 0) + 1 ); &#125; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue((a,b) -&gt; map.get(b) - map.get(a)); for (int key : map.keySet())&#123; pq.add(key); &#125; for (int i = 0; i &lt; k ; i++)&#123; ans[i] = pq.poll(); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"}]},{"title":"206. Reverse Linked List","slug":"206-Reverse-Linked-List","date":"2022-04-09T19:49:54.000Z","updated":"2022-04-09T19:49:54.819Z","comments":true,"path":"2022/04/10/206-Reverse-Linked-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/206-Reverse-Linked-List/","excerpt":"","text":"问题Given the head of a singly linked list, reverse the list, and return the reversed list. 翻转列表，当链表长度不足时，直接返回原链表。将头元素设置到preNode，同时将其next设置为null，作为新链表的尾。将其余的元素设置到curNode。 当当前节点不为null时遍历： 将curNode的next保存在temp。 将curNode的next指向preNode，作为preNode的上一个节点。 将preNode指向curNode，完成交换。 将curNode指向temp，curNode变为原来的curNode的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if( head == null )&#123; //if not enough, return head return head; &#125; if ( head.next == null )&#123; return head; &#125; ListNode preNode = head; //set head to preNode, it will be the last node in the end ListNode curNode = head.next; //curNode move to next preNode.next = null; //only preserve one head node ListNode temp; while( curNode != null )&#123; temp = curNode.next; //preserve nodes after curNode curNode.next = preNode; //cur -&gt; pre preNode = curNode; //set back reversed list to preNode curNode = temp; //put back preserved nodes, curNode move to the next &#125; return preNode; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"203. Remove Linked List Elements","slug":"203-Remove-Linked-List-Elements","date":"2022-04-09T02:39:09.000Z","updated":"2022-04-09T02:39:09.603Z","comments":true,"path":"2022/04/09/203-Remove-Linked-List-Elements/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/203-Remove-Linked-List-Elements/","excerpt":"","text":"问题Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head. 设置哨兵节点，将其next指向头部。设置前节点，将其指向哨兵节点。设置尾部节点，并指向头部。移动当前节点尾部，如尾部的val等于需要删去的val，则将前节点的next指向尾部的next。尾部的next如为null，则前节点的next指向null。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null)&#123; return head; &#125; ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode preNode = dummyHead; ListNode tail = dummyHead.next; while( tail != null )&#123; if ( tail.next == null &amp;&amp; tail.val == val )&#123; preNode.next = null; break; &#125; else if (tail.val == val)&#123; preNode.next = tail.next; tail = preNode.next; &#125; else&#123; preNode = preNode.next; tail = tail.next; &#125; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"733. Flood Fill","slug":"733-Flood-Fill","date":"2022-04-09T01:13:45.000Z","updated":"2022-04-20T11:33:23.359Z","comments":true,"path":"2022/04/09/733-Flood-Fill/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/733-Flood-Fill/","excerpt":"","text":"答案An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. Return the modified image after performing the flood fill. 深度优先搜索。如果当前像素颜色等于最初的颜色，则变更为新颜色。然后继续递归四个周围的像素。 1234567891011121314151617181920212223242526272829class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; int oldColor = image[sr][sc]; if (oldColor != newColor)&#123; dfs(image,sr,sc,oldColor,newColor); &#125; return image; &#125; private void dfs(int[][] image, int r, int c, int oldColor, int newColor)&#123; if (image[r][c] == oldColor)&#123; image[r][c] = newColor; if (r&gt;=1)&#123; dfs(image,r-1,c,oldColor,newColor); &#125; if (c&gt;=1)&#123; dfs(image,r,c-1,oldColor,newColor); &#125; if (r&lt;image.length-1)&#123; dfs(image,r+1,c,oldColor,newColor); &#125; if (c&lt;image[0].length-1)&#123; dfs(image,r,c+1,oldColor,newColor); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"21. Merge Two Sorted Lists","slug":"21-Merge-Two-Sorted-Lists","date":"2022-04-09T00:19:16.000Z","updated":"2022-04-20T11:33:50.289Z","comments":true,"path":"2022/04/09/21-Merge-Two-Sorted-Lists/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/21-Merge-Two-Sorted-Lists/","excerpt":"","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 先设置空的哨兵节点，然后将尾部指针指向这个节点。遍历两个链表，将尾部节点的下一个值指向两个节点中值较小的一个。然后将指针移动到下一个值。最后返回哨兵节点的下一个节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode dummyHead = new ListNode(); ListNode tail = dummyHead; while ( list1 != null &amp;&amp; list2 !=null )&#123; if (list1.val &lt; list2.val)&#123; tail.next = list1; list1 = list1.next; tail = tail.next; &#125; else&#123; tail.next = list2; list2 = list2.next; tail = tail.next; &#125; &#125; if ( list1 == null)&#123; tail.next = list2; &#125; else &#123; tail.next = list1; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"141. Linked List Cycle","slug":"141-Linked-List-Cycle","date":"2022-04-08T21:24:04.000Z","updated":"2022-04-08T21:24:52.458Z","comments":true,"path":"2022/04/09/141-Linked-List-Cycle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/141-Linked-List-Cycle/","excerpt":"","text":"问题Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. 遍历并移动快慢指针。如两个指针最终相遇，则链表中有循环。如快指针移动到链表尾部，则链表无循环。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; if ( head == null)&#123; return false; &#125; else if ( fast.next == null)&#123; return false; &#125; while( fast != null &amp;&amp; fast.next != null )&#123; slow = slow.next; fast = fast.next.next; if (slow == fast)&#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"703. Kth Largest Element in a Stream","slug":"703-Kth-Largest-Element-in-a-Stream","date":"2022-04-08T20:06:37.000Z","updated":"2022-04-08T20:06:37.916Z","comments":true,"path":"2022/04/09/703-Kth-Largest-Element-in-a-Stream/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/703-Kth-Largest-Element-in-a-Stream/","excerpt":"","text":"问题Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. 优先级队列，插入所有元素，小元素在前。当队列长度大于k时，poll掉前面的元素。 12345678910111213141516171819202122232425class KthLargest &#123; PriorityQueue&lt;Integer&gt; pq; int kth; public KthLargest(int k, int[] nums) &#123; pq = new PriorityQueue&lt;Integer&gt;(); kth = k; for (int num : nums)&#123; pq.add(num); &#125; &#125; public int add(int val) &#123; pq.add(val); while (pq.size() &gt; kth)&#123; pq.poll(); &#125; return pq.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"}]},{"title":"242. Valid Anagram","slug":"242-Valid-Anagram","date":"2022-04-07T06:40:19.000Z","updated":"2022-04-07T06:40:19.263Z","comments":true,"path":"2022/04/07/242-Valid-Anagram/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/242-Valid-Anagram/","excerpt":"","text":"问题Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 两数组相等时，直接遍历两个数组并记录各个字符出现的数量。一个数组遍历时用做加法，另一个做减法。如果最后每个字符出现的数量均为0，则返回真。 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length()!=t.length())&#123; return false; &#125; int[] dic = new int[26]; for (int i = 0; i &lt; s.length(); i++)&#123; dic[s.charAt(i)-&#x27;a&#x27;]++; dic[t.charAt(i)-&#x27;a&#x27;]--; &#125; for(int num : dic)&#123; if ( num != 0 )&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[]},{"title":"567. Permutation in String","slug":"567-Permutation-in-String","date":"2022-04-07T06:28:20.000Z","updated":"2022-04-20T11:34:20.582Z","comments":true,"path":"2022/04/07/567-Permutation-in-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/567-Permutation-in-String/","excerpt":"","text":"问题Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2. 将要查找的组合加入数组，数值为字符出现的次数。滑动窗口，入窗口对应的元素数值-1，出窗口对应的元素数值+1。每次移动窗口都检验一次数组的数值是否全部为0，如果是真，则返回真。小技巧：直接用数组来记录字符出现的次数，用字符减去与’a’的差作为下标。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1.length() &gt; s2.length())&#123; return false; &#125; int[] dic = new int[26]; for (int i = 0; i &lt; s1.length(); i++)&#123; dic[s1.charAt(i)-&#x27;a&#x27;]++; dic[s2.charAt(i)-&#x27;a&#x27;]--; &#125; int i = 0; int j = s1.length(); while( j &lt; s2.length() )&#123; if ( allZero(dic) )&#123; return true; &#125; dic[s2.charAt(i)-&#x27;a&#x27;]++; dic[s2.charAt(j)-&#x27;a&#x27;]--; i++; j++; &#125; return allZero(dic); &#125; private boolean allZero(int[] dic)&#123; for (int num : dic)&#123; if ( num != 0 )&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"Permutation","slug":"Permutation","permalink":"https://xuanhe95.github.io/tags/Permutation/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"3-Longest-Substring-Without-Repeating-Characters","date":"2022-04-07T05:50:40.000Z","updated":"2022-04-20T11:34:51.695Z","comments":true,"path":"2022/04/07/3-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/3-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"问题Given a string s, find the length of the longest substring without repeating characters. 滑动窗口，哈希表记录访问过的字符的元素。如果重复，则放弃前一个重复的字符，更新左指针。注意：只有在新指针大于现有指针时才更新！ 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int best = 0; int i = 0; int j = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); while ( j &lt; s.length() )&#123; char curChar = s.charAt(j); if ( !map.containsKey(curChar) )&#123; map.put( curChar, j ); &#125; else&#123; if ( map.get(curChar) + 1 &gt; i)&#123; i = map.get(curChar) + 1; &#125; map.put( curChar, j ); &#125; if ((j - i + 1) &gt; best)&#123; best = (j - i + 1); &#125; j++; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://xuanhe95.github.io/tags/Sliding-Window/"}]},{"title":"383. Ransom Note","slug":"383-Ransom-Note","date":"2022-04-07T05:02:15.000Z","updated":"2022-04-20T11:35:34.461Z","comments":true,"path":"2022/04/07/383-Ransom-Note/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/383-Ransom-Note/","excerpt":"","text":"Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. 哈希表，遍历添加字典及次数。然后遍历note，与字典中的字符数量作比较。 可以优化速度，采用数组记录所有英文字母的数量。 12345678910111213141516171819202122232425class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; HashMap&lt;Character, Integer&gt; dic = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; magazine.length(); i++)&#123; char curChar = magazine.charAt(i); if (!dic.containsKey(curChar))&#123; dic.put(curChar, 1); &#125; else&#123; dic.put(curChar, dic.get(curChar)+1); &#125; &#125; for (int i = 0; i &lt; ransomNote.length(); i++)&#123; char curChar = ransomNote.charAt(i); if (dic.containsKey(curChar) &amp;&amp; dic.get(curChar) &gt; 0)&#123; dic.put(curChar, dic.get(curChar)-1); &#125; else&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"387. First Unique Character in a String","slug":"387-First-Unique-Character-in-a-String","date":"2022-04-07T04:48:17.000Z","updated":"2022-04-20T11:35:51.476Z","comments":true,"path":"2022/04/07/387-First-Unique-Character-in-a-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/387-First-Unique-Character-in-a-String/","excerpt":"","text":"问题Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. 遍历，建立哈希表，记录出现次数。再次遍历，如果出现次数为1，则返回下标。 1234567891011121314151617181920212223class Solution &#123; public int firstUniqChar(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for ( int i = 0; i &lt; s.length(); i++ )&#123; char curChar = s.charAt(i); if ( !map.containsKey(curChar) )&#123; map.put(curChar, 1); &#125; else&#123; map.put(curChar, map.get(curChar)+1); &#125; &#125; for ( int i = 0; i &lt; s.length(); i++ )&#123; char curChar = s.charAt(i); if ( map.get(curChar) == 1 )&#123; return i; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"1046. Last Stone Weight","slug":"1046-Last-Stone-Weight","date":"2022-04-07T04:09:40.000Z","updated":"2022-04-20T11:36:47.625Z","comments":true,"path":"2022/04/07/1046-Last-Stone-Weight/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/1046-Last-Stone-Weight/","excerpt":"","text":"问题You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;&#x3D; y. The result of this smash is: If x &#x3D;&#x3D; y, both stones are destroyed, and If x !&#x3D; y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0. 采用PriorityQueue队列，将所有元素放入。每次取出两个，将两者的差值放回队列。 12345678910111213141516class Solution &#123; public int lastStoneWeight(int[] stones) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for (int stone : stones)&#123; pq.add(stone); &#125; while ( pq.size() &gt; 1) &#123; int largeStone = pq.poll(); int smallStone = pq.poll(); pq.add( largeStone - smallStone ); &#125; return pq.poll(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"}]},{"title":"680. Valid Palindrome II","slug":"680-Valid-Palindrome-II","date":"2022-04-07T00:37:01.000Z","updated":"2022-04-20T11:37:19.492Z","comments":true,"path":"2022/04/07/680-Valid-Palindrome-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/680-Valid-Palindrome-II/","excerpt":"","text":"问题Given a string s, return true if the s can be palindrome after deleting at most one character from it. 双指针，字符串两边对比。如果两边字符不相等，则更新两边指针，并分别传入辅助方法再次对比。两个结果有一个是true则返回true。 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0; int right = s.length() - 1; while (left &lt; right)&#123; if (s.charAt(left) == s.charAt(right) )&#123; left++; right--; &#125; else&#123; return ( checkPalindrome(s, left+1, right) || checkPalindrome(s, left, right-1)); &#125; &#125; return true; &#125; private boolean checkPalindrome(String s, int left, int right)&#123; while (left &lt; right)&#123; if (s.charAt(left)==s.charAt(right))&#123; left++; right--; &#125; else&#123; return false; &#125; &#125; return true; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"}]},{"title":"19. Remove Nth Node From End of List","slug":"19-Remove-Nth-Node-From-End-of-List","date":"2022-04-06T20:18:11.000Z","updated":"2022-04-20T11:37:06.424Z","comments":true,"path":"2022/04/07/19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/19-Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"问题Given the head of a linked list, remove the nth node from the end of the list and return its head. 双指针，同时记录前n个节点和当前节点。当前指针到链表尾部时，删除前面的指针，注意处理edge cases。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode preNode = null; ListNode removedNode = head; ListNode fastNode = head; for ( int i = 0; i &lt; n; i++ )&#123; fastNode = fastNode.next; &#125; while ( fastNode != null )&#123; fastNode = fastNode.next; preNode = removedNode; removedNode = removedNode.next; &#125; if ( removedNode == head )&#123; head = head.next; &#125; else if ( removedNode.next == null)&#123; preNode.next = null; &#125; else&#123; preNode.next = removedNode.next; &#125; return head; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"876. Middle of the Linked List","slug":"876-Middle-of-the-Linked-List","date":"2022-04-06T19:53:17.000Z","updated":"2022-04-08T21:27:14.358Z","comments":true,"path":"2022/04/07/876-Middle-of-the-Linked-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/876-Middle-of-the-Linked-List/","excerpt":"","text":"问题Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 快慢指针，两个指针不同速度遍历链表。当快指针达到链表尾部时候，慢指针正好在中间。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode slowNode = head; ListNode fastNode = head; while( fastNode != null )&#123; fastNode = fastNode.next; if (fastNode == null)&#123; return slowNode; &#125; slowNode = slowNode.next; fastNode = fastNode.next; &#125; return slowNode; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"74. Search a 2D Matrix","slug":"74-Search-a-2D-Matrix","date":"2022-04-06T19:51:13.000Z","updated":"2022-04-19T01:31:59.343Z","comments":true,"path":"2022/04/07/74-Search-a-2D-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/74-Search-a-2D-Matrix/","excerpt":"","text":"问题Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 二分搜索，以整个数组尺寸作为搜索范围。每次搜索中间值，如等于target则返回。 123456789101112131415161718192021class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int left = 0; int right = (matrix.length * matrix[0].length) - 1; while(left &lt;= right)&#123; int mid = left + (right - left)/2; int row = mid / matrix[0].length; int col = mid % matrix[0].length; if(matrix[row][col] == target)&#123; return true; &#125; else if(matrix[row][col] &gt; target)&#123; right = mid - 1; &#125; else&#123; left = mid + 1; &#125; &#125; return false; &#125;&#125; 双指针，先搜索到合适的行。再搜索到合适的列。 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0; int j = 0; while(i &lt; matrix.length)&#123; if(matrix[i][0] == target)&#123; return true; &#125; else if(matrix[i][0] &lt; target)&#123; i++; &#125; else&#123; break; &#125; &#125; if( i == 0 )&#123; return false; &#125; i--; while(j &lt; matrix[0].length)&#123; if(matrix[i][j] == target)&#123; return true; &#125; j++; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"}]},{"title":"36. Valid Sudoku","slug":"36-Valid-Sudoku","date":"2022-04-06T19:08:49.000Z","updated":"2022-04-06T19:08:49.845Z","comments":true,"path":"2022/04/07/36-Valid-Sudoku/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/36-Valid-Sudoku/","excerpt":"","text":"问题Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. 遍历并创建三组不同的哈希表，每个表内包含一组哈希集合。如果访问的元素已在哈希集合内，则返回false 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; rowMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; colMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; blockMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); for (int i = 0; i &lt; board[0].length; i++ )&#123; for (int j = 0; j &lt; board.length; j++ )&#123; char curChar = board[i][j]; if (curChar == &#x27;.&#x27;)&#123; continue; &#125; if (!rowMap.containsKey(i))&#123; rowMap.put(i, new HashSet&lt;Character&gt;()); &#125; if (!colMap.containsKey(j))&#123; colMap.put(j, new HashSet&lt;Character&gt;()); &#125; if (!blockMap.containsKey(j/3*3+i/3))&#123; blockMap.put(j/3*3+i/3, new HashSet&lt;Character&gt;()); &#125; HashSet&lt;Character&gt; curRow = rowMap.get(i); HashSet&lt;Character&gt; curCol = colMap.get(j); HashSet&lt;Character&gt; curBlock = blockMap.get(j/3*3+i/3); if ( !curRow.contains(curChar) &amp;&amp; !curCol.contains(curChar) &amp;&amp; !curBlock.contains(curChar) )&#123; curRow.add(curChar); curCol.add(curChar); curBlock.add(curChar); &#125; else&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"923. 3Sum With Multiplicity","slug":"923-3Sum-With-Multiplicity","date":"2022-04-06T18:27:00.000Z","updated":"2022-04-20T11:38:02.731Z","comments":true,"path":"2022/04/07/923-3Sum-With-Multiplicity/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/923-3Sum-With-Multiplicity/","excerpt":"","text":"Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] &#x3D;&#x3D; target. As the answer can be very large, return it modulo 109 + 7. 首先遍历元素，根据元素的值和出现次数建立哈希表。然后再哈希表中选择三个元素，如果和等于target，则计算三个元素出现次数的乘积。最后除以重复计算的次数。由于数值较大，因此中途计算应该采用长整型long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int threeSumMulti(int[] arr, int target) &#123; //enumberate every element and put them into the map HashMap&lt;Integer, Long&gt; map = new HashMap&lt;Integer, Long&gt;(); long count = 0; for ( int num : arr )&#123; if (!map.containsKey(num))&#123; map.put(num, (long)1); &#125; else&#123; map.put(num, map.get(num)+1); &#125; &#125; //traverse whole elements and select three numbers for ( int a : map.keySet() )&#123; long totalA = map.get(a); for (int b : map.keySet())&#123; long totalB = map.get(b); if ( a == b )&#123; if (totalB &lt; 2)&#123; continue; &#125; totalB = totalB - 1; &#125; int c = target - a - b; if ( map.containsKey(c) )&#123; long totalC = map.get(c); long total = 0; if ( a == b &amp;&amp; b == c )&#123; total = totalA * totalB * ( totalC - 2 ) ; &#125; else if ( b == c || a == c )&#123; total = totalA * totalB * ( totalC - 1 ) ; &#125; else&#123; total = totalA * totalB * totalC; &#125; if ( total &gt; 0 )&#123; count += total; &#125; &#125; &#125; &#125; count/=6; int ans = (int) (count % 1000000007); return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"118. Pascal's Triangle","slug":"118-Pascal-s-Triangle","date":"2022-04-05T18:53:43.000Z","updated":"2022-04-20T11:38:36.899Z","comments":true,"path":"2022/04/06/118-Pascal-s-Triangle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/118-Pascal-s-Triangle/","excerpt":"","text":"Given an integer numRows, return the first numRows of Pascal’s triangle. 动态规划，直接按照杨辉三角形的定义计算。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows); for (int i = 0; i &lt; numRows ; i++)&#123; List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(i+1); for (int j = 0; j &lt;= i; j++)&#123; if ( j == 0 || j == i )&#123; arr.add(1); &#125; else&#123; arr.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j)); &#125; &#125; ans.add(arr); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"11. Container With Most Water","slug":"11-Container-With-Most-Water","date":"2022-04-05T16:50:01.000Z","updated":"2022-04-05T19:03:02.604Z","comments":true,"path":"2022/04/06/11-Container-With-Most-Water/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/11-Container-With-Most-Water/","excerpt":"","text":"问题You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. 双指针在首尾，二者容量取决于两者中较小的一个。贪心算法，保留两个指针上较大的元素，移动较小一边的指针。由于指针移动时距离只会减小，因此当新的元素比上一个更大时才有可能比之前的容量更大。遍历一次找到最大容量。时间复杂度：O(n) 感觉这个移动有点博弈论的味了，每次都移动自己最差的一边，虽然可能变得更差，但是总比不动（或者减小）强，动最差的部分可能找到更好的结果，但是动另一边总会更差或者不变，兄弟们，这不是题，这是人生，逃离舒适圈！！（这解释我觉得无敌了，哈哈哈） 12345678910111213141516171819202122232425class Solution &#123; public int maxArea(int[] height) &#123; int best = 0; int i = 0; int j = height.length - 1; while ( i &lt; j )&#123; int product = 0; if (height[i] &lt; height[j])&#123; product = height[i] * ( j -i ); i++; &#125; else&#123; product = height[j] * ( j -i ); j--; &#125; if ( product &gt; best)&#123; best = product; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"344. Reverse String","slug":"344-Reverse-String","date":"2022-04-05T13:56:14.000Z","updated":"2022-04-05T19:06:30.027Z","comments":true,"path":"2022/04/05/344-Reverse-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/344-Reverse-String/","excerpt":"","text":"问题简述Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. 双指针，同时更新并交换两个数值。 12345678910111213141516class Solution &#123; public void reverseString(char[] s) &#123; int i = 0; int j = s.length - 1; while( i &lt; j ) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"167. Two Sum II - Input Array Is Sorted","slug":"167-Two-Sum-II-Input-Array-Is-Sorted","date":"2022-04-05T05:52:45.000Z","updated":"2022-04-05T19:05:47.624Z","comments":true,"path":"2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","excerpt":"","text":"问题描述Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 由于是有序数列，因此可以采用双指针。左右两侧和不等于目标时，根据大小结果移动左右指针。 123456789101112131415161718192021222324class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int i = 0; int j = numbers.length - 1; int[] ans = new int[2]; while( i &lt; j )&#123; int diff = target - numbers[j]; if ( diff == numbers[i])&#123; ans[0] = i+1; ans[1] = j+1; return ans; &#125; else if ( diff &lt; numbers[i] ) &#123; j--; &#125; else&#123; i++; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"566. Reshape the Matrix","slug":"566-Reshape-the-Matrix","date":"2022-04-05T04:40:01.000Z","updated":"2022-04-20T11:39:20.577Z","comments":true,"path":"2022/04/05/566-Reshape-the-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/566-Reshape-the-Matrix/","excerpt":"","text":"问题概述In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. 根据数组的数学公式得出其位置，一次遍历将原数组中的数字填入。O(r*c) 1234567891011121314151617181920212223class Solution &#123; public int[][] matrixReshape(int[][] mat, int r, int c) &#123; int[][] ans = new int[r][c]; int oldR = mat.length; int oldC = mat[0].length; if ( oldR * oldC != r * c )&#123; return mat; &#125; for (int i = 0; i &lt; r*c ; i++ )&#123; int m = i/oldC; int n = i%oldC; int p = i/c; int q = i%c; ans[p][q] = mat[m][n]; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"}]},{"title":"283. Move Zeroes","slug":"283-Move-Zeroes","date":"2022-04-04T18:11:56.000Z","updated":"2022-04-10T23:11:57.492Z","comments":true,"path":"2022/04/05/283-Move-Zeroes/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/283-Move-Zeroes/","excerpt":"","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int j = 0; while ( j &lt; nums.length )&#123; if ( nums[j] != 0 )&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; &#125; j++; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"121-Best-Time-to-Buy-and-Sell-Stock","date":"2022-04-04T17:50:49.000Z","updated":"2022-04-10T23:11:49.674Z","comments":true,"path":"2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","excerpt":"","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ )&#123; difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] )&#123; difference[i] = difference[i] + difference[i - 1]; &#125; if (difference[i] &gt; best)&#123; best = difference[i]; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"350. Intersection of Two Arrays II","slug":"350-Intersection-of-Two-Arrays-II","date":"2022-04-04T12:42:40.000Z","updated":"2022-04-10T23:11:36.836Z","comments":true,"path":"2022/04/04/350-Intersection-of-Two-Arrays-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/350-Intersection-of-Two-Arrays-II/","excerpt":"","text":"问题描述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ )&#123; if (!map.containsKey(nums1[i]))&#123; map.put(nums1[i],1); &#125; else&#123; map.put(nums1[i],map.get(nums1[i])+1); &#125; &#125; for ( int i = 0 ; i &lt; nums2.length ; i++ )&#123; if (map.containsKey(nums2[i]))&#123; if (map.get(nums2[i]) &gt; 0)&#123; count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); &#125; &#125; &#125; int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++)&#123; ans[i] = arr.get(i); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"31. Next Permutation","slug":"31-Next-Permutation","date":"2022-04-03T20:11:22.000Z","updated":"2022-04-20T11:40:38.965Z","comments":true,"path":"2022/04/04/31-Next-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/31-Next-Permutation/","excerpt":"","text":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr &#x3D; [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr &#x3D; [1,2,3] is [1,3,2].Similarly, the next permutation of arr &#x3D; [2,3,1] is [3,1,2].While the next permutation of arr &#x3D; [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public void nextPermutation(int[] nums) &#123; int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1)&#123; int i = nums.length -2; while (i &gt;= 0)&#123; if (nums[i + 1] &lt;= nums[i]) &#123; //从尾部开始，比较元素是否是大到小 i--; continue; &#125; else &#123; //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--)&#123; if (nums[j] &lt;= nums[i])&#123; continue; &#125; int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; &#125; break; &#125; &#125; if (flag == 0 )&#123; //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Permutation","slug":"Permutation","permalink":"https://xuanhe95.github.io/tags/Permutation/"}]},{"title":"88. Merge Sorted Array","slug":"88-Merge-Sorted-Array","date":"2022-04-03T15:26:40.000Z","updated":"2022-04-20T11:41:16.205Z","comments":true,"path":"2022/04/03/88-Merge-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/88-Merge-Sorted-Array/","excerpt":"","text":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) &#123; if ( nums1[i] &lt; nums2[j] )&#123; nums1[k] = nums2[j]; j--; k--; &#125; else &#123; nums1[k] = nums1[i]; i--; k--; &#125; &#125; if ( i &lt; 0 )&#123; while ( j &gt;= 0 )&#123; nums1[k] = nums2[j]; j--; k--; &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"}]},{"title":"1. Two Sum","slug":"1-Two-Sum","date":"2022-04-03T14:35:42.000Z","updated":"2022-04-20T11:41:47.475Z","comments":true,"path":"2022/04/03/1-Two-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/1-Two-Sum/","excerpt":"","text":"问题描述Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int result = target - nums[i]; if ( map.containsKey(result) )&#123; ans[0] = map.get(result); ans[1] = i; return ans; &#125; else&#123; map.put(nums[i], i); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2022-04-03T13:54:39.000Z","updated":"2022-04-20T11:42:57.673Z","comments":true,"path":"2022/04/03/189-Rotate-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/189-Rotate-Array/","excerpt":"","text":"Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution &#123; public void rotate(int[] nums, int k) &#123; if (k != 0)&#123; int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) &#123; int i = n + k; i %= nums.length; int temp = nums[n]; while( true )&#123; int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n)&#123; nums[n] = temp; break; &#125; &#125; &#125; &#125; &#125; private int gcd(int a, int b)&#123; int max = a; int min = b; if (max == min)&#123; return min; &#125; if ( a &lt; b )&#123; max = b; min = a; &#125; return gcd(max - min, min); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"977. Squares of a Sorted Array","slug":"977-Squares-of-a-Sorted-Array","date":"2022-04-03T13:35:19.000Z","updated":"2022-04-20T11:43:23.292Z","comments":true,"path":"2022/04/03/977-Squares-of-a-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/977-Squares-of-a-Sorted-Array/","excerpt":"","text":"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) &#123; if ( nums[left] &lt; 0 )&#123; if ( (-nums[left]) &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else &#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; else&#123; if ( nums[left] &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else&#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"测试一下","slug":"测试一下","date":"2022-03-30T14:26:17.000Z","updated":"2022-03-30T14:26:17.799Z","comments":true,"path":"2022/03/30/测试一下/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/","excerpt":"","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","categories":[],"tags":[]},{"title":"post title","slug":"post-title","date":"2022-03-30T12:22:27.000Z","updated":"2022-03-30T12:24:40.285Z","comments":true,"path":"2022/03/30/post-title/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/post-title/","excerpt":"","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-30T12:02:37.831Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/03/30/hello-world/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"},{"name":"Medium","slug":"Medium","permalink":"https://xuanhe95.github.io/categories/Medium/"},{"name":"Easy","slug":"Medium/Easy","permalink":"https://xuanhe95.github.io/categories/Medium/Easy/"},{"name":"复习","slug":"LeetCode/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/%E5%A4%8D%E4%B9%A0/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"Matrix","slug":"Matrix","permalink":"https://xuanhe95.github.io/tags/Matrix/"},{"name":"其他解法？","slug":"其他解法？","permalink":"https://xuanhe95.github.io/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://xuanhe95.github.io/tags/Binary-Search/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://xuanhe95.github.io/tags/Binary-Tree/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"String","slug":"String","permalink":"https://xuanhe95.github.io/tags/String/"},{"name":"Sort","slug":"Sort","permalink":"https://xuanhe95.github.io/tags/Sort/"},{"name":"intervals","slug":"intervals","permalink":"https://xuanhe95.github.io/tags/intervals/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Hash","slug":"Hash","permalink":"https://xuanhe95.github.io/tags/Hash/"},{"name":"Sliding Window","slug":"Sliding-Window","permalink":"https://xuanhe95.github.io/tags/Sliding-Window/"},{"name":"Array","slug":"Array","permalink":"https://xuanhe95.github.io/tags/Array/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"双向遍历","slug":"双向遍历","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"},{"name":"Queue","slug":"Queue","permalink":"https://xuanhe95.github.io/tags/Queue/"},{"name":"Renamed","slug":"Renamed","permalink":"https://xuanhe95.github.io/tags/Renamed/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"https://xuanhe95.github.io/tags/Bit-Manipulation/"},{"name":"掩码","slug":"掩码","permalink":"https://xuanhe95.github.io/tags/%E6%8E%A9%E7%A0%81/"},{"name":"算法","slug":"算法","permalink":"https://xuanhe95.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"投票算法","slug":"投票算法","permalink":"https://xuanhe95.github.io/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"},{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"Back Track","slug":"Back-Track","permalink":"https://xuanhe95.github.io/tags/Back-Track/"},{"name":"Permutation","slug":"Permutation","permalink":"https://xuanhe95.github.io/tags/Permutation/"},{"name":"Combination","slug":"Combination","permalink":"https://xuanhe95.github.io/tags/Combination/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"}]}