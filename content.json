{"meta":{"title":"XANDER Studio","subtitle":"Xander Studio","description":"Stay Foolish, Stay Hungery...","author":"Xuanhe","url":"https://xuanhe95.github.io","root":"/"},"pages":[],"posts":[{"title":"283. Move Zeroes","slug":"283-Move-Zeroes","date":"2022-04-04T18:11:56.000Z","updated":"2022-04-04T18:12:13.262Z","comments":true,"path":"2022/04/05/283-Move-Zeroes/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/283-Move-Zeroes/","excerpt":"","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int j = 0; while ( j &lt; nums.length )&#123; if ( nums[j] != 0 )&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; &#125; j++; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"121-Best-Time-to-Buy-and-Sell-Stock","date":"2022-04-04T17:50:49.000Z","updated":"2022-04-04T18:12:25.439Z","comments":true,"path":"2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","excerpt":"","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ )&#123; difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] )&#123; difference[i] = difference[i] + difference[i - 1]; &#125; if (difference[i] &gt; best)&#123; best = difference[i]; &#125; &#125; return best; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"350. Intersection of Two Arrays II","slug":"350-Intersection-of-Two-Arrays-II","date":"2022-04-04T12:42:40.000Z","updated":"2022-04-04T12:42:40.986Z","comments":true,"path":"2022/04/04/350-Intersection-of-Two-Arrays-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/350-Intersection-of-Two-Arrays-II/","excerpt":"","text":"问题简述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ )&#123; if (!map.containsKey(nums1[i]))&#123; map.put(nums1[i],1); &#125; else&#123; map.put(nums1[i],map.get(nums1[i])+1); &#125; &#125; for ( int i = 0 ; i &lt; nums2.length ; i++ )&#123; if (map.containsKey(nums2[i]))&#123; if (map.get(nums2[i]) &gt; 0)&#123; count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); &#125; &#125; &#125; int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++)&#123; ans[i] = arr.get(i); &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"31. Next Permutation","slug":"31-Next-Permutation","date":"2022-04-03T20:11:22.000Z","updated":"2022-04-03T20:11:22.496Z","comments":true,"path":"2022/04/04/31-Next-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/31-Next-Permutation/","excerpt":"","text":"问题描述A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr &#x3D; [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr &#x3D; [1,2,3] is [1,3,2].Similarly, the next permutation of arr &#x3D; [2,3,1] is [3,1,2].While the next permutation of arr &#x3D; [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public void nextPermutation(int[] nums) &#123; int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1)&#123; int i = nums.length -2; while (i &gt;= 0)&#123; if (nums[i + 1] &lt;= nums[i]) &#123; //从尾部开始，比较元素是否是大到小 i--; continue; &#125; else &#123; //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--)&#123; if (nums[j] &lt;= nums[i])&#123; continue; &#125; int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; &#125; break; &#125; &#125; if (flag == 0 )&#123; //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"}]},{"title":"88. Merge Sorted Array","slug":"88-Merge-Sorted-Array","date":"2022-04-03T15:26:40.000Z","updated":"2022-04-03T15:26:41.037Z","comments":true,"path":"2022/04/03/88-Merge-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/88-Merge-Sorted-Array/","excerpt":"","text":"问题概述You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) &#123; if ( nums1[i] &lt; nums2[j] )&#123; nums1[k] = nums2[j]; j--; k--; &#125; else &#123; nums1[k] = nums1[i]; i--; k--; &#125; &#125; if ( i &lt; 0 )&#123; while ( j &gt;= 0 )&#123; nums1[k] = nums2[j]; j--; k--; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"}]},{"title":"1. Two Sum","slug":"1-Two-Sum","date":"2022-04-03T14:35:42.000Z","updated":"2022-04-03T14:35:42.475Z","comments":true,"path":"2022/04/03/1-Two-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/1-Two-Sum/","excerpt":"","text":"问题描述Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int result = target - nums[i]; if ( map.containsKey(result) )&#123; ans[0] = map.get(result); ans[1] = i; return ans; &#125; else&#123; map.put(nums[i], i); &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2022-04-03T13:54:39.000Z","updated":"2022-04-03T20:11:53.553Z","comments":true,"path":"2022/04/03/189-Rotate-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/189-Rotate-Array/","excerpt":"","text":"问题描述Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution &#123; public void rotate(int[] nums, int k) &#123; if (k != 0)&#123; int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) &#123; int i = n + k; i %= nums.length; int temp = nums[n]; while( true )&#123; int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n)&#123; nums[n] = temp; break; &#125; &#125; &#125; &#125; &#125; private int gcd(int a, int b)&#123; int max = a; int min = b; if (max == min)&#123; return min; &#125; if ( a &lt; b )&#123; max = b; min = a; &#125; return gcd(max - min, min); &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"977. Squares of a Sorted Array","slug":"977-Squares-of-a-Sorted-Array","date":"2022-04-03T13:35:19.000Z","updated":"2022-04-03T13:35:48.407Z","comments":true,"path":"2022/04/03/977-Squares-of-a-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/977-Squares-of-a-Sorted-Array/","excerpt":"","text":"问题描述Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) &#123; if ( nums[left] &lt; 0 )&#123; if ( (-nums[left]) &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else &#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; else&#123; if ( nums[left] &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else&#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"测试一下","slug":"测试一下","date":"2022-03-30T14:26:17.000Z","updated":"2022-03-30T14:26:17.799Z","comments":true,"path":"2022/03/30/测试一下/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/","excerpt":"","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","categories":[],"tags":[]},{"title":"post title","slug":"post-title","date":"2022-03-30T12:22:27.000Z","updated":"2022-03-30T12:24:40.285Z","comments":true,"path":"2022/03/30/post-title/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/post-title/","excerpt":"","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-30T12:02:37.831Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/03/30/hello-world/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}