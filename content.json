{"meta":{"title":"XANDER Studio","subtitle":"Xander Studio","description":"Stay Foolish, Stay Hungery...","author":"Xuanhe","url":"https://xuanhe95.github.io","root":"/"},"pages":[],"posts":[{"title":"682. Baseball Game","slug":"682-Baseball-Game","date":"2022-04-10T18:04:38.000Z","updated":"2022-04-10T18:04:38.689Z","comments":true,"path":"2022/04/11/682-Baseball-Game/","link":"","permalink":"https://xuanhe95.github.io/2022/04/11/682-Baseball-Game/","excerpt":"","text":"问题You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds’ scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x.“+” - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores.“D” - Record a new score that is double the previous score. It is guaranteed there will always be a previous score.“C” - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score.Return the sum of all the scores on the record. 遍历选项，根据内容决定对ArrayList的操作。然后遍历将ArrayList加和，返回。 123456789101112131415161718192021222324252627class Solution &#123; public int calPoints(String[] ops) &#123; int ans = 0; List&lt;Integer&gt; records = new ArrayList(); for (String op : ops)&#123; switch(op)&#123; case &quot;+&quot;: records.add(records.get(records.size()-1)+records.get(records.size()-2)); break; case &quot;D&quot;: records.add(records.get(records.size()-1)*2); break; case &quot;C&quot;: records.remove(records.size()-1); break; default: records.add(Integer.parseInt(op)); &#125; &#125; for (int record : records)&#123; ans += record; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"994. Rotting Oranges","slug":"994-Rotting-Oranges","date":"2022-04-10T09:58:27.000Z","updated":"2022-04-10T09:58:27.818Z","comments":true,"path":"2022/04/10/994-Rotting-Oranges/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/994-Rotting-Oranges/","excerpt":"","text":"问题You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. 由于腐烂的橘子每次都只能影响周围的橘子，因此采用BFS。将所有腐烂的橘子加入队列。如果没有新鲜的橘子，则返回0。每次出队列，如果周围有新鲜的橘子存在，则将新鲜的橘子替换为腐烂并加入队列。每个level结束后，time+1。 最后遍历一遍，如果还有新鲜的橘子，返回-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123; public int orangesRotting(int[][] grid) &#123; Queue&lt;Integer&gt; q = new LinkedList(); int row = grid.length; int col = grid[0].length; int fresh = 0; for (int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if ( grid[i][j] == 2)&#123; q.add(i * col + j); &#125; else if (grid[i][j] == 1)&#123; fresh++; &#125; &#125; &#125; if(fresh == 0)&#123;return 0;&#125; int count = q.size()-1; int temp = 0; int time = -1; while(!q.isEmpty())&#123; int i = q.peek() / col; int j = q.poll() % col; if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == 1)&#123; grid[i-1][j] = 2; q.add((i-1)*col+j); temp++; &#125; if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == 1)&#123; grid[i][j-1] = 2; q.add(i*col+(j-1)); temp++; &#125; if(i+1&lt;row &amp;&amp; grid[i+1][j] == 1)&#123; grid[i+1][j] = 2; q.add((i+1)*col+j); temp++; &#125; if(j+1&lt;col &amp;&amp; grid[i][j+1] == 1)&#123; grid[i][j+1] = 2; q.add(i*col+(j+1)); temp++; &#125; if(count == 0)&#123; count = temp; temp = 0; time++; &#125; count--; &#125; for (int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if ( grid[i][j] == 1)&#123; return -1; &#125; &#125; &#125; return time; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"}]},{"title":"542. 01 Matrix","slug":"542-01-Matrix","date":"2022-04-10T09:13:25.000Z","updated":"2022-04-10T09:13:25.756Z","comments":true,"path":"2022/04/10/542-01-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/542-01-Matrix/","excerpt":"","text":"问题Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.The distance between two adjacent cells is 1. 由于是搜索最近的距离，因此可以采用BFS搜索。首先创建一个距离矩阵，将所有原矩阵为0的位置填上距离0，将其他位置填上无穷大。使用BFS搜索，将所有0的坐标放入队列。取出队列头元素，将其周围的距离矩阵的元素与自身距离矩阵的元素+1比较，将较小的值设置在周围的距离矩阵上。同时，将改变数值的坐标再次放入队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123; public int[][] updateMatrix(int[][] mat) &#123; Queue&lt;Integer&gt; q = new LinkedList(); int row = mat.length; int col = mat[0].length; int[][] ans = new int[row][col]; for ( int i = 0; i &lt; row; i++ )&#123; for (int j = 0; j &lt; col; j++)&#123; if (mat[i][j] == 0)&#123; ans[i][j] = 0; q.add(i*col + j); &#125; else&#123; ans[i][j] = Integer.MAX_VALUE; &#125; &#125; &#125; while(!q.isEmpty())&#123; int i = q.peek() / col; int j = q.poll() % col; if(i-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i-1][j])&#123; ans[i-1][j] = ans[i][j]+1; q.add((i-1)*col + j); &#125; if(i+1 &lt; row &amp;&amp; ans[i][j]+1 &lt; ans[i+1][j])&#123; ans[i+1][j] = ans[i][j]+1; q.add((i+1)*col + j); &#125; if(j-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i][j-1])&#123; ans[i][j-1] = ans[i][j]+1; q.add(i*col + (j-1)); &#125; if(j+1 &lt; col &amp;&amp; ans[i][j]+1 &lt; ans[i][j+1])&#123; ans[i][j+1] = ans[i][j]+1; q.add(i*col + (j+1)); &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"}]},{"title":"116. Populating Next Right Pointers in Each Node","slug":"116-Populating-Next-Right-Pointers-in-Each-Node","date":"2022-04-10T06:29:14.000Z","updated":"2022-04-10T06:29:14.640Z","comments":true,"path":"2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/","excerpt":"","text":"问题You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456 struct Node &#123; int val; Node *left; Node *right; Node *next;&gt;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 递归，当root为null时返回。如果root有右节点，则左节点next指向右节点。如果root有右节点同时next已经指向了一个节点，则将其右节点next指向该节点的左子节点。递归左右子节点，并返回root。 1234567891011121314151617181920212223242526272829303132333435363738/*// Definition for a Node.class Node &#123; public int val; public Node left; public Node right; public Node next; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, Node _left, Node _right, Node _next) &#123; val = _val; left = _left; right = _right; next = _next; &#125;&#125;;*/class Solution &#123; public Node connect(Node root) &#123; if (root==null)&#123;return root;&#125; if (root.right!=null)&#123; root.left.next = root.right; if (root.next!=null)&#123; root.right.next = root.next.left; &#125; &#125; connect(root.left); connect(root.right); return root; &#125;&#125; BFS搜索每一个节点，将节点指向队列中next下一个节点。当计数器达到2的指数时，将节点指向null。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public Node connect(Node root) &#123; if (root == null)&#123; return root; &#125; int count = 1; Queue&lt;Node&gt; q = new LinkedList(); q.offer(root); while (!q.isEmpty())&#123; count++; Node curr = q.poll(); if ( isPow(count) )&#123; curr.next = null; &#125; else&#123; curr.next = q.peek(); &#125; if(curr.left!=null)&#123; q.add(curr.left); &#125; if(curr.right!=null)&#123; q.add(curr.right); &#125; &#125; return root; &#125; private boolean isPow(int val)&#123; if(val == 0 || val == 1)&#123; return false; &#125; while ( val % 2 == 0 )&#123; val = val / 2; &#125; if (val == 1)&#123; return true; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"20. Valid Parentheses","slug":"20-Valid-Parentheses","date":"2022-04-10T03:19:50.000Z","updated":"2022-04-10T03:19:50.707Z","comments":true,"path":"2022/04/10/20-Valid-Parentheses/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/20-Valid-Parentheses/","excerpt":"","text":"问题Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 用栈储存遍历中的字符。如果是“（”，“{”或“[”，则入栈。如果是其他字符，且不与栈顶的字符成对，则返回false。其他情况需要pop掉栈顶。 toCharArray(): 将字符串转换为字符数组，便于遍历。 123456789101112131415161718192021class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack(); for (char c : s.toCharArray())&#123; if ( c == &#x27;(&#x27; || c == &#x27;&#123;&#x27; || c == &#x27;[&#x27; )&#123; stack.push(c); &#125; else if ( stack.size() == 0 || c == &#x27;)&#x27; &amp;&amp; stack.peek() != &#x27;(&#x27; || c == &#x27;&#125;&#x27; &amp;&amp; stack.peek() != &#x27;&#123;&#x27; || c == &#x27;]&#x27; &amp;&amp; stack.peek() != &#x27;[&#x27;) &#123; return false; &#125; else&#123; stack.pop(); &#125; &#125; return stack.isEmpty(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"}]},{"title":"617. Merge Two Binary Trees","slug":"617-Merge-Two-Binary-Trees","date":"2022-04-10T01:39:03.000Z","updated":"2022-04-10T01:39:03.743Z","comments":true,"path":"2022/04/10/617-Merge-Two-Binary-Trees/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/617-Merge-Two-Binary-Trees/","excerpt":"","text":"问题You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. 递归。将root1和root2合并到root1。如果一个节点为null，则返回另一个节点。否则root1的值为root1 + root2的值。root1.left递归root1和root2的left。root2.right递归root1和root2的right。返回root1。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode() &#123;&#125; * TreeNode(int val) &#123; this.val = val; &#125; * TreeNode(int val, TreeNode left, TreeNode right) &#123; * this.val = val; * this.left = left; * this.right = right; * &#125; * &#125; */class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if( root1 == null )&#123; return root2; &#125; if( root2 == null )&#123; return root1; &#125; root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"83. Remove Duplicates from Sorted List","slug":"83-Remove-Duplicates-from-Sorted-List","date":"2022-04-10T00:38:58.000Z","updated":"2022-04-10T00:41:06.849Z","comments":true,"path":"2022/04/10/83-Remove-Duplicates-from-Sorted-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/83-Remove-Duplicates-from-Sorted-List/","excerpt":"","text":"问题Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 设置前一个节点和当前节点两个指针。由于是有数的链表，遍历时可以直接比较两个节点。如相等则前一个节点的next指向当前节点的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if ( head == null)&#123; return head; &#125; if ( head.next == null)&#123; return head; &#125; ListNode prev = head; ListNode curr = head.next; while(curr != null)&#123; if(prev.val != curr.val)&#123; curr = curr.next; prev = prev.next; &#125; else&#123; prev.next = curr.next; curr = curr.next; &#125; &#125; return head; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"695. Max Area of Island","slug":"695-Max-Area-of-Island","date":"2022-04-10T00:03:12.000Z","updated":"2022-04-10T00:20:50.087Z","comments":true,"path":"2022/04/10/695-Max-Area-of-Island/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/695-Max-Area-of-Island/","excerpt":"","text":"问题You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. DFS, 遍历每个等于1的地图块。递归周围四个地图块，当超越数组范围时返回0。进行搜索时将搜索过的地图块设为0。否则运行BFS时将全局变量count增加。执行完毕后BFS时将全局变量count清零。 count计算的是BFS执行的次数 12345678910111213141516171819202122232425262728293031class Solution &#123; int count = 0; public int maxAreaOfIsland(int[][] grid) &#123; int best = 0; for(int i = 0; i &lt; grid.length ; i++)&#123; for(int j = 0; j &lt; grid[0].length; j++)&#123; if ( grid[i][j] == 1 )&#123; best = Math.max(best, dfs(grid,i,j)); count = 0; &#125; &#125; &#125; return best; &#125; private int dfs(int[][] grid, int i, int j)&#123; if((i &lt; 0 || i &gt; grid.length -1) || (j &lt; 0 || j &gt; grid[0].length -1 ) || grid[i][j] == 0)&#123; return 0; &#125; grid[i][j] = 0; count++; dfs(grid,i-1,j); dfs(grid,i,j-1); dfs(grid,i+1,j); dfs(grid,i,j+1); return count; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"}]},{"title":"347. Top K Frequent Elements","slug":"347-Top-K-Frequent-Elements","date":"2022-04-09T23:39:16.000Z","updated":"2022-04-09T23:39:16.609Z","comments":true,"path":"2022/04/10/347-Top-K-Frequent-Elements/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/347-Top-K-Frequent-Elements/","excerpt":"","text":"问题Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. 遍历，使用哈希表保存遍历次数。再次遍历，根据元素出现的次数将其填入大根堆。遍历取出k个最大值。 getOrDefault()：方便的遍历并生成哈希表。 lambda： （）内表示传入的数值。-&gt; 后表示返回值。 1234567891011121314151617class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; int[] ans = new int[k]; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for (int num : nums)&#123; map.put( num, map.getOrDefault(num , 0) + 1 ); &#125; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue((a,b) -&gt; map.get(b) - map.get(a)); for (int key : map.keySet())&#123; pq.add(key); &#125; for (int i = 0; i &lt; k ; i++)&#123; ans[i] = pq.poll(); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"}]},{"title":"206. Reverse Linked List","slug":"206-Reverse-Linked-List","date":"2022-04-09T19:49:54.000Z","updated":"2022-04-09T19:49:54.819Z","comments":true,"path":"2022/04/10/206-Reverse-Linked-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/10/206-Reverse-Linked-List/","excerpt":"","text":"问题Given the head of a singly linked list, reverse the list, and return the reversed list. 翻转列表，当链表长度不足时，直接返回原链表。将头元素设置到preNode，同时将其next设置为null，作为新链表的尾。将其余的元素设置到curNode。 当当前节点不为null时遍历： 将curNode的next保存在temp。 将curNode的next指向preNode，作为preNode的上一个节点。 将preNode指向curNode，完成交换。 将curNode指向temp，curNode变为原来的curNode的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; if( head == null )&#123; //if not enough, return head return head; &#125; if ( head.next == null )&#123; return head; &#125; ListNode preNode = head; //set head to preNode, it will be the last node in the end ListNode curNode = head.next; //curNode move to next preNode.next = null; //only preserve one head node ListNode temp; while( curNode != null )&#123; temp = curNode.next; //preserve nodes after curNode curNode.next = preNode; //cur -&gt; pre preNode = curNode; //set back reversed list to preNode curNode = temp; //put back preserved nodes, curNode move to the next &#125; return preNode; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"203. Remove Linked List Elements","slug":"203-Remove-Linked-List-Elements","date":"2022-04-09T02:39:09.000Z","updated":"2022-04-09T02:39:09.603Z","comments":true,"path":"2022/04/09/203-Remove-Linked-List-Elements/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/203-Remove-Linked-List-Elements/","excerpt":"","text":"问题Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val &#x3D;&#x3D; val, and return the new head. 设置哨兵节点，将其next指向头部。设置前节点，将其指向哨兵节点。设置尾部节点，并指向头部。移动当前节点尾部，如尾部的val等于需要删去的val，则将前节点的next指向尾部的next。尾部的next如为null，则前节点的next指向null。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null)&#123; return head; &#125; ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode preNode = dummyHead; ListNode tail = dummyHead.next; while( tail != null )&#123; if ( tail.next == null &amp;&amp; tail.val == val )&#123; preNode.next = null; break; &#125; else if (tail.val == val)&#123; preNode.next = tail.next; tail = preNode.next; &#125; else&#123; preNode = preNode.next; tail = tail.next; &#125; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"733. Flood Fill","slug":"733-Flood-Fill","date":"2022-04-09T01:13:45.000Z","updated":"2022-04-09T01:13:45.287Z","comments":true,"path":"2022/04/09/733-Flood-Fill/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/733-Flood-Fill/","excerpt":"","text":"答案An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. Return the modified image after performing the flood fill. 深度优先搜索。如果当前像素颜色等于最初的颜色，则变更为新颜色。然后继续递归四个周围的像素。 1234567891011121314151617181920212223242526272829class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; int oldColor = image[sr][sc]; if (oldColor != newColor)&#123; dfs(image,sr,sc,oldColor,newColor); &#125; return image; &#125; private void dfs(int[][] image, int r, int c, int oldColor, int newColor)&#123; if (image[r][c] == oldColor)&#123; image[r][c] = newColor; if (r&gt;=1)&#123; dfs(image,r-1,c,oldColor,newColor); &#125; if (c&gt;=1)&#123; dfs(image,r,c-1,oldColor,newColor); &#125; if (r&lt;image.length-1)&#123; dfs(image,r+1,c,oldColor,newColor); &#125; if (c&lt;image[0].length-1)&#123; dfs(image,r,c+1,oldColor,newColor); &#125; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"}]},{"title":"21. Merge Two Sorted Lists","slug":"21-Merge-Two-Sorted-Lists","date":"2022-04-09T00:19:16.000Z","updated":"2022-04-09T00:19:16.999Z","comments":true,"path":"2022/04/09/21-Merge-Two-Sorted-Lists/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/21-Merge-Two-Sorted-Lists/","excerpt":"","text":"问题You are given the heads of two sorted linked lists list1 and list2.》Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 先设置空的哨兵节点，然后将尾部指针指向这个节点。遍历两个链表，将尾部节点的下一个值指向两个节点中值较小的一个。然后将指针移动到下一个值。最后返回哨兵节点的下一个节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123; ListNode dummyHead = new ListNode(); ListNode tail = dummyHead; while ( list1 != null &amp;&amp; list2 !=null )&#123; if (list1.val &lt; list2.val)&#123; tail.next = list1; list1 = list1.next; tail = tail.next; &#125; else&#123; tail.next = list2; list2 = list2.next; tail = tail.next; &#125; &#125; if ( list1 == null)&#123; tail.next = list2; &#125; else &#123; tail.next = list1; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"}]},{"title":"141. Linked List Cycle","slug":"141-Linked-List-Cycle","date":"2022-04-08T21:24:04.000Z","updated":"2022-04-08T21:24:52.458Z","comments":true,"path":"2022/04/09/141-Linked-List-Cycle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/141-Linked-List-Cycle/","excerpt":"","text":"问题Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. 遍历并移动快慢指针。如两个指针最终相遇，则链表中有循环。如快指针移动到链表尾部，则链表无循环。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; if ( head == null)&#123; return false; &#125; else if ( fast.next == null)&#123; return false; &#125; while( fast != null &amp;&amp; fast.next != null )&#123; slow = slow.next; fast = fast.next.next; if (slow == fast)&#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"703. Kth Largest Element in a Stream","slug":"703-Kth-Largest-Element-in-a-Stream","date":"2022-04-08T20:06:37.000Z","updated":"2022-04-08T20:06:37.916Z","comments":true,"path":"2022/04/09/703-Kth-Largest-Element-in-a-Stream/","link":"","permalink":"https://xuanhe95.github.io/2022/04/09/703-Kth-Largest-Element-in-a-Stream/","excerpt":"","text":"问题Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. 优先级队列，插入所有元素，小元素在前。当队列长度大于k时，poll掉前面的元素。 12345678910111213141516171819202122232425class KthLargest &#123; PriorityQueue&lt;Integer&gt; pq; int kth; public KthLargest(int k, int[] nums) &#123; pq = new PriorityQueue&lt;Integer&gt;(); kth = k; for (int num : nums)&#123; pq.add(num); &#125; &#125; public int add(int val) &#123; pq.add(val); while (pq.size() &gt; kth)&#123; pq.poll(); &#125; return pq.peek(); &#125;&#125;/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"}]},{"title":"242. Valid Anagram","slug":"242-Valid-Anagram","date":"2022-04-07T06:40:19.000Z","updated":"2022-04-07T06:40:19.263Z","comments":true,"path":"2022/04/07/242-Valid-Anagram/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/242-Valid-Anagram/","excerpt":"","text":"问题Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 两数组相等时，直接遍历两个数组并记录各个字符出现的数量。一个数组遍历时用做加法，另一个做减法。如果最后每个字符出现的数量均为0，则返回真。 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; if (s.length()!=t.length())&#123; return false; &#125; int[] dic = new int[26]; for (int i = 0; i &lt; s.length(); i++)&#123; dic[s.charAt(i)-&#x27;a&#x27;]++; dic[t.charAt(i)-&#x27;a&#x27;]--; &#125; for(int num : dic)&#123; if ( num != 0 )&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[]},{"title":"567. Permutation in String","slug":"567-Permutation-in-String","date":"2022-04-07T06:28:20.000Z","updated":"2022-04-07T06:35:24.973Z","comments":true,"path":"2022/04/07/567-Permutation-in-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/567-Permutation-in-String/","excerpt":"","text":"问题Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2. 将要查找的组合加入数组，数值为字符出现的次数。滑动窗口，入窗口对应的元素数值-1，出窗口对应的元素数值+1。每次移动窗口都检验一次数组的数值是否全部为0，如果是真，则返回真。小技巧：直接用数组来记录字符出现的次数，用字符减去与’a’的差作为下标。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if (s1.length() &gt; s2.length())&#123; return false; &#125; int[] dic = new int[26]; for (int i = 0; i &lt; s1.length(); i++)&#123; dic[s1.charAt(i)-&#x27;a&#x27;]++; dic[s2.charAt(i)-&#x27;a&#x27;]--; &#125; int i = 0; int j = s1.length(); while( j &lt; s2.length() )&#123; if ( allZero(dic) )&#123; return true; &#125; dic[s2.charAt(i)-&#x27;a&#x27;]++; dic[s2.charAt(j)-&#x27;a&#x27;]--; i++; j++; &#125; return allZero(dic); &#125; private boolean allZero(int[] dic)&#123; for (int num : dic)&#123; if ( num != 0 )&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"3-Longest-Substring-Without-Repeating-Characters","date":"2022-04-07T05:50:40.000Z","updated":"2022-04-07T05:54:16.146Z","comments":true,"path":"2022/04/07/3-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/3-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"问题Given a string s, find the length of the longest substring without repeating characters. 滑动窗口，哈希表记录访问过的字符的元素。如果重复，则放弃前一个重复的字符，更新左指针。注意：只有在新指针大于现有指针时才更新！ 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int best = 0; int i = 0; int j = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); while ( j &lt; s.length() )&#123; char curChar = s.charAt(j); if ( !map.containsKey(curChar) )&#123; map.put( curChar, j ); &#125; else&#123; if ( map.get(curChar) + 1 &gt; i)&#123; i = map.get(curChar) + 1; &#125; map.put( curChar, j ); &#125; if ((j - i + 1) &gt; best)&#123; best = (j - i + 1); &#125; j++; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"383. Ransom Note","slug":"383-Ransom-Note","date":"2022-04-07T05:02:15.000Z","updated":"2022-04-07T05:02:15.980Z","comments":true,"path":"2022/04/07/383-Ransom-Note/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/383-Ransom-Note/","excerpt":"","text":"问题Given two strings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. 哈希表，遍历添加字典及次数。然后遍历note，与字典中的字符数量作比较。 可以优化速度，采用数组记录所有英文字母的数量。 12345678910111213141516171819202122232425class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; HashMap&lt;Character, Integer&gt; dic = new HashMap&lt;Character, Integer&gt;(); for (int i = 0; i &lt; magazine.length(); i++)&#123; char curChar = magazine.charAt(i); if (!dic.containsKey(curChar))&#123; dic.put(curChar, 1); &#125; else&#123; dic.put(curChar, dic.get(curChar)+1); &#125; &#125; for (int i = 0; i &lt; ransomNote.length(); i++)&#123; char curChar = ransomNote.charAt(i); if (dic.containsKey(curChar) &amp;&amp; dic.get(curChar) &gt; 0)&#123; dic.put(curChar, dic.get(curChar)-1); &#125; else&#123; return false; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"387. First Unique Character in a String","slug":"387-First-Unique-Character-in-a-String","date":"2022-04-07T04:48:17.000Z","updated":"2022-04-07T04:48:17.959Z","comments":true,"path":"2022/04/07/387-First-Unique-Character-in-a-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/387-First-Unique-Character-in-a-String/","excerpt":"","text":"问题Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. 遍历，建立哈希表，记录出现次数。再次遍历，如果出现次数为1，则返回下标。 1234567891011121314151617181920212223class Solution &#123; public int firstUniqChar(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for ( int i = 0; i &lt; s.length(); i++ )&#123; char curChar = s.charAt(i); if ( !map.containsKey(curChar) )&#123; map.put(curChar, 1); &#125; else&#123; map.put(curChar, map.get(curChar)+1); &#125; &#125; for ( int i = 0; i &lt; s.length(); i++ )&#123; char curChar = s.charAt(i); if ( map.get(curChar) == 1 )&#123; return i; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"1046. Last Stone Weight","slug":"1046-Last-Stone-Weight","date":"2022-04-07T04:09:40.000Z","updated":"2022-04-07T04:09:40.205Z","comments":true,"path":"2022/04/07/1046-Last-Stone-Weight/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/1046-Last-Stone-Weight/","excerpt":"","text":"问题You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;&#x3D; y. The result of this smash is: If x &#x3D;&#x3D; y, both stones are destroyed, and If x !&#x3D; y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0. 采用PriorityQueue队列，将所有元素放入。每次取出两个，将两者的差值放回队列。 12345678910111213141516class Solution &#123; public int lastStoneWeight(int[] stones) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for (int stone : stones)&#123; pq.add(stone); &#125; while ( pq.size() &gt; 1) &#123; int largeStone = pq.poll(); int smallStone = pq.poll(); pq.add( largeStone - smallStone ); &#125; return pq.poll(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"680. Valid Palindrome II","slug":"680-Valid-Palindrome-II","date":"2022-04-07T00:37:01.000Z","updated":"2022-04-07T00:37:01.629Z","comments":true,"path":"2022/04/07/680-Valid-Palindrome-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/680-Valid-Palindrome-II/","excerpt":"","text":"问题Given a string s, return true if the s can be palindrome after deleting at most one character from it. 双指针，字符串两边对比。如果两边字符不相等，则更新两边指针，并分别传入辅助方法再次对比。两个结果有一个是true则返回true。 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0; int right = s.length() - 1; while (left &lt; right)&#123; if (s.charAt(left) == s.charAt(right) )&#123; left++; right--; &#125; else&#123; return ( checkPalindrome(s, left+1, right) || checkPalindrome(s, left, right-1)); &#125; &#125; return true; &#125; private boolean checkPalindrome(String s, int left, int right)&#123; while (left &lt; right)&#123; if (s.charAt(left)==s.charAt(right))&#123; left++; right--; &#125; else&#123; return false; &#125; &#125; return true; &#125; &#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"}]},{"title":"19. Remove Nth Node From End of List","slug":"19-Remove-Nth-Node-From-End-of-List","date":"2022-04-06T20:18:11.000Z","updated":"2022-04-08T21:26:44.655Z","comments":true,"path":"2022/04/07/19-Remove-Nth-Node-From-End-of-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/19-Remove-Nth-Node-From-End-of-List/","excerpt":"","text":"问题Given the head of a linked list, remove the nth node from the end of the list and return its head. 双指针，同时记录前n个节点和当前节点。当前指针到链表尾部时，删除前面的指针，注意处理edge cases。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode preNode = null; ListNode removedNode = head; ListNode fastNode = head; for ( int i = 0; i &lt; n; i++ )&#123; fastNode = fastNode.next; &#125; while ( fastNode != null )&#123; fastNode = fastNode.next; preNode = removedNode; removedNode = removedNode.next; &#125; if ( removedNode == head )&#123; head = head.next; &#125; else if ( removedNode.next == null)&#123; preNode.next = null; &#125; else&#123; preNode.next = removedNode.next; &#125; return head; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"876. Middle of the Linked List","slug":"876-Middle-of-the-Linked-List","date":"2022-04-06T19:53:17.000Z","updated":"2022-04-08T21:27:14.358Z","comments":true,"path":"2022/04/07/876-Middle-of-the-Linked-List/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/876-Middle-of-the-Linked-List/","excerpt":"","text":"问题Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 快慢指针，两个指针不同速度遍历链表。当快指针达到链表尾部时候，慢指针正好在中间。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode middleNode(ListNode head) &#123; ListNode slowNode = head; ListNode fastNode = head; while( fastNode != null )&#123; fastNode = fastNode.next; if (fastNode == null)&#123; return slowNode; &#125; slowNode = slowNode.next; fastNode = fastNode.next; &#125; return slowNode; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}]},{"title":"74. Search a 2D Matrix","slug":"74-Search-a-2D-Matrix","date":"2022-04-06T19:51:13.000Z","updated":"2022-04-06T19:51:14.021Z","comments":true,"path":"2022/04/07/74-Search-a-2D-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/74-Search-a-2D-Matrix/","excerpt":"","text":"问题Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 双指针，先搜索到合适的行。再搜索到合适的列。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; int i = 0; int j = 0; while ( i &lt; matrix.length ) &#123; int num = matrix[i][j]; if ( num == target )&#123; return true; &#125; else if ( num &lt; target )&#123; i++; &#125; else&#123; break; &#125; &#125; if ( i == 0 )&#123; return false; &#125; i--; while ( j &lt; matrix[0].length )&#123; int num = matrix[i][j]; if ( num == target )&#123; return true; &#125; else if ( num &lt; target )&#123; j++; &#125; else&#123; return false; &#125; &#125; return false; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"36. Valid Sudoku","slug":"36-Valid-Sudoku","date":"2022-04-06T19:08:49.000Z","updated":"2022-04-06T19:08:49.845Z","comments":true,"path":"2022/04/07/36-Valid-Sudoku/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/36-Valid-Sudoku/","excerpt":"","text":"问题Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. 遍历并创建三组不同的哈希表，每个表内包含一组哈希集合。如果访问的元素已在哈希集合内，则返回false 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean isValidSudoku(char[][] board) &#123; HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; rowMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; colMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; blockMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); for (int i = 0; i &lt; board[0].length; i++ )&#123; for (int j = 0; j &lt; board.length; j++ )&#123; char curChar = board[i][j]; if (curChar == &#x27;.&#x27;)&#123; continue; &#125; if (!rowMap.containsKey(i))&#123; rowMap.put(i, new HashSet&lt;Character&gt;()); &#125; if (!colMap.containsKey(j))&#123; colMap.put(j, new HashSet&lt;Character&gt;()); &#125; if (!blockMap.containsKey(j/3*3+i/3))&#123; blockMap.put(j/3*3+i/3, new HashSet&lt;Character&gt;()); &#125; HashSet&lt;Character&gt; curRow = rowMap.get(i); HashSet&lt;Character&gt; curCol = colMap.get(j); HashSet&lt;Character&gt; curBlock = blockMap.get(j/3*3+i/3); if ( !curRow.contains(curChar) &amp;&amp; !curCol.contains(curChar) &amp;&amp; !curBlock.contains(curChar) )&#123; curRow.add(curChar); curCol.add(curChar); curBlock.add(curChar); &#125; else&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"923. 3Sum With Multiplicity","slug":"923-3Sum-With-Multiplicity","date":"2022-04-06T18:27:00.000Z","updated":"2022-04-06T18:27:00.097Z","comments":true,"path":"2022/04/07/923-3Sum-With-Multiplicity/","link":"","permalink":"https://xuanhe95.github.io/2022/04/07/923-3Sum-With-Multiplicity/","excerpt":"","text":"问题Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] &#x3D;&#x3D; target. As the answer can be very large, return it modulo 109 + 7. 首先遍历元素，根据元素的值和出现次数建立哈希表。然后再哈希表中选择三个元素，如果和等于target，则计算三个元素出现次数的乘积。最后除以重复计算的次数。由于数值较大，因此中途计算应该采用长整型long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int threeSumMulti(int[] arr, int target) &#123; //enumberate every element and put them into the map HashMap&lt;Integer, Long&gt; map = new HashMap&lt;Integer, Long&gt;(); long count = 0; for ( int num : arr )&#123; if (!map.containsKey(num))&#123; map.put(num, (long)1); &#125; else&#123; map.put(num, map.get(num)+1); &#125; &#125; //traverse whole elements and select three numbers for ( int a : map.keySet() )&#123; long totalA = map.get(a); for (int b : map.keySet())&#123; long totalB = map.get(b); if ( a == b )&#123; if (totalB &lt; 2)&#123; continue; &#125; totalB = totalB - 1; &#125; int c = target - a - b; if ( map.containsKey(c) )&#123; long totalC = map.get(c); long total = 0; if ( a == b &amp;&amp; b == c )&#123; total = totalA * totalB * ( totalC - 2 ) ; &#125; else if ( b == c || a == c )&#123; total = totalA * totalB * ( totalC - 1 ) ; &#125; else&#123; total = totalA * totalB * totalC; &#125; if ( total &gt; 0 )&#123; count += total; &#125; &#125; &#125; &#125; count/=6; int ans = (int) (count % 1000000007); return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"118. Pascal's Triangle","slug":"118-Pascal-s-Triangle","date":"2022-04-05T18:53:43.000Z","updated":"2022-04-05T19:01:11.012Z","comments":true,"path":"2022/04/06/118-Pascal-s-Triangle/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/118-Pascal-s-Triangle/","excerpt":"","text":"问题Given an integer numRows, return the first numRows of Pascal’s triangle. 动态规划，直接按照杨辉三角形的定义计算。 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows); for (int i = 0; i &lt; numRows ; i++)&#123; List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(i+1); for (int j = 0; j &lt;= i; j++)&#123; if ( j == 0 || j == i )&#123; arr.add(1); &#125; else&#123; arr.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j)); &#125; &#125; ans.add(arr); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"11. Container With Most Water","slug":"11-Container-With-Most-Water","date":"2022-04-05T16:50:01.000Z","updated":"2022-04-05T19:03:02.604Z","comments":true,"path":"2022/04/06/11-Container-With-Most-Water/","link":"","permalink":"https://xuanhe95.github.io/2022/04/06/11-Container-With-Most-Water/","excerpt":"","text":"问题You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. 双指针在首尾，二者容量取决于两者中较小的一个。贪心算法，保留两个指针上较大的元素，移动较小一边的指针。由于指针移动时距离只会减小，因此当新的元素比上一个更大时才有可能比之前的容量更大。遍历一次找到最大容量。时间复杂度：O(n) 感觉这个移动有点博弈论的味了，每次都移动自己最差的一边，虽然可能变得更差，但是总比不动（或者减小）强，动最差的部分可能找到更好的结果，但是动另一边总会更差或者不变，兄弟们，这不是题，这是人生，逃离舒适圈！！（这解释我觉得无敌了，哈哈哈） 12345678910111213141516171819202122232425class Solution &#123; public int maxArea(int[] height) &#123; int best = 0; int i = 0; int j = height.length - 1; while ( i &lt; j )&#123; int product = 0; if (height[i] &lt; height[j])&#123; product = height[i] * ( j -i ); i++; &#125; else&#123; product = height[j] * ( j -i ); j--; &#125; if ( product &gt; best)&#123; best = product; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"344. Reverse String","slug":"344-Reverse-String","date":"2022-04-05T13:56:14.000Z","updated":"2022-04-05T19:06:30.027Z","comments":true,"path":"2022/04/05/344-Reverse-String/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/344-Reverse-String/","excerpt":"","text":"问题简述Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. 双指针，同时更新并交换两个数值。 12345678910111213141516class Solution &#123; public void reverseString(char[] s) &#123; int i = 0; int j = s.length - 1; while( i &lt; j ) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"167. Two Sum II - Input Array Is Sorted","slug":"167-Two-Sum-II-Input-Array-Is-Sorted","date":"2022-04-05T05:52:45.000Z","updated":"2022-04-05T19:05:47.624Z","comments":true,"path":"2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/","excerpt":"","text":"问题描述Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 由于是有序数列，因此可以采用双指针。左右两侧和不等于目标时，根据大小结果移动左右指针。 123456789101112131415161718192021222324class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int i = 0; int j = numbers.length - 1; int[] ans = new int[2]; while( i &lt; j )&#123; int diff = target - numbers[j]; if ( diff == numbers[i])&#123; ans[0] = i+1; ans[1] = j+1; return ans; &#125; else if ( diff &lt; numbers[i] ) &#123; j--; &#125; else&#123; i++; &#125; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"566. Reshape the Matrix","slug":"566-Reshape-the-Matrix","date":"2022-04-05T04:40:01.000Z","updated":"2022-04-06T19:53:31.024Z","comments":true,"path":"2022/04/05/566-Reshape-the-Matrix/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/566-Reshape-the-Matrix/","excerpt":"","text":"问题概述In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. 根据数组的数学公式得出其位置，一次遍历将原数组中的数字填入。O(r*c) 1234567891011121314151617181920212223class Solution &#123; public int[][] matrixReshape(int[][] mat, int r, int c) &#123; int[][] ans = new int[r][c]; int oldR = mat.length; int oldC = mat[0].length; if ( oldR * oldC != r * c )&#123; return mat; &#125; for (int i = 0; i &lt; r*c ; i++ )&#123; int m = i/oldC; int n = i%oldC; int p = i/c; int q = i%c; ans[p][q] = mat[m][n]; &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"283. Move Zeroes","slug":"283-Move-Zeroes","date":"2022-04-04T18:11:56.000Z","updated":"2022-04-06T07:19:29.538Z","comments":true,"path":"2022/04/05/283-Move-Zeroes/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/283-Move-Zeroes/","excerpt":"","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int i = 0; int j = 0; while ( j &lt; nums.length )&#123; if ( nums[j] != 0 )&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; &#125; j++; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"121. Best Time to Buy and Sell Stock","slug":"121-Best-Time-to-Buy-and-Sell-Stock","date":"2022-04-04T17:50:49.000Z","updated":"2022-04-06T07:20:10.618Z","comments":true,"path":"2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","link":"","permalink":"https://xuanhe95.github.io/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/","excerpt":"","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution &#123; public int maxProfit(int[] prices) &#123; int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ )&#123; difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] )&#123; difference[i] = difference[i] + difference[i - 1]; &#125; if (difference[i] &gt; best)&#123; best = difference[i]; &#125; &#125; return best; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"}]},{"title":"350. Intersection of Two Arrays II","slug":"350-Intersection-of-Two-Arrays-II","date":"2022-04-04T12:42:40.000Z","updated":"2022-04-06T07:20:49.549Z","comments":true,"path":"2022/04/04/350-Intersection-of-Two-Arrays-II/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/350-Intersection-of-Two-Arrays-II/","excerpt":"","text":"问题描述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ )&#123; if (!map.containsKey(nums1[i]))&#123; map.put(nums1[i],1); &#125; else&#123; map.put(nums1[i],map.get(nums1[i])+1); &#125; &#125; for ( int i = 0 ; i &lt; nums2.length ; i++ )&#123; if (map.containsKey(nums2[i]))&#123; if (map.get(nums2[i]) &gt; 0)&#123; count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); &#125; &#125; &#125; int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++)&#123; ans[i] = arr.get(i); &#125; return ans; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"31. Next Permutation","slug":"31-Next-Permutation","date":"2022-04-03T20:11:22.000Z","updated":"2022-04-05T05:58:47.787Z","comments":true,"path":"2022/04/04/31-Next-Permutation/","link":"","permalink":"https://xuanhe95.github.io/2022/04/04/31-Next-Permutation/","excerpt":"","text":"问题描述A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr &#x3D; [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr &#x3D; [1,2,3] is [1,3,2].Similarly, the next permutation of arr &#x3D; [2,3,1] is [3,1,2].While the next permutation of arr &#x3D; [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution &#123; public void nextPermutation(int[] nums) &#123; int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1)&#123; int i = nums.length -2; while (i &gt;= 0)&#123; if (nums[i + 1] &lt;= nums[i]) &#123; //从尾部开始，比较元素是否是大到小 i--; continue; &#125; else &#123; //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--)&#123; if (nums[j] &lt;= nums[i])&#123; continue; &#125; int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; &#125; break; &#125; &#125; if (flag == 0 )&#123; //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"}]},{"title":"88. Merge Sorted Array","slug":"88-Merge-Sorted-Array","date":"2022-04-03T15:26:40.000Z","updated":"2022-04-05T05:58:48.410Z","comments":true,"path":"2022/04/03/88-Merge-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/88-Merge-Sorted-Array/","excerpt":"","text":"问题描述You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) &#123; if ( nums1[i] &lt; nums2[j] )&#123; nums1[k] = nums2[j]; j--; k--; &#125; else &#123; nums1[k] = nums1[i]; i--; k--; &#125; &#125; if ( i &lt; 0 )&#123; while ( j &gt;= 0 )&#123; nums1[k] = nums2[j]; j--; k--; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"}]},{"title":"1. Two Sum","slug":"1-Two-Sum","date":"2022-04-03T14:35:42.000Z","updated":"2022-04-05T05:58:46.865Z","comments":true,"path":"2022/04/03/1-Two-Sum/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/1-Two-Sum/","excerpt":"","text":"问题描述Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++)&#123; int result = target - nums[i]; if ( map.containsKey(result) )&#123; ans[0] = map.get(result); ans[1] = i; return ans; &#125; else&#123; map.put(nums[i], i); &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"}]},{"title":"189. Rotate Array","slug":"189-Rotate-Array","date":"2022-04-03T13:54:39.000Z","updated":"2022-04-05T05:58:57.511Z","comments":true,"path":"2022/04/03/189-Rotate-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/189-Rotate-Array/","excerpt":"","text":"问题描述Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution &#123; public void rotate(int[] nums, int k) &#123; if (k != 0)&#123; int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) &#123; int i = n + k; i %= nums.length; int temp = nums[n]; while( true )&#123; int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n)&#123; nums[n] = temp; break; &#125; &#125; &#125; &#125; &#125; private int gcd(int a, int b)&#123; int max = a; int min = b; if (max == min)&#123; return min; &#125; if ( a &lt; b )&#123; max = b; min = a; &#125; return gcd(max - min, min); &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"977. Squares of a Sorted Array","slug":"977-Squares-of-a-Sorted-Array","date":"2022-04-03T13:35:19.000Z","updated":"2022-04-05T05:59:10.780Z","comments":true,"path":"2022/04/03/977-Squares-of-a-Sorted-Array/","link":"","permalink":"https://xuanhe95.github.io/2022/04/03/977-Squares-of-a-Sorted-Array/","excerpt":"","text":"问题描述Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) &#123; if ( nums[left] &lt; 0 )&#123; if ( (-nums[left]) &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else &#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; else&#123; if ( nums[left] &lt; nums[right] )&#123; ans[i] = nums[right] * nums[right]; right--; &#125; else&#123; ans[i] = nums[left] * nums[left]; left++; &#125; i--; &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"测试一下","slug":"测试一下","date":"2022-03-30T14:26:17.000Z","updated":"2022-03-30T14:26:17.799Z","comments":true,"path":"2022/03/30/测试一下/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/","excerpt":"","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","categories":[],"tags":[]},{"title":"post title","slug":"post-title","date":"2022-03-30T12:22:27.000Z","updated":"2022-03-30T12:24:40.285Z","comments":true,"path":"2022/03/30/post-title/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/post-title/","excerpt":"","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-30T12:02:37.831Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/03/30/hello-world/","link":"","permalink":"https://xuanhe95.github.io/2022/03/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/"},{"name":"Medium","slug":"LeetCode/Medium","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Easy/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"},{"name":"复习","slug":"LeetCode/Medium/复习","permalink":"https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"Esay","slug":"LeetCode/Esay","permalink":"https://xuanhe95.github.io/categories/LeetCode/Esay/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"BFS","slug":"BFS","permalink":"https://xuanhe95.github.io/tags/BFS/"},{"name":"数据结构","slug":"数据结构","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Tree","slug":"Tree","permalink":"https://xuanhe95.github.io/tags/Tree/"},{"name":"递归","slug":"递归","permalink":"https://xuanhe95.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"Stack","slug":"Stack","permalink":"https://xuanhe95.github.io/tags/Stack/"},{"name":"Linked List","slug":"Linked-List","permalink":"https://xuanhe95.github.io/tags/Linked-List/"},{"name":"DFS","slug":"DFS","permalink":"https://xuanhe95.github.io/tags/DFS/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://xuanhe95.github.io/tags/Priority-Queue/"},{"name":"lambda","slug":"lambda","permalink":"https://xuanhe95.github.io/tags/lambda/"},{"name":"双指针","slug":"双指针","permalink":"https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://xuanhe95.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"Hash Map","slug":"Hash-Map","permalink":"https://xuanhe95.github.io/tags/Hash-Map/"},{"name":"回文","slug":"回文","permalink":"https://xuanhe95.github.io/tags/%E5%9B%9E%E6%96%87/"},{"name":"DP","slug":"DP","permalink":"https://xuanhe95.github.io/tags/DP/"},{"name":"数学","slug":"数学","permalink":"https://xuanhe95.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"贪心算法","slug":"贪心算法","permalink":"https://xuanhe95.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://xuanhe95.github.io/tags/LeetCode/"},{"name":"原地算法","slug":"原地算法","permalink":"https://xuanhe95.github.io/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"GCD","slug":"GCD","permalink":"https://xuanhe95.github.io/tags/GCD/"}]}