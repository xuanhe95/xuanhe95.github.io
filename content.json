{"pages":[],"posts":[{"title":"1. Two Sum","text":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. 采用哈希表储存遍历过的数值及下标，查表如果有键则返回其下标及当前下标。 1234567891011121314151617181920class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int[] ans = new int[2]; for (int i = 0; i &lt; nums.length; i++){ int result = target - nums[i]; if ( map.containsKey(result) ){ ans[0] = map.get(result); ans[1] = i; return ans; } else{ map.put(nums[i], i); } } return ans; }}","link":"/2022/04/03/1-Two-Sum/"},{"title":"101. Symmetric Tree","text":"问题Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). 递归root1的左子节点和root2的右子节点以及root2的左子节点以及root1的右子节点。如两者不相等则返回false。如果传入的两个数值有一个为null，则两者不相等时返回false。反之返回true。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean isSymmetric(TreeNode root) { return isSymmetric(root,root); } public boolean isSymmetric(TreeNode root1, TreeNode root2){ if ( root1 == null || root2 == null ){ if(root1 == root2){return true;} else{return false;} } if ( root1.val == root2.val ){ return isSymmetric(root1.left,root2.right) &amp;&amp; isSymmetric(root1.right,root2.left); } else{ return false; } }}","link":"/2022/04/13/101-Symmetric-Tree/"},{"title":"102. Binary Tree Level Order Traversal","text":"Question Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). SolutionBFS搜索，层序遍历，记录每个层级的节点数量size。在遍历时挤出size个节点，并将其子节点加入队列。 Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); int size = 1; while(!q.isEmpty()){ List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode curr = null; for(int i = 0; i &lt; size; i++){ curr = q.poll(); if(curr.left != null) q.offer(curr.left); if(curr.right != null) q.offer(curr.right); list.add(curr.val); } ret.add(list); size = q.size(); } return ret; }}","link":"/2022/04/13/102-Binary-Tree-Level-Order-Traversal/"},{"title":"103. Binary Tree Zigzag Level Order Traversal","text":"Given the root of a binary tree, return the zigzag level order traversal of its nodes’ values. (i.e., from left to right, then right to left for the next level and alternate between). BFS搜索，每次遍历挤出整层的节点。根据真值reverse来判断列表顺序。当reverse为真，则每次添加元素到列表头。反之则添加元素到列表尾。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int size = 1; boolean reverse = false; while(!q.isEmpty()){ List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); if(reverse){ level.add(0, curr.val); } else{ level.add(curr.val); } if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); } reverse = !reverse; ret.add(level); size = q.size(); } return ret; }} 双端队列，根据真值reverse来判断是取队头还是取队尾。每层级需要遍历所有的节点。注意添加节点时也需要根据reverse来决定加入对头还是队尾。（从一个层级取出时，加入下一个层级元素需要从队列另一边压入。）同时左右节点的加入顺序也需要调整。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Deque&lt;TreeNode&gt; dq = new LinkedList&lt;&gt;(); dq.add(root); int size = 1; boolean reverse = false; while(!dq.isEmpty()){ List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; size; i++){ if(reverse){ TreeNode curr = dq.removeLast(); if(curr.right != null) dq.offerFirst(curr.right); if(curr.left != null) dq.offerFirst(curr.left); temp.add(curr.val); } else{ TreeNode curr = dq.removeFirst(); if(curr.left != null) dq.offerLast(curr.left); if(curr.right != null) dq.offerLast(curr.right); temp.add(curr.val); } } reverse = !reverse; ret.add(temp); size = dq.size(); } return ret; }}","link":"/2022/05/02/103-Binary-Tree-Zigzag-Level-Order-Traversal/"},{"title":"104. Maximum Depth of Binary Tree","text":"问题Given the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 递归，每次返回左子节点和右子节点中较大的结果+1。当节点为null时返回0。 1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int maxDepth(TreeNode root) { if(root == null){ return 0; } return Math.max(maxDepth(root.left),maxDepth(root.right))+1; }} BFS搜索，每次倾倒出队列里所有的元素并将level+1。搜索完毕返回level。 1234567891011121314151617181920class Solution { public int maxDepth(TreeNode root) { if(root == null){ return 0; } Queue&lt;TreeNode&gt; q = new LinkedList(); q.offer(root); int level = 0; while(!q.isEmpty()){ int size = q.size(); for (int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); if(curr.left!=null){q.offer(curr.left);} if(curr.right!=null){q.offer(curr.right);} } level++; } return level; }}","link":"/2022/04/13/104-Maximum-Depth-of-Binary-Tree/"},{"title":"1046. Last Stone Weight","text":"问题You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.At the end of the game, there is at most one stone left. Return the smallest possible weight of the left stone. If there are no stones left, return 0. 采用PriorityQueue队列，将所有元素放入。每次取出两个，将两者的差值放回队列。 12345678910111213141516class Solution { public int lastStoneWeight(int[] stones) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for (int stone : stones){ pq.add(stone); } while ( pq.size() &gt; 1) { int largeStone = pq.poll(); int smallStone = pq.poll(); pq.add( largeStone - smallStone ); } return pq.poll(); }}","link":"/2022/04/07/1046-Last-Stone-Weight/"},{"title":"1048. Longest String Chain","text":"Question You are given an array of words where each word consists of lowercase English letters. word&lt;sub&gt;A&lt;/sub&gt; is a predecessor of word&lt;sub&gt;B&lt;/sub&gt; if and only if we can insert exactly one letter anywhere in word&lt;sub&gt;A&lt;/sub&gt; without changing the order of the other characters to make it equal to word&lt;sub&gt;B&lt;/sub&gt;. For example, &quot;abc&quot; is a predecessor of &quot;ab&lt;u&gt;a&lt;/u&gt;c&quot;, while &quot;cba&quot; is not a predecessor of &quot;bcad&quot;. A word chain* *is a sequence of words [word&lt;sub&gt;1&lt;/sub&gt;, word&lt;sub&gt;2&lt;/sub&gt;, ..., word&lt;sub&gt;k&lt;/sub&gt;] with k &gt;= 1, where word&lt;sub&gt;1&lt;/sub&gt; is a predecessor of word&lt;sub&gt;2&lt;/sub&gt;, word&lt;sub&gt;2&lt;/sub&gt; is a predecessor of word&lt;sub&gt;3&lt;/sub&gt;, and so on. A single word is trivially a word chain with k == 1. Return *the length of the longest possible word chain with words chosen from the given list of *words. Solution排序+动态规划。采用一个一维动态规划数组记录到某个word的最大字符串链长度。 排序每个predecessor必定比next少1，因此首先将数组根据word的长度排序。 动态规划数组dp[i]记录到i位置时的最大长度。双重遍历i和j，其中j&gt;i。如果words[i-1]是words[j-1]的predecessor，则更新dp[j]为dp[j]与dp[i]+1的较大值。 辅助方法 isValid()判断predecessor是否有效。初始化一个flag为false记录不同字符是否已出现。如果两者长度差不为1直接返回false。双指针分别指向两个字符串，如果两个当前字符相等，则两个指针共同前进。如果不相等且flag为true则i指针前进，并且将flag改为false。否则返回false。如果循环结束返回true。 Code123456789101112131415161718192021222324252627282930313233343536class Solution { public int longestStrChain(String[] words) { int max = 0; Arrays.sort(words, (a,b) -&gt; a.length() - b.length()); int[] dp = new int[words.length+1]; for(int i = 1; i &lt;= words.length; i++){ for(int j = i + 1; j &lt;= words.length; j++){ if(isValid(words[i-1], words[j-1])){ dp[j] = Math.max(dp[j], dp[i] + 1); max = Math.max(max, dp[j]); } } } return max + 1; } private boolean isValid(String predecessor, String next){ if(predecessor.length() + 1 != next.length()) return false; boolean flag = true; int i = 0, j = 0; while(i &lt; next.length() &amp;&amp; j &lt; predecessor.length()){ if(next.charAt(i) == predecessor.charAt(j)){ i++; j++; } else if(flag){ i++; flag = false; } else{ return false; } } return true; }}","link":"/2022/06/15/1048-Longest-String-Chain/"},{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","text":"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree. 先序遍历时，访问的顺序是[根节点 - 左子节点 - 右子节点]。中序遍历时，访问的顺序是[左子节点 - 根节点 - 右子节点]。可以注意到根节点与左子节点的顺序是相反的，因此我们可以利用栈将节点储存起来，当挤出时顺序自然是调转的。 按照先序遍历来创建树，遍历先序数组。同时将指针指向中序遍历的数组的头部。先创建根节点，并将其放入栈中。分为两种情况讨论。 情况一，处理当前根节点的左子节点，并将其入栈： 当栈顶的节点值与中序遍历当前的节点值不同时，说明当前的根节点仍有左子节点。 先序：[根节点 - 左子节点 - 右子节点]中序：[左子节点 - 根节点 - 右子节点] 此时将栈顶的节点的左子节点设置为先序数组对应的节点，继续遍历下一个先序数组。 栈内：[根节点 - 左子节点]先序：[根节点 - 左子节点 - 右子节点]中序：[左子节点 - 根节点 - 右子节点] 情况二，寻找栈内节点们的右子节点： 当栈顶的节点与中序遍历当前的节点值相同时，说明我们经过了当前根节点的先序遍历中的最后一个左子节点。当前先序数组指针指向了当前栈内节点一个右子节点。 栈内：[根节点 - 左子节点]先序：[根节点 - 左子节点 - 右子节点]中序：[左子节点 - 根节点 - 右子节点] 此时我们开始向右移动中序遍历的指针，寻找先序遍历指针中的节点应该是当前栈内哪一个节点的右子节点。此时栈内节点的顺序，与中序遍历的左子节点顺序正好相反。当栈顶与中序遍历的指针相等时，挤出栈顶并将中序指针右移，直到两者不相等或栈空。此时将最后挤出的根节点的右子节点设置为当前先序数组对应的节点，继续遍历下一个先序数组。 当遍历完成后，返回根节点即可。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { int j = 0; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode root = new TreeNode(preorder[0]); stack.add(root); for(int i = 1; i &lt; preorder.length; i++){ TreeNode curr = new TreeNode(preorder[i]); TreeNode prev = stack.peek(); if(inorder[j] != prev.val){ prev.left = curr; stack.add(curr); } else{ while(!stack.isEmpty() &amp;&amp; inorder[j] == stack.peek().val){ prev = stack.pop(); j++; } prev.right = curr; stack.add(curr); } } return root; }}","link":"/2022/05/03/105-Binary-Tree-from-Preorder/"},{"title":"108. Convert Sorted Array to Binary Search Tree","text":"Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. 以中序遍历的顺序创建节点（代码实现时先序遍历），每次选择范围的中间值mid为根节点。根节点的左子节点递归左侧left直到mid-1的位置。根节点的右子节点递归mid+1直到右侧right的位置。当left &gt; right时，返回null作为二叉树的叶子节点。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode sortedArrayToBST(int[] nums) { return build(nums, 0, nums.length-1); } private TreeNode build(int[] nums, int left, int right){ if(left &gt; right) return null; int mid = left + (right - left) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = build(nums, left, mid-1); root.right = build(nums, mid+1, right); return root; }}","link":"/2022/05/02/108-Convert-Sorted-Array-to-Binary-Search-Tree/"},{"title":"1091. Shortest Path in Binary Matrix","text":"Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that: All the visited cells of the path are 0.All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).The length of a clear path is the number of visited cells of this path. 由于不能重复搜索，且需要在搜索时将搜索过的位置改变，因此需要采用BFS逐一层级的搜索。逐层级搜索并记录层级。最后返回层级+1即可。（还有更快的优化算法A*） 整体没有改变太多，基本还是方法二那种。启发式函数改为切比雪夫距离距离。距离计算方法有很多，常用启发式函数有这几种。选择合适的启发式函数有利于速度的提升。这题可以用好几种启发式函数，初学都可以试着都写一下。 曼哈顿距离（Manhattan Distance）一般只能在四个方向上移动时用（右、左、上、下） 对角线距离（Diagonal Distance）：当我们只允许向八个方向移动时用（国际象棋中的王移动方式那种） 欧几里得距离（Euclidean Distance）：不受限制，允许向任何方向移动时。 切比雪夫距离（Chebyshev Distance）：可参考：[https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-le-2/](LeetCode 1266) 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int shortestPathBinaryMatrix(int[][] grid) { int n = grid[0].length; int m = grid.length; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int count = 0; q.add(0); int size = q.size(); while(!q.isEmpty()){ for(int k = 0; k &lt; size; k++){ int curr = q.poll(); int i = curr / n; int j = curr % n; if(grid[i][j] ==1) continue; if(i == m-1 &amp;&amp; j == n-1 &amp;&amp; grid[i][j] == 0) return count+1; if(grid[i][j] == 0){ grid[i][j] = 1; if(i+1&lt;n &amp;&amp; j+1&lt;n) q.add((i+1) * n + (j+1)); if(i+1&lt;n &amp;&amp; j-1&gt;=0) q.add((i+1) * n + (j-1)); if(i+1&lt;n) q.add((i+1) * n + j); if(i-1&gt;=0 &amp;&amp; j-1&gt;=0) q.add((i-1) * n + (j-1)); if(i-1&gt;=0 &amp;&amp; j+1&lt;n) q.add((i-1) * n + (j+1)); if(j+1&lt;n) q.add(i * n + (j+1)); if(j-1&gt;=0) q.add(i * n + (j-1)); if(i-1&gt;=0) q.add((i-1) * n + j); } } size = q.size(); count++; } return -1; }}","link":"/2022/04/23/1091-Shortest-Path-in-Binary-Matrix/"},{"title":"1108. Defanging an IP Address","text":"Question Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period &quot;.&quot; with &quot;[.]&quot;. Solution迭代每个字符，用StringBuffer类来组成新的字符串。 Code1234567891011121314class Solution { public String defangIPaddr(String address) { StringBuffer sb = new StringBuffer(); for(char c : address.toCharArray()){ if(c == '.'){ sb.append(&quot;[.]&quot;); } else{ sb.append(c); } } return sb.toString(); }}","link":"/2022/06/21/1108-Defanging-an-IP-Address/"},{"title":"112. Path Sum","text":"问题Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. 递归，如果当前节点为null则返回false。计算并更新当前节点的值。如果当前节点为叶节点，且当前节点的值等于target，则返回true。递归左子节点和右子节点，返回两者的或运算。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { return hasPathSum(root,0,targetSum); } private boolean hasPathSum(TreeNode root, int parentVal, int target){ if (root == null){return false;} root.val = root.val + parentVal; if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target){ return true; } return ( hasPathSum(root.left, root.val, target) || hasPathSum(root.right, root.val, target)); }}","link":"/2022/04/14/112-Path-Sum/"},{"title":"11. Container With Most Water","text":"问题You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container. 双指针在首尾，二者容量取决于两者中较小的一个。贪心算法，保留两个指针上较大的元素，移动较小一边的指针。由于指针移动时距离只会减小，因此当新的元素比上一个更大时才有可能比之前的容量更大。遍历一次找到最大容量。时间复杂度：O(n) 感觉这个移动有点博弈论的味了，每次都移动自己最差的一边，虽然可能变得更差，但是总比不动（或者减小）强，动最差的部分可能找到更好的结果，但是动另一边总会更差或者不变，兄弟们，这不是题，这是人生，逃离舒适圈！！（这解释我觉得无敌了，哈哈哈） 12345678910111213141516171819202122232425class Solution { public int maxArea(int[] height) { int best = 0; int i = 0; int j = height.length - 1; while ( i &lt; j ){ int product = 0; if (height[i] &lt; height[j]){ product = height[i] * ( j -i ); i++; } else{ product = height[j] * ( j -i ); j--; } if ( product &gt; best){ best = product; } } return best; }}","link":"/2022/04/06/11-Container-With-Most-Water/"},{"title":"113. Path Sum II","text":"Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. 回溯，每次将root的值添加到list中。并计算新的sum值。分别向左右子节点进行递归，然后回溯。当节点没有左右子节点，且sum等于targetSum则将新建的list添加到结果中。（注意这一步内也需要进行回溯操作。） 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;List&lt;Integer&gt;&gt; ret; int target; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { ret = new ArrayList&lt;&gt;(); if(root == null) return ret; target = targetSum; backTrack(root, 0, new ArrayList&lt;&gt;()); return ret; } private void backTrack(TreeNode root, int sum, List&lt;Integer&gt; nodes){ if(root.left == null &amp;&amp; root.right == null){ sum += root.val; if(sum == target){ nodes.add(root.val); ret.add(new ArrayList&lt;Integer&gt;(nodes)); nodes.remove(nodes.size()-1); } return; } nodes.add(root.val); sum += root.val; if(root.left != null) backTrack(root.left, sum, nodes); if(root.right != null) backTrack(root.right, sum, nodes); nodes.remove(nodes.size()-1); sum -= root.val; }}","link":"/2022/05/02/113-Path-Sum-II/"},{"title":"114. Flatten Binary Tree to Linked List","text":"Question Given the root of a binary tree, flatten the tree into a “linked list”: The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The “linked list” should be in the same order as a pre-order** traversal** of the binary tree. Solution全局变量prev，初始化为null，用来记录上一个访问的节点。 由于最后要达到先序遍历（根节点-左子节点-右子节点）的数据结构顺序，因此在进行访问时需要与先序遍历的操作相反，首先递归右子节点，然后递归左子节点，最后修改当前节点。 先遍历当前节点的右侧节点，再遍历当前节点的左侧节点。最后处理当前节点，将左子节点设置为null，右子节点设置为prev。最后将当前节点保存在prev上。 Code1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { TreeNode prev = null; public void flatten(TreeNode root) { if(root == null) return; flatten(root.right); //traverse right nodes first flatten(root.left); //traverse left nodes root.left = null; //set current node's left child node to null root.right = prev; //set current node's right child node to previous node prev = root; //update previous node }}","link":"/2022/07/27/114-Flatten-Binary-Tree-to-Linked-List/"},{"title":"1143. Longest Common Subsequence","text":"Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, “ace” is a subsequence of “abcde”.A common subsequence of two strings is a subsequence that is common to both strings. 动态规划，dp的长和宽分别为两个字符串的长度。遍历dp字符串的长和宽。（注意在第一层遍历时先保存当前选择的字符可以提升速度。）当两个字符串相同时，则可以从上一个状态+1。注意状态转移方程的上一个状态应该是从对角线方向+1。当两个字符串不同时，则继续保存之前的最大长度。 123456789101112131415161718192021class Solution { public int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m+1][n+1]; char[] bin1 = text1.toCharArray(); char[] bin2 = text2.toCharArray(); for(int i = 1; i &lt;= m; i++){ int k = bin1[i-1]; for(int j = 1; j &lt;= n ; j++){ if(k == bin2[j-1]){ dp[i][j] = dp[i-1][j-1]+1; } else{ dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; }}","link":"/2022/05/02/1143-Longest-Common-Subsequence/"},{"title":"116. Populating Next Right Pointers in Each Node","text":"问题You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: 123456 struct Node { int val; Node *left; Node *right; Node *next;&gt;} Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 递归，当root为null时返回。如果root有右节点，则左节点next指向右节点。如果root有右节点同时next已经指向了一个节点，则将其右节点next指向该节点的左子节点。递归左右子节点，并返回root。 1234567891011121314151617181920212223242526272829303132333435363738/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/class Solution { public Node connect(Node root) { if (root==null){return root;} if (root.right!=null){ root.left.next = root.right; if (root.next!=null){ root.right.next = root.next.left; } } connect(root.left); connect(root.right); return root; }} BFS搜索每一个节点，将节点指向队列中next下一个节点。当计数器达到2的指数时，将节点指向null。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public Node connect(Node root) { if (root == null){ return root; } int count = 1; Queue&lt;Node&gt; q = new LinkedList(); q.offer(root); while (!q.isEmpty()){ count++; Node curr = q.poll(); if ( isPow(count) ){ curr.next = null; } else{ curr.next = q.peek(); } if(curr.left!=null){ q.add(curr.left); } if(curr.right!=null){ q.add(curr.right); } } return root; } private boolean isPow(int val){ if(val == 0 || val == 1){ return false; } while ( val % 2 == 0 ){ val = val / 2; } if (val == 1){ return true; } return false; }}","link":"/2022/04/10/116-Populating-Next-Right-Pointers-in-Each-Node/"},{"title":"117. Populating Next Pointers in Each Node II","text":"Question Given a binary tree 123456struct Node { int val; Node *left; Node *right; Node *next;} Populate each next pointer to point to its next right node. If &gt; there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. SolutionBFS搜索，从右至左将每层节点放入队列。用一个size记录该层级放入节点的数量，每次循环将size-1，当size归零时放入新一层级的节点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445/*// Definition for a Node.class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; }};*/class Solution { public Node connect(Node root) { if(root == null) return root; Queue&lt;Node&gt; q = new LinkedList(); q.add(root); while(!q.isEmpty()){ int size = q.size(); Node next = null; while(size &gt; 0){ size--; Node curr = q.poll(); curr.next = next; next = curr; if(curr.right != null) q.add(curr.right); if(curr.left != null) q.add(curr.left); } } return root; }}","link":"/2022/04/21/117-Populating-Next-Pointers-in-Each-Node-II/"},{"title":"118. Pascal&#39;s Triangle","text":"Given an integer numRows, return the first numRows of Pascal’s triangle. 动态规划，直接按照杨辉三角形的定义计算。 123456789101112131415161718192021class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { ArrayList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(numRows); for (int i = 0; i &lt; numRows ; i++){ List&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(i+1); for (int j = 0; j &lt;= i; j++){ if ( j == 0 || j == i ){ arr.add(1); } else{ arr.add(ans.get(i-1).get(j-1)+ans.get(i-1).get(j)); } } ans.add(arr); } return ans; }}","link":"/2022/04/06/118-Pascal-s-Triangle/"},{"title":"119. Pascal&#39;s Triangle II","text":"Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: 根据杨辉三角形的规则递归。每次递归行数-1。根据上一行的返回值，生成新行的列表，然后返回。如果生成行数为0则返回{1}。 12345678910111213141516171819202122class Solution { public List&lt;Integer&gt; getRow(int rowIndex) { if(rowIndex == 0){ List&lt;Integer&gt; ret = new ArrayList(); ret.add(1); return ret; } List&lt;Integer&gt; arr = getRow(rowIndex - 1); List&lt;Integer&gt; ret = new ArrayList(); for(int i = 0; i &lt; arr.size()+1; i++){ if(i == 0 || i == arr.size()){ ret.add(1); } else{ ret.add(arr.get(i) + arr.get(i-1)); } } return ret; }}","link":"/2022/04/18/119-Pascal-s-Triangle-II/"},{"title":"120. Triangle","text":"问题Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. 动态规划，先将最左侧一列的值算出。然后[i+1][j+1]根据[i][j+1]和[i][j]得出。该动态规划表应是为三角形。因此当i等于j时，[i+1][i+j]的数值只根据[i][j]得出。 例子：代码里插入了一个print方法打印动态规划表。当输入列表 [[2],[3,4],[6,5,7],[4,1,8,3]] 时：其动态规划表为： 2, 0, 0, 0, 5, 6, 0, 0, 11, 10, 13, 0, 15, 11, 18, 16, 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int[][] dp = new int[triangle.size()][triangle.size()]; int min = Integer.MAX_VALUE; dp[0][0] = triangle.get(0).get(0); for (int i = 0; i &lt; triangle.size()-1; i++){ dp[i+1][0] = dp[i][0] + triangle.get(i+1).get(0); } for (int i = 0; i &lt; triangle.size()-1; i++){ for (int j = 0; j &lt;= i; j++){ if ( i == j ){ dp[i+1][j+1] = dp[i][j] + triangle.get(i+1).get(j+1); } else{ dp[i+1][j+1] = Math.min(dp[i][j] + triangle.get(i+1).get(j+1), dp[i][j+1] + triangle.get(i+1).get(j+1)); } } } //print(dp); for (int k = 0; k &lt; triangle.size(); k++){ min = Math.min(dp[triangle.size()-1][k],min); } return min; } private void print(int[][] text){ for (int i = 0; i &lt;text.length; i++){ for (int j = 0; j &lt; text[0].length; j++){ System.out.print(text[i][j]+&quot;, &quot;); } System.out.println(); } }}","link":"/2022/04/14/120-Triangle/"},{"title":"1192. Critical Connections in a Network","text":"Question There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;] represents a connection between servers a&lt;sub&gt;i&lt;/sub&gt; and b&lt;sub&gt;i&lt;/sub&gt;. Any server can reach other servers directly or indirectly through the network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order. Solution参考：# 60 分钟搞定图论中的 Tarjan 算法 根据connections建立图（采用数组记录图速度比用哈希表实现快）。然后采用Tarjon算法寻找图中的桥。 时间戳按访问顺序为数组dfn[]添加顺序。(dfn = depth first (traversal) number) 搜索树在无向图中，每一次从u节点出发进行DFS搜索，每个节点只访问一次，所有被访问过的节点与边构成一棵树，称之为“无向连通图的搜索树” 追溯值数组low[]记录从当前节点u出发时，能够访问到的所有节点中，时间戳最小的值。 无向图的桥的判定法则在一张无向图中，判断边 e （其对应的两个节点分别为 u 与 v）是否为桥，需要其满足如下条件即可：dfn[u] &lt; low[v] Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { int num; int[] visited; int[] dfn; int[] low; List&lt;List&lt;Integer&gt;&gt; ret; List&lt;Integer&gt;[] graph; public List&lt;List&lt;Integer&gt;&gt; criticalConnections(int n, List&lt;List&lt;Integer&gt;&gt; connections) { num = 0; ret = new ArrayList&lt;&gt;(); visited = new int[n]; dfn = new int[n]; low = new int[n]; graph = new ArrayList[n]; buildGraph(n, connections); tarjan(0, -1); return ret; } private void tarjan(int u, int parent){ dfn[u] = low[u] = num++; //记录节点遍历的顺序并初始化low值 visited[u] = 1; for(Integer v : graph[u]){ if(v == parent) continue; if(visited[v] == 0){ //搜索未搜索过的相邻节点 tarjan(v, u); low[u] = Math.min(low[u], low[v]); //搜索相邻节点后，更新访问的最小值 if(dfn[u] &lt; low[v]){ //满足桥的定义时添加结果 List&lt;Integer&gt; e = new ArrayList&lt;&gt;(); e.add(u); e.add(v); ret.add(e); } } else{ low[u] = Math.min(low[u], dfn[v]); //如果搜索过相邻节点，则判断这两个值得最小值并更新 } } } private void buildGraph(int n, List&lt;List&lt;Integer&gt;&gt; connections){ for(int i = 0; i &lt; n; i++){ graph[i]=new ArrayList&lt;&gt;(); } for(List&lt;Integer&gt; e : connections){ int v1 = e.get(0); int v2 = e.get(1); graph[v1].add(v2); graph[v2].add(v1); } }}","link":"/2022/05/18/1192-Critical-Connections-in-a-Network/"},{"title":"1202. Smallest String With Swaps","text":"You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps. 并查集，注意要使用路径压缩否则会超时。先将所有配对联通。然后创建一个数组group记录每个字符串位置的分组情况。根据分组，借助优先队列保存字符串。通过哈希表创建group和PriorityQueue的映射。按当前位置的分组情况和优先队列的顺序来添加字符串。最后返回字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) { StringBuffer sb = new StringBuffer(); UnionFind uf = new UnionFind(s.length()); for(List&lt;Integer&gt; pair : pairs){ uf.union(pair.get(0), pair.get(1)); } int[] group = new int[s.length()]; for(int i = 0; i &lt; s.length(); i++){ group[i] = uf.find(i); } HashMap&lt;Integer, PriorityQueue&lt;Character&gt;&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++){ PriorityQueue&lt;Character&gt; bin = map.getOrDefault(group[i], new PriorityQueue&lt;Character&gt;()); bin.add(s.charAt(i)); map.put(group[i], bin); } for(int i = 0; i &lt; s.length(); i++){ sb.append(map.get(group[i]).poll()); } return sb.toString(); } class UnionFind { int[] parent; int[] count; public UnionFind(int n){ parent = new int[n]; count = new int[n]; for(int i = 0; i &lt; n; i++){ parent[i] = i; count[i] = 1; } } private int find(int id){ if(parent[id] == id) return id; parent[id] = find(parent[id]); return parent[id]; } private boolean union(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; if(count[p1] &gt; count[p2]) parent[p2] = p1; else parent[p1] = p2; return true; } }}","link":"/2022/04/27/1202-Smallest-String-With-Swaps/"},{"title":"1209. Remove All Adjacent Duplicates in String II","text":"Question You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique. Solution用一个栈保存当前的字符，同时建立一个cnt[]数组记录当前字符连续出现的次数。 遍历字符串。 如果当前的字符与栈顶的字符相同时，获取数组中记录的当前连续次数lastCount并加一。如果lastCount等于k，则匹配到了足够的字符，去掉栈顶的k - 1个元素。否则将字符串加入栈顶，记录当前位置的出现次数lastCount。 如果当前字符与栈顶字符不同，则将字符直接加入栈顶，记录当前位置的cnt[dq.size()]为1。 最后将栈内元素倒序组成字符串。由于需要这一步操作，因此之前的栈采用双端队列实现。 Code12345678910111213141516171819202122232425262728293031323334class Solution { public String removeDuplicates(String s, int k) { Deque&lt;Character&gt; dq = new LinkedList&lt;Character&gt;(); int[] cnt = new int[s.length()+1]; for(int i = 0; i &lt; s.length(); i++){ char c = s.charAt(i); if(i &gt; 0 &amp;&amp; !dq.isEmpty() &amp;&amp; dq.peek() == c){ int lastCount = cnt[dq.size()]; lastCount++; if(lastCount == k){ while(lastCount != 1){ dq.removeFirst(); lastCount--; } } else{ dq.offerFirst(c); cnt[dq.size()] = lastCount; } } else{ dq.offerFirst(c); cnt[dq.size()] = 1; } } StringBuffer sb = new StringBuffer(); while(!dq.isEmpty()){ sb.append(dq.removeLast()); } return sb.toString(); }}","link":"/2022/05/06/1209-Remove-All-Adjacent-Duplicates-in-String-II/"},{"title":"121. Best Time to Buy and Sell Stock","text":"问题描述You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. 采用dp的思想，先计算一遍盈利差，再计算一遍最大收益。空间上还可以优化。 12345678910111213141516171819class Solution { public int maxProfit(int[] prices) { int best = 0; int[] difference = new int[prices.length]; difference[0] = 0; for (int i = 1; i &lt; prices.length; i++ ){ difference[i] = prices[i] - prices[i - 1]; if ( difference[i] + difference[i - 1] &gt; difference[i] ){ difference[i] = difference[i] + difference[i - 1]; } if (difference[i] &gt; best){ best = difference[i]; } } return best; }}","link":"/2022/04/05/121-Best-Time-to-Buy-and-Sell-Stock/"},{"title":"1220. Count Vowels Permutation","text":"Question Given an integer n, your task is to count how many strings of length n can be formed under the following rules: Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u') Each vowel 'a' may only be followed by an 'e'. Each vowel 'e' may only be followed by an 'a' or an 'i'. Each vowel 'i' may not be followed by another 'i'. Each vowel 'o' may only be followed by an 'i' or a 'u'. Each vowel 'u' may only be followed by an 'a'. Since the answer may be too large, return it modulo 10^9 + 7. SolutionDFS搜索，记忆化剪枝。每次根据上一个字母last来从哈希表里选择下一个可选字母进行遍历，并计算总的可组成数sum。 Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { final int MOD = (int) Math.pow(10, 9) + 7; int[][] memo; HashMap&lt;Character, Character[]&gt; map; public int countVowelPermutation(int n) { if(n == 1) return 5; map = new HashMap&lt;&gt;(); memo = new int[26][n+1]; Character[] vowels = {'a', 'e', 'i', 'o', 'u'}, a = {'e'}, e = {'a','i'}, i = {'a','e','o','u'}, o = {'i', 'u'}, u = {'a'}; map.put('a', a); map.put('e', e); map.put('i', i); map.put('o', o); map.put('u', u); int ans = 0; for(char vowel : vowels){ ans += count(vowel, n-1); ans %= MOD; } return ans; } private int count(char last, int n){ if(memo[last-'a'][n] != 0) return memo[last-'a'][n]; if(n == 1){ memo[last-'a'][n] = map.get(last).length; return memo[last-'a'][n]; } int sum = 0; for(char next : map.get(last)){ sum += count(next, n-1); sum %= MOD; } memo[last-'a'][n] = sum; return sum; }}","link":"/2022/08/06/1220-Count-Vowels-Permutation/"},{"title":"1249. Minimum Remove to Make Valid Parentheses","text":"Given a string s of ‘(‘ , ‘)’ and lowercase English characters. Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if: It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. 用栈储存括号，按顺序将括号压入栈。如果和上一个括号配对，则挤出上一个括号。 当栈不为空时，如果栈顶的符号为“)”，则优先去掉字符串左侧的括号。如果栈顶的符号为“(”，则优先去掉字符串右侧的括号。最后返回字符串。 1234567891011121314151617181920212223242526class Solution { public String minRemoveToMakeValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); StringBuffer sb = new StringBuffer(s); for(int i = 0; i &lt; s.length(); i++){ if(s.charAt(i) == '(') stack.push('('); else if(s.charAt(i) == ')'){ if(!stack.isEmpty() &amp;&amp; stack.peek() == '(') stack.pop(); else stack.push(')'); } } while(!stack.isEmpty()){ if(stack.pop() == ')'){ int index = sb.indexOf(&quot;)&quot;); sb.delete(index, index+1); } else{ int index = sb.lastIndexOf(&quot;(&quot;); sb.delete(index, index+1); } } return sb.toString(); }}","link":"/2022/04/30/1249-Minimum-Remove-to-Make-Valid-Parentheses/"},{"title":"1260. Shift 2D Grid","text":"问题Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: Element at grid[i][j] moves to grid[i][j + 1].Element at grid[i][n - 1] moves to grid[i + 1][0].Element at grid[m - 1][n - 1] moves to grid[0][0].Return the 2D grid after applying shift operation k times. 遍历整个数组，将索引值加上移动的次数，得到新的位置。 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); int row = grid.length; int col = grid[0].length; int size = row * col; Integer[][] mat = new Integer[row][col]; for (int i = 0; i &lt; size; i++){ int j = i + k; if ( j &gt; size - 1){ j %= size; } int nr = j / col; int nc = j % col; int or = i / col; int oc = i % col; mat[nr][nc] = grid[or][oc]; } for (int i = 0; i &lt; row; i++){ List&lt;Integer&gt; nums = Arrays.asList(mat[i]); ans.add(nums); } return ans; }}","link":"/2022/04/11/1260-Shift-2D-Grid/"},{"title":"1268. Search Suggestions System","text":"Question You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed. Solution字典树+优先级队列。在TrieNode节点中保存PriorityQueue，以记录该节点下的三个单词。注意PriorityQueue中的String需要按倒序排列，以保证维护时可以直接poll掉字符顺序较后的单词。 add()方法创建并添加TrieNode节点，同时在移动当前节点位置时，需要维护PriorityQueue，当长度大于3时，则挤出字典顺序排列较后的单词。 search()方法在查找前缀时，将每个TrieNode节点上的PriorityQueue倒序加入List。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { class TrieNode{ boolean end; TrieNode[] children = new TrieNode[26]; PriorityQueue&lt;String&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; b.compareTo(a)); } TrieNode root; public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) { List&lt;List&lt;String&gt;&gt; ret = new ArrayList&lt;&gt;(); root = new TrieNode(); for(String word : products){ add(word); } return search(searchWord); } private void add(String word){ TrieNode curr = root; for(char c : word.toCharArray()){ int i = c - 'a'; if(curr.children[i] == null) curr.children[i] = new TrieNode(); curr = curr.children[i]; curr.q.add(word); if(curr.q.size() &gt; 3) curr.q.poll(); } curr.end = true; } private List&lt;List&lt;String&gt;&gt; search(String prefix){ List&lt;List&lt;String&gt;&gt; ret = new ArrayList&lt;&gt;(); TrieNode curr = root; for(char c : prefix.toCharArray()){ int i = c - 'a'; if(curr.children[i] == null) curr.children[i] = new TrieNode(); curr = curr.children[i]; List&lt;String&gt; temp = new ArrayList&lt;&gt;(); while(!curr.q.isEmpty()){ temp.add(curr.q.poll()); } Collections.reverse(temp); ret.add(temp); } return ret; }}","link":"/2022/06/19/1268-Search-Suggestions-System/"},{"title":"128. Longest Consecutive Sequence","text":"Question Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Solution 1哈希表，先将所有元素加入哈希表。然后遍历哈希表，如果表内没有当前数字-1时（没有更小的连续数字），则将temp初始化为1。当表内有下一个连续数字时，将temp和curNum增加1。 当没有下一个连续数字时，更新结果到res上。 Code123456789101112131415161718192021222324class Solution { public int longestConsecutive(int[] nums) { HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : nums){ set.add(num); } int res = 0; for(int num : set){ if(!set.contains(num - 1)){ int temp = 1; int curNum = num; while(set.contains(curNum + 1)){ temp++; curNum++; } res = Math.max(res, temp); } } return res; }} Solution 2先排序，再遍历。维护一个最大长度res。用一个temp参数记录连续长度。如果当前值是上一个值+1，则temp+1。如果当前值等于上一个值，则continue。其他情况则更新最大长度res，并将temp恢复为1。 Code1234567891011121314151617181920212223class Solution { public int longestConsecutive(int[] nums) { if(nums.length == 0) return 0; Arrays.sort(nums); int res = 0, temp = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i] == nums[i-1] + 1){ temp++; } else if(nums[i] == nums[i-1]){ continue; } else{ res = Math.max(res, temp); temp = 1; } } res = Math.max(res, temp); return res; }}","link":"/2022/07/05/128-Longest-Consecutive-Sequence/"},{"title":"13. Roman to Integer","text":"Question Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Solution倒叙遍历，记录几个mark以标注是否出现对应的字母。 初始res为0，根据字符加减数值。如果出现则将mark设置为真。如果mark为真，且上一个字符出现对应需要减去的罗马字符，则改加为减。 最后返回res值。 Code1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int romanToInt(String s) { int res = 0; boolean markX = false, markC = false, markM = false; for(int i = s.length()-1; i &gt;= 0; i--){ char c = s.charAt(i); if(c == 'I'){ if(markX) res -= 1; else res += 1; } else if(c == 'V'){ markX = true; res += 5; } else if(c == 'X'){ markX = true; if(markC) res -= 10; else res += 10; } else if(c == 'L'){ markC = true; res += 50; } else if(c == 'C'){ markC = true; if(markM) res -= 100; else res += 100; } else if(c == 'D'){ markM = true; res += 500; } else if(c == 'M'){ markM = true; res += 1000; } } return res; }}","link":"/2022/08/15/13-Roman-to-Integer/"},{"title":"130. Surrounded Regions","text":"Question Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Solution首先对所有在边缘上的“O”进行BFS或DFS搜索，将和边缘连续的“O”改为“#”或任意其他字符。 然后遍历整个board，如果是“O”则改为“X”，如果是“#”则恢复为“O”。 Code123456789101112131415161718192021222324252627282930313233343536373839class Solution { public void solve(char[][] board) { for(int i = 0; i &lt;board.length; i++){ for(int j = 0; j &lt;board[0].length; j++){ boolean isEdge = (i == 0 || j == 0 || i == board.length-1 || j == board[0].length-1); if(isEdge &amp;&amp; board[i][j] == 'O'){ bfs(board, i, j); } } } for(int i = 0; i &lt; board.length; i++){ for(int j = 0; j &lt; board[0].length; j++){ if(board[i][j] == '#') board[i][j] = 'O'; else if(board[i][j] == 'O') board[i][j] = 'X'; } } } private void bfs(char[][] board, int x, int y){ int m = board.length; int n = board[0].length; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); q.add(new int[]{x, y}); int size = 1; while(!q.isEmpty()){ for(int k = 0; k &lt; size; k++){ int[] curr = q.poll(); int i = curr[0], j = curr[1]; if( i&lt;0 || j&lt;0 || i&gt;m-1 || j&gt;n-1 || board[i][j] == 'X' || board[i][j] == '#' ) continue; board[i][j] = '#'; q.add(new int[]{i+1,j}); q.add(new int[]{i-1,j}); q.add(new int[]{i,j+1}); q.add(new int[]{i,j-1}); } size = q.size(); } }}","link":"/2022/05/05/130-Surrounded-Regions/"},{"title":"1302. Deepest Leaves Sum","text":"Question Given the root of a binary tree, return the sum of values of its deepest leaves. SolutionBFS搜索，层序遍历，每次计算每个层级的总和。最后返回最后一个层级总和。 Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int deepestLeavesSum(TreeNode root) { Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); int res = 0; q.offer(root); int level = q.size(); while(!q.isEmpty()){ int sum = 0; for(int i = 0; i &lt; level; i++){ TreeNode curr = q.poll(); sum += curr.val; if(curr.left != null) q.offer(curr.left); if(curr.right != null) q.offer(curr.right); } res = sum; level = q.size(); } return res; }}","link":"/2022/05/15/1302-Deepest-Leaves-Sum/"},{"title":"1329. Sort the Matrix Diagonally","text":"Question A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix’s end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2]. Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix. Solution分别遍历数组的两条边。按对角线顺序进行遍历，用列表记录访问过的数字。排序列表后按对角线填入原数组。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public int[][] diagonalSort(int[][] mat) { int m = mat.length, n = mat[0].length; List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); for(int t = 0; t &lt; m; t++){ int i = t, j = 0; while(i &lt; m &amp;&amp; j &lt; n){ arr.add(mat[i][j]); i++; j++; } Collections.sort(arr); i = t; j = 0; while(i &lt; m &amp;&amp; j &lt; n){ mat[i][j] = arr.get(j); i++; j++; } arr.clear(); } for(int t = 1; t &lt; n; t++){ int i = 0, j = t; while(i &lt; m &amp;&amp; j &lt; n){ arr.add(mat[i][j]); i++; j++; } Collections.sort(arr); i = 0; j = t; while(i &lt; m &amp;&amp; j &lt; n){ mat[i][j] = arr.get(i); i++; j++; } arr.clear(); } return mat; }}","link":"/2022/08/27/1329-Sort-the-Matrix-Diagonally/"},{"title":"1332. Remove Palindromic Subsequences","text":"Question You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous. A string is called palindrome if is one that reads the same backward as well as forward. Solution当字符为空时，返回0。注意本题中的子序列不需要连续。由于只有’a’与’b’两个字符，因此最多两步即可将字符串清空。 辅助方法判断字符串是否为回文字符串。如果为真则返回1，只需要删除一次。 如果为假则返回2，需要先删除所有的’a’，再删除所有的’b’。 Code12345678910111213141516class Solution { public int removePalindromeSub(String s) { if(s.length() == 0) return 0; return isPalindrome(s) ? 1 : 2; } private boolean isPalindrome(String s){ int i = 0, j = s.length() - 1; while(j &gt; i){ if(s.charAt(i) != s.charAt(j)) return false; i++; j--; } return true; }}","link":"/2022/06/09/1332-Remove-Palindromic-Subsequences/"},{"title":"1342. Number of Steps to Reduce a Number to Zero","text":"Question Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Solution循环，当num不等于零时，如果为奇数则减一，如果为偶数则除以2。每次循环记录次数。 Code123456789101112131415class Solution { public int numberOfSteps(int num) { int count =0; while(num != 0){ count++; if((num &amp; 1) == 0){ num/=2; } else{ num--; } } return count; }}","link":"/2022/05/27/1342-Number-of-Steps-to-Reduce-a-Number-to-Zero/"},{"title":"135. Candy","text":"Question There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children. Solution双向遍历。先从左至右遍历数组，如果上一个数值小于当前数值，则当前糖果等于上一个糖果数+1。然后从右至左遍历数组，同理计算right的数值。然后保存right与left[]里较大的数值，作为需要分配的糖果数加入到res。 Code12345678910111213141516171819202122232425class Solution { public int candy(int[] ratings) { int[] left = new int[ratings.length]; for(int i = 0; i &lt; ratings.length; i++){ if(i &gt; 0 &amp;&amp; ratings[i] &gt; ratings[i-1]){ left[i] = left[i-1] + 1; } else{ left[i] = 1; } } int right = 0, res = 0; for(int i = ratings.length-1; i &gt;= 0; i--){ if(i &lt; ratings.length-1 &amp;&amp; ratings[i] &gt; ratings[i+1]){ right++; } else{ right = 1; } res += Math.max(left[i], right); } return res; }}","link":"/2022/07/04/135-Candy/"},{"title":"1379. Find a Node of a Binary Tree in a Clone Tree","text":"Question Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree. SolutionDFS搜索，同步递归original和cloned的子节点。当在original里找到target的时候返回当前的cloned节点。 注意可以先判断一个分支中的返回值是否为空，如果不为空则直接返回。反之则返回另一个分支。这样操作可以进行一部分剪枝。 Code1234567891011121314151617181920/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) { if(original == null) return null; if(original.equals(target)) return cloned; TreeNode left = getTargetCopy(original.left, cloned.left, target); if(left != null) return left; else return getTargetCopy(original.right, cloned.right, target); }}","link":"/2022/05/18/1379-Find-a-Node-of-a-Binary-Tree-in-a-Clone-Tree/"},{"title":"136. Single Number","text":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. 位运算，对所有数值做二进制异或运算。两个同样的值异或运算会等于0，最后和与单独的数字相等。 123456789class Solution { public int singleNumber(int[] nums) { int ans = 0; for(int num : nums){ ans = ans ^ num; } return ans; }} 排序，然后遍历数组，如果第i个值不等于第i+1个则返回。 1234567891011class Solution { public int singleNumber(int[] nums) { Arrays.sort(nums); for(int i = 0; i &lt; nums.length-1; i+=2){ if(nums[i] != nums[i+1]){ return nums[i]; } } return nums[nums.length-1]; }}","link":"/2022/04/16/136-Single-Number/"},{"title":"1383. Maximum Performance of a Team","text":"Question You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the i&lt;sup&gt;th&lt;/sup&gt; engineer respectively. Choose at most k different engineers out of the n engineers to form a team with the maximum performance. The performance of a team is the sum of their engineers’ speeds multiplied by the minimum efficiency among their engineers. Return the maximum performance of this team. Since the answer can be a huge number, return it modulo 10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7. Solution排序，将所有工程师根据其效率降序排列。 此时遍历时后一个工程师的效率一定小于等于前一个工程师。 因此，此时遍历到每一个工程师，其前面所有的工程师的efficiency均大于等于其本身。维护一个所有选取工程师的总速度ttSpd，每次计算并更新max的值。用最小堆来维护选取的工程师速度，如果优先级队列的尺寸超过k-1，则poll掉队列内最低的速度。 Code12345678910111213141516171819202122232425262728293031class Solution { public int maxPerformance(int n, int[] speed, int[] efficiency, int k) { final int mod = (int) Math.pow(10, 9) + 7; int[][] engineer = new int[n][2]; for(int i = 0; i &lt; n; i++){ engineer[i][0] = speed[i]; engineer[i][1] = efficiency[i]; } Arrays.sort(engineer, new Comparator&lt;int[]&gt;(){ public int compare(int[] a, int[] b){ return b[1] - a[1]; } }); long max = 0, ttSpd = 0; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); for(int i = 0; i &lt; n; i++){ int s = engineer[i][0], e = engineer[i][1]; ttSpd += s; max = Math.max(max, ttSpd * e); pq.add(s); if(pq.size() == k) ttSpd -= pq.poll(); } return (int) (max % mod); }}","link":"/2022/09/11/1383-Maximum-Performance-of-a-Team/"},{"title":"139. Word Break","text":"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. 动态规划，创建一个数组dp[]，长度为字符串长度+1，记录是否可以达到。将dp[0]设置为1，表示可以达到。 从可取长度为1开始，遍历直到可取长度为字符串的长度。用下一个遍历j将字符串分为两部分。（这里j从i-1下降到0会比从0上升到i-1更快。）当dp[j]可以到达，且当前的哈希表中有(i-j)组成的字符串时，则dp[i]也可以到达。结束第二层循环。继续搜索更长的字符串是否可以达到。最后返回dp中的最后一个元素。 12345678910111213141516171819202122class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); int n = s.length(); int[] dp = new int[n+1]; for(String word : wordDict){ set.add(word); } dp[0] = 1; int temp = 0; for(int i = 1; i &lt;= n; i++){ for(int j = i - 1; j &gt;= 0; j--){ if(dp[j] == 1 &amp;&amp; set.contains(s.substring(j, i))){ dp[i] = 1; break; } } } return dp[n] == 1; }}","link":"/2022/05/01/139-Word-Break/"},{"title":"1396. Design Underground System","text":"An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the UndergroundSystem class: void checkIn(int id, string stationName, int t) A customer with a card ID equal to id, checks in at the station stationName at time t. A customer can only be checked into one place at a time. void checkOut(int id, string stationName, int t) A customer with a card ID equal to id, checks out from the station stationName at time t. double getAverageTime(string startStation, string endStation) Returns the average time it takes to travel from startStation to endStation. The average time is computed from all the previous traveling times from startStation to endStation that happened directly, meaning a check in at startStation followed by a check out from endStation. The time it takes to travel from startStation to endStation may be different from the time it takes to travel from endStation to startStation. There will be at least one customer that has traveled from startStation to endStation before getAverageTime is called.You may assume all calls to the checkIn and checkOut methods are consistent. If a customer checks in at time t1 then checks out at time t2, then t1 &lt; t2. All events happen in chronological order. 两个哈希表，第一个暂存id。第二个用来储存“站点——站点”和路线中的总用时，路线中的总人数。最后返回总用时除以总人数。（一开始采用的算法没有考虑id重复进站，和id出站进站不同的情况。） 12345678910111213141516171819202122232425262728293031323334353637class UndergroundSystem { HashMap&lt;Integer, Pair&lt;String, Integer&gt;&gt; inMap; HashMap&lt;String, int[]&gt; outMap; public UndergroundSystem() { inMap = new HashMap&lt;Integer, Pair&lt;String, Integer&gt;&gt;(); outMap = new HashMap&lt;String, int[]&gt;(); } public void checkIn(int id, String stationName, int t) { Pair&lt;String, Integer&gt; data = new Pair(stationName, t); inMap.put(id, data); } public void checkOut(int id, String stationName, int t) { Pair&lt;String, Integer&gt; data = inMap.get(id); String route = data.getKey() + &quot;-&quot; + stationName; int[] routeData = outMap.getOrDefault(route, new int[2]); routeData[0] += t - data.getValue(); routeData[1]++; outMap.put(route, routeData); } public double getAverageTime(String startStation, String endStation) { String route = startStation + &quot;-&quot; + endStation; return outMap.get(route)[0] / (double) outMap.get(route)[1]; }}/** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem obj = new UndergroundSystem(); * obj.checkIn(id,stationName,t); * obj.checkOut(id,stationName,t); * double param_3 = obj.getAverageTime(startStation,endStation); */","link":"/2022/04/24/1396-Design-Underground-System/"},{"title":"141. Linked List Cycle","text":"问题Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. 遍历并移动快慢指针。如两个指针最终相遇，则链表中有循环。如快指针移动到链表尾部，则链表无循环。 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; if ( head == null){ return false; } else if ( fast.next == null){ return false; } while( fast != null &amp;&amp; fast.next != null ){ slow = slow.next; fast = fast.next.next; if (slow == fast){ return true; } } return false; }}","link":"/2022/04/09/141-Linked-List-Cycle/"},{"title":"1423. Maximum Points You Can Obtain from Cards","text":"Question There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain. Solution 1这种取两端的问题可以转化为取中间连续k个元素之和最小。 计算所有数字的和sum。然后用维护一个宽度为k的窗口内的加和temp，并记录其最小值min。 返回sum - min，结果即是取两侧时可以取的最大值。 Code1234567891011121314151617181920class Solution { public int maxScore(int[] cardPoints, int k) { int n = cardPoints.length, sum = 0; for(int point : cardPoints) sum += point; //求所有数值的和 if(k == n) return sum; int left = 0, right = n-k, temp = 0, min = 0; for(int i = 0; i &lt; n-k; i++){ temp += cardPoints[i]; min = temp; } while(right &lt; n){ //维护窗口内的temp，并更新min temp += cardPoints[right] - cardPoints[left];; min = Math.min(min, temp); right++; left++; } return sum - min; }} Solution 2分别计算从两侧开始的加和并记录在两个数组left[]和right[]上。 然后分别取两个指针，左侧指针l从0开始遍历到k，右侧指针对应的位置为l+n-k。计算并更新最大值max。 Code1234567891011121314151617class Solution { public int maxScore(int[] cardPoints, int k) { int n = cardPoints.length, max = 0; int[] left = new int[n+1], right = new int[n+1]; for(int i = 0; i &lt; n; i++){ left[i+1] = left[i] + cardPoints[i]; right[n-i-1] = right[n-i] + cardPoints[n-i-1]; } for(int l = 0; l &lt;= k; l++){ max = Math.max(max, left[l] + right[n-k+l]); } return max; }}","link":"/2022/06/26/1423-Maximum-Points-You-Can-Obtain-from-Cards/"},{"title":"144. Binary Tree Preorder Traversal","text":"问题Given the root of a binary tree, return the preorder traversal of its nodes’ values. 先序遍历。先将当前节点加入数组。然后递归左子节点。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ans = new ArrayList(); traversal(root); return ans; } private void traversal(TreeNode root){ if (root == null){ return; } ans.add(root.val); traversal(root.left); traversal(root.right); return; }}","link":"/2022/04/12/144-Binary-Tree-Preorder-Traversal/"},{"title":"1448. Count Good Nodes in Binary Tree","text":"Question Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree. SolutionDFS搜索，每次传入当前分支的最大值。如果当前值大于等于最大值，则count+1。 Code12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int count; public int goodNodes(TreeNode root) { count = 0; dfs(root, Integer.MIN_VALUE); return count; } private void dfs(TreeNode root, int max){ if(root == null) return; if(root.val &gt;= max){ count++; max = root.val; } dfs(root.left, max); dfs(root.right, max); }}","link":"/2022/09/01/1448-Count-Good-Nodes-in-Binary-Tree/"},{"title":"145. Binary Tree Postorder Traversal","text":"问题Given the root of a binary tree, return the postorder traversal of its nodes’ values. 后序遍历。先递归左子节点。然后递归右子节点。最后将当前节点加入数组。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; postorderTraversal(TreeNode root) { ans = new ArrayList(); traversal(root); return ans; } private void traversal(TreeNode root){ if (root == null){ return; } traversal(root.left); traversal(root.right); ans.add(root.val); return; }}","link":"/2022/04/12/145-Binary-Tree-Postorder-Traversal/"},{"title":"142. Linked List Cycle II","text":"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. 快慢指针。快指针的移动速度是慢指针的两倍。设环外长度为a，b是快指针和慢指针相遇的位置，c是环中剩余位置。可以由此得到公式a + (n + 1)b + nc = 2(a + b)，也就是a = c + (n - 1)(b + c)由于（b + c）是环的长度。因此，当两个指针相遇时，在头部设置一个新节点。慢指针和新指针将在循环入口处相遇，此时返回节点。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode detectCycle(ListNode head) { if( head == null || head.next == null) return null; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; if(slow.equals(fast)) break; } if(fast == null || fast.next == null){ return null; } ListNode root = head; while(!root.equals(slow)){ slow = slow.next; root = root.next; } return root; }} 哈希表，递归并将节点加入哈希集合，如果重复则返回节点，反之返回null。 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { HashSet&lt;ListNode&gt; set; public ListNode detectCycle(ListNode head) { set = new HashSet&lt;&gt;(); return findCycle(head, 0); } private ListNode findCycle(ListNode root, int count){ if(root == null){ return null; } if(set.contains(root)){ return root; } set.add(root); count++; return findCycle(root.next, count); }}","link":"/2022/04/25/142-Linked-List-Cycle-II/"},{"title":"1457. Pseudo-Palindromic Paths in a Binary Tree","text":"Question Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome. Return the number of pseudo-palindromic paths going from the root node to leaf nodes. Solution用数组bin[]记录一个树枝上的节点。 回溯，遇到根节点则判断数组bin[]中是否只有0个或1个奇数的数字。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int res; int[] bin; public int pseudoPalindromicPaths (TreeNode root) { res = 0; bin = new int[10]; backtrack(root); return res; } private void backtrack(TreeNode root){ if(root.left == null &amp;&amp; root.right == null){ bin[root.val]++; boolean flag = false; for(int i = 0; i &lt; bin.length; i++){ if(flag &amp;&amp; (bin[i] &amp; 1) == 1){ bin[root.val]--; return; } else if((bin[i] &amp; 1) == 1) flag = true; } res++; bin[root.val]--; return; } bin[root.val]++; if(root.left != null) backtrack(root.left); if(root.right != null) backtrack(root.right); bin[root.val]--; }}","link":"/2022/09/14/1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/"},{"title":"1354. Construct Target Array With Multiple Sums","text":"Question You are given an array target of n integers. From a starting array arr consisting of n 1’s, you may perform the following procedure : let x be the sum of all elements currently in your array. choose index i, such that 0 &lt;= i &lt; n and set the value of arr at index i to x. You may repeat this procedure as many times as needed. Return true if it is possible to construct the target array from arr, otherwise, return false. Solution 1递归，每次寻找到数组中最大的数字的下标maxIndex，并对整个数组加和。当数组中出现小于1的数时，不成立，返回false。当数组加和等于数组长度时，返回true。 记录剩余的数字others，如果没有剩余数字，则返回false。将target[maxIndex]减去others，因此每次翻倍，快速逼近。当小于0时，则还原到上一个target[maxIndex]。 递归更改后的数组。 Code123456789101112131415161718192021222324class Solution { public boolean isPossible(int[] target) { int maxIndex = 0, sum = 0; for(int i = 0; i &lt; target.length; i++){ if(target[i] &lt;= 0) return false; //数组中出现小于1的数，则不成立，返回false if(target[maxIndex] &lt; target[i]) maxIndex = i; sum += target[i]; } if(sum == target.length) return true; //加和等于长度，则数组内全部为1，返回true int others = sum - target[maxIndex]; if(others == 0) return false; //没有其他值时返回false target[maxIndex] -= others; int n = 1; while(target[maxIndex] &gt; others){ target[maxIndex] -= n * others; if(target[maxIndex] &lt;= 0){ target[maxIndex] += n * others; break; } n*=2; //因子每次翻倍，快速逼近 } return isPossible(target); }} Solution 2优先级队列， 大根堆。每次挤出队列里最大的数字max。 如果max的值为1，则返回true。 计算加和和新的值，并更新sum。如果最大的数字max小于0，或者剩余的sum小于0，则返回false。 当max仍然大于剩下的数字时，继续做减法。采用因数翻倍，快速接近目标值。如果max小于0，则恢复到上一个值，并添加到优先级队列中。 Code123456789101112131415161718192021222324252627282930class Solution { public boolean isPossible(int[] target) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); int sum = 0; for(int num : target){ pq.offer(num); sum+=num; } while(true){ int max = pq.poll(); if(max == 1) return true; sum -= max; max = max - sum; if(sum &lt;= 0 || max &lt;= 0) return false; int n = 1; while(max &gt; sum){ max -= n * sum; if(max &lt;= 0){ max += n * sum; break; } n*=2; } sum += max; pq.offer(max); } }}","link":"/2022/06/24/1354-Construct-Target-Array-With-Multiple-Sums/"},{"title":"1461. Check If a String Contains All Binary Codes","text":"Question Given a binary string s and an integer k, return true if every binary code of length k is a substring of s. Otherwise, return false. Solution位运算+哈希表，用整数num记录二进制编码并加入哈希表中。首先将字符串内的前k位二进制码转换为整数。并将其数值添加到哈希表内。 滑动窗口遍历，维持num为k长度内二进制码所对应的整数，并在遍历时将num加入哈希集合。如果哈希集合的size达到k长度对应的可组合数，则返回true，否则返回false。 位运算与掩码为了维护整数num，首先将其二进制编码向左移动一位。然后与mask进行按位与运算，屏蔽掉多余的位数。 mask的值为k长度对应的可组合数-1。 Code123456789101112131415161718192021class Solution { public boolean hasAllCodes(String s, int k) { if(s.length() &lt; k) return false; //字符串长度不足则返回false char[] bin = s.toCharArray(); int n = s.length(), m = (int) Math.pow(2, k); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); //哈希表记录访问过的数字 int num = Integer.parseInt(s.substring(0,k), 2); //字符串以二进制转换为整数 int mask = m-1; //掩码等于寻找长度-1 set.add(num); for(int i = k; i &lt; s.length(); i++){ //位运算，维护窗口内整数的值 num &lt;&lt;= 1; //位运算左移一位 num &amp;= mask; //出界的位置被掩码遮盖 if(bin[i] == '1') num++; set.add(num); if(set.size() == m) return true; //如果哈希表长度等于2^k，则已经遍历了所有组合，返回true } return false; }}","link":"/2022/05/31/1461-Check-If-a-String-Contains-All-Binary-Codes/"},{"title":"1465. Max Area After Horizontal and Vertical Cuts","text":"Question You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where: horizontalCuts[i] is the distance from the top of the rectangular cake to the i&lt;sup&gt;th&lt;/sup&gt; horizontal cut and similarly, and verticalCuts[j] is the distance from the left of the rectangular cake to the j&lt;sup&gt;th&lt;/sup&gt; vertical cut. Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7. Solution先排序，记录两次切割之间的距离的最大值。最后同样需要比较蛋糕的总尺寸和最后一次切割的距离。 返回宽度和长度的最大值的乘积即可。 注意：两个int整数相乘会溢出，max需要记录为long类型。 Code123456789101112131415161718192021222324class Solution { public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) { int MOD = (int) Math.pow(10,9)+7; Arrays.sort(horizontalCuts); Arrays.sort(verticalCuts); long maxH = 0, maxV = 0; int lastH = 0, lastV = 0; for(int i = 0; i &lt; horizontalCuts.length; i++){ maxH = Math.max(maxH, horizontalCuts[i] - lastH); lastH = horizontalCuts[i]; } maxH = Math.max(maxH, h - lastH); for(int i = 0; i &lt; verticalCuts.length; i++){ maxV = Math.max(maxV, verticalCuts[i] - lastV); lastV = verticalCuts[i]; } maxV = Math.max(maxV, w - lastV); return (int) (maxV * maxH % MOD) ; }}","link":"/2022/07/02/1465-Max-Area-After-Horizontal-and-Vertical-Cuts/"},{"title":"1480. Running Sum of 1d Array","text":"Question Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums. Solution类似动态规划，遍历数组，并将当前位置的元素和上一个位置的元素进行加和。 Code12345678class Solution { public int[] runningSum(int[] nums) { for(int i = 1; i &lt; nums.length; i++){ nums[i] += nums[i-1]; } return nums; }}","link":"/2022/06/01/1480-Running-Sum-of-1d-Array/"},{"title":"15. 3Sum","text":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. 三数之和，重点是如何遍历后去除重复的数组。首先对数组进行排序。遍历数组，三个数中最小的数字为nums[i]。此时需要去除重复的nums[i]。如重复则继续下一次循环。此时设置双指针left和right，分别在nums[i]右侧的子数组的首尾。 当nums[i] + nums[left] + nums[right] &gt; 0时，后两个数的和需要减小，right指针向左移动。 当nums[i] + nums[left] + nums[right] &lt; 0时，后两个数的和需要增大，left指针向右移动。 当nums[i] + nums[left] + nums[right] = 0时，找到一个组合。此时需要去除重复的nums[left]和nums[right]。如重复则更新left或right的指针。 将组合添加到返回列表。 最后返回列表。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i++){ int left = i+1; int right = nums.length-1; if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]){ continue; } while(left &lt; right){ if(nums[i]+nums[left]+nums[right]==0){ while(left+1 &lt; nums.length &amp;&amp; nums[left] == nums[left+1]){ left++; } while(right-1 &gt; i &amp;&amp; nums[right] == nums[right-1]){ right--; } List&lt;Integer&gt; list = new ArrayList(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); left++; right--; } else if(nums[i]+nums[left]+nums[right]&gt;0){ right--; } else{ left++; } } } return ans; }}","link":"/2022/04/17/15-3Sum/"},{"title":"153. Find Minimum in Rotated Sorted Array","text":"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: [4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. 二分搜索，寻找断裂点。当left小于right时循环。每次计算出mid，分为两种情况： 如果nums[mid]小于nums[nums.length-1]，则右半侧为顺序的。 反之则左半侧为顺序，右半侧为无序的。以此来更新搜索范围。由于mid计算公式向下取整。当更新left时更新为mid+1，向前一格。当更新right时更新为mid。最后返回nums[left]。 12345678910111213141516171819class Solution { public int findMin(int[] nums) { return findBreakPoint(nums,0,nums.length-1); } private int findBreakPoint(int[] nums, int left, int right){ while(left &lt; right){ int mid = (right - left)/2 + left; if(nums[mid] &lt; nums[nums.length-1]){ right = mid; } else if(nums[mid] &gt;= nums[0]){ left = mid+1; } } return nums[left]; }}","link":"/2022/04/17/153-Find-Minimum-in-Rotated-Sorted-Array/"},{"title":"149. Max Points on a Line","text":"Question Given an array of points where points[i] = [x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line. Solution首先选取一个点，然后创建哈希表。记录这个点与其他点的斜率关系与出现次数。记录一个出现次数最多的max值，如果当前次数大于max则更新max。 注意计算斜率时对y == 0和 x == 0时要返回无穷大和0，否则会有精度问题。最后返回max + 1。 可以优化的地方是，当max大于总点数的一半，或者max大于剩余的点时，因为已经找到了最大的max值，可以直接返回答案。 Code12345678910111213141516171819202122232425262728293031class Solution { public int maxPoints(int[][] points) { int n = points.length; if(n == 1) return 1; else if(n == 2) return 2; int max = 0; for(int i = 0; i &lt; points.length; i++){ if(max &gt; points.length / 2) break; if(max &gt; points.length - i) break; HashMap&lt;Double, Integer&gt; map = new HashMap&lt;&gt;(); for(int j = i+1; j &lt; points.length; j++){ double k = getSlope(points[i], points[j]); int count = map.getOrDefault(k, 0) + 1; max = Math.max(max, count); map.put(k, count); } } return max + 1 ; } private double getSlope(int[] p1, int[] p2){ double x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1]; if(y1-y2 == 0) return Double.MAX_VALUE; if(x1-x2 == 0) return 0; double k = (x1 - x2) / (y1 - y2); return k; }} 叉乘计算可以判断两个向量是否重合。由于叉乘乘积（$|a||b|sinθ$）的模等于两个向量组成的平行四边形的面积，因此当两者乘积为0时，则两个向量重合。 点乘乘积得到的是向量在另一个向量上的投影的乘积，$|a||b|cosθ$","link":"/2022/05/06/149-Max-Points-on-a-Line/"},{"title":"155. Min Stack","text":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. 分别将数据保存在一个Priority Queue和一个栈中。pop方法pop掉stack的内容，然后将其从优先队列中移除。top方法返回stack的栈顶。getMin方法返回优先队列的顶。 123456789101112131415161718192021222324252627282930313233343536class MinStack { Queue&lt;Integer&gt; pq; Stack&lt;Integer&gt; stack; public MinStack() { pq = new PriorityQueue&lt;&gt;(); stack = new Stack&lt;&gt;(); } public void push(int val) { pq.add(val); stack.add(val); } public void pop() { int i = stack.pop(); pq.remove(i); } public int top() { return stack.peek(); } public int getMin() { return pq.peek(); }}/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */","link":"/2022/04/30/155-Min-Stack/"},{"title":"1557. Minimum Number of Vertices to Reach All Nodes","text":"Question Given a directed acyclic graph, with n vertices numbered from 0 to n-1, and an array edges where edges[i] = [from i, to] represents a directed edge from node from i to node to i . Find the smallest set of vertices from which all nodes in the graph are reachable. It’s guaranteed that a unique solution exists. Notice that you can return the vertices in any order. Answer由于是有向无环图（Directed acyclic graph），因此直接计算图内的入度为0的节点即可。每条路径都需要从入度为0的点开始。 Code12345678910111213class Solution { public List&lt;Integer&gt; findSmallestSetOfVertices(int n, List&lt;List&lt;Integer&gt;&gt; edges) { List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); int[] inDegrees = new int[n]; for(List&lt;Integer&gt; edge : edges){ inDegrees[edge.get(1)]++; } for(int i = 0; i &lt; n; i++){ if(inDegrees[i] == 0) ret.add(i); } return ret; }}","link":"/2022/05/04/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/"},{"title":"1578. Minimum Time to Make Rope Colorful","text":"ProblemAlice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the i&lt;sup&gt;th&lt;/sup&gt; balloon. Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the i&lt;sup&gt;th&lt;/sup&gt; balloon from the rope. Return the minimum time Bob needs to make the rope colorful. Solution滑动窗口，遍历字符串。common用来记录连续颜色相同的个数，初始化为1。如果当前字符与下一个字符相同，则窗口向右侧扩展，common++。遍历时记录替换气球需要的最大时间maxTime和替换掉所有同色气球的总时间deleteTime。 如果common大于1，则总时间加上需要删除的时间（刨除最大时间maxTime）。更新i为i + common。 Code1234567891011121314151617181920class Solution { public int minCost(String colors, int[] neededTime) { int i = 0, totalTime = 0; char[] c = colors.toCharArray(); while(i &lt; neededTime.length){ int common = 1, maxTime = neededTime[i], deleteTime = neededTime[i]; while(i + common &lt; neededTime.length &amp;&amp; c[i] == c[i + common]){ maxTime = Math.max(maxTime, neededTime[i + common]); deleteTime += neededTime[i + common]; common++; } if(common &gt; 1){ deleteTime -= maxTime; totalTime += deleteTime; } i += common; } return totalTime; }}","link":"/2022/10/03/1578-Minimum-Time-to-Make-Rope-Colorful/"},{"title":"160. Intersection of Two Linked Lists","text":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1:The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. 计算两个链表的长度。将长的链表向下移动两者长度的差，对齐两个链表的长度。同时向下移动两个链表，如果两个节点的内存地址相同，则返回节点。否则返回null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int sizeA = 0, sizeB = 0; ListNode l1 = headA, l2 = headB; while(l1 != null){ l1 = l1.next; sizeA++; } while(l2 != null){ l2 = l2.next; sizeB++; } if(sizeA &gt; sizeB){ int size = sizeA - sizeB; while(size != 0){ headA = headA.next; size--; } } else{ int size = sizeB - sizeA; while(size != 0){ headB = headB.next; size--; } } while(headA != null){ if(headA == headB) return headA; headA = headA.next; headB = headB.next; } return null; }} 遍历移动一个链表，将其加入哈希集合。然后移动另一个链表，如果哈希集合中有重复节点，则返回该节点。 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while(headA != null){ set.add(headA); headA = headA.next; } while(headB != null){ if(set.contains(headB)) return headB; headB = headB.next; } return null; }}","link":"/2022/04/26/160-Intersection-of-Two-Linked-Lists/"},{"title":"1584. Min Cost to Connect All Points","text":"You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points. 并查集，最小生成树(Minimum spanning tree)，Kruskal算法。Edge辅助类，保存并计算两点的id和其曼哈顿距离。将edges根据其距离排序。 遍历所有的edge，如果edge的两点没有合并，则合并两点，并取这条边作为结果。加和所有的结果，答案就是最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Solution { public int minCostConnectPoints(int[][] points) { List&lt;Edge&gt; edges = new ArrayList&lt;Edge&gt;(); int min = 0; for(int i = 0; i &lt; points.length; i++){ for(int j = i+1; j &lt; points.length; j++){ edges.add(new Edge(points, i, j)); } } Collections.sort(edges, (a, b) -&gt; a.length - b.length); UnionFind uf = new UnionFind(points.length); for(Edge e : edges){ if(uf.union(e.id1, e.id2)){ min += e.length; } } return min; } class UnionFind{ private int[] parents; private int[] size; public UnionFind(int n){ size = new int[n]; parents = new int[n]; for(int i = 0; i &lt; n; i++){ parents[i] = i; size[i] = 1; } } public int find(int id){ if(parents[id] == id) return id; return find(parents[id]); } public boolean union(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; if(size[p1] &lt; size[p2]){ parents[p1] = p2; size[p2] += size[p1]; } else{ parents[p2] = p1; size[p1] += size[p2]; } return true; } } class Edge{ int id1; int id2; int length; public Edge(int[][] points, int _id1, int _id2){ id1 = _id1; id2 = _id2; length = Math.abs(points[id1][0] - points[id2][0]) + Math.abs(points[id1][1] - points[id2][1]); } }}","link":"/2022/04/26/1584-Min-Cost-to-Connect-All-Points/"},{"title":"162. Find Peak Element","text":"A peak element is an element that is strictly greater than its neighbors. Given an integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. You must write an algorithm that runs in O(log n) time. 二分搜索，由于只需要搜索任意一个山峰，因此只要向上走，一定可以走到一个峰。当中值的下一个值是增长时（向上爬山），则更新左侧指针的位置为中值+1。继续搜索下一个中值。否则更新右侧指针的位置为当前中值，等于向左侧进行搜索。最后返回左侧指针停留的位置。时间复杂度为O(logn)。 12345678910111213141516class Solution { public int findPeakElement(int[] num) { int left = 0; int right = num.length - 1; while (left &lt; right) { int mid1 = (right - left) / 2 + left; int mid2 = mid1 + 1; if (num[mid1] &lt; num[mid2]) left = mid1+1; else right = mid1; } return left; }} 一次遍历，找到峰值，返回其index。时间复杂度为O(n)。 123456789101112class Solution { public int findPeakElement(int[] nums) { int peak = 0; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &gt; nums[peak]){ peak = i; } } return peak; }} 分治法，每次将数组分为两组，向下递归。当数组长度为1时返回元素，比较返回来的两个数值的大小。返回其中的峰值index。此解法时间为O(nlogn)。 123456789101112131415161718192021class Solution { public int findPeakElement(int[] nums) { return findPeak(nums,0,nums.length-1); } private int findPeak(int[] nums, int left, int right){ if(left == right){ return left; } int mid = left + (right - left) / 2; int i = findPeak(nums, left, mid); int j = findPeak(nums, mid+1, right); if(nums[i] &gt; nums[j]){ return i; } else{ return j; } }}","link":"/2022/04/18/162-Find-Peak-Element/"},{"title":"1631. Path With Minimum Effort","text":"You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort. A route’s effort is the maximum absolute difference in heights between two consecutive cells of the route. Return the minimum effort required to travel from the top-left cell to the bottom-right cell. A*算法，启发式搜索。BFS搜索结合Priority Queue。采用一个数组储存当前访问点的位置，以及其effort。采用优先队列，优先搜索effort最小的方向。每次循环倾倒出队列中所有的元素。计算上一个节点和当前节点的差值作为nextEffort，并和上一个节点的effort作比较，较大的作为当前节点的effort，将effort作为权重，优先搜索一个层级内effort较小的路径。将所有操作加入队列，并排除越界的位置。当当前节点为最后一个节点时，返回其effort。 1234567891011121314151617181920212223242526272829303132333435class Solution { int min; public int minimumEffortPath(int[][] heights) { int[][] operations = {{1,0},{-1,0},{0,1},{0,-1}}; int m = heights.length, n = heights[0].length; Queue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[2] - b[2]); int[] point = {0, 0, 0}; int size = 1; int[][] visited = new int[m][n]; q.add(point); while(!q.isEmpty()){ for(int k = 0; k &lt; size; k++){ int[] curr = q.poll(); int i = curr[0], j = curr[1], currEffort = curr[2]; if(visited[i][j] == 1) continue; visited[i][j] = 1; if(i == m-1 &amp;&amp; j == n-1) return currEffort; for(int[] operation : operations){ int nextX = i + operation[0]; int nextY = j + operation[1]; if(nextX &lt; 0 || nextY &lt; 0 || nextX &gt;= m || nextY &gt;= n) continue; int nextEffort = Math.max(currEffort, Math.abs(heights[i][j] - heights[nextX][nextY])); int[] next = {nextX, nextY, nextEffort}; q.add(next); } } size = q.size(); } return -1; }}","link":"/2022/04/28/1631-Path-With-Minimum-Effort/"},{"title":"1641. Count Sorted Vowel Strings","text":"Question Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted. A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet. Solution动态规划，创建数组dp[]记录以每个字符开头能组成的字符串数量。由于当长度为1时，每个字符串都能组成一次，因此初始化所有值为1。 n增长时，每一个层级都等于该字符后的所有值相加。最后得出的结果在下一个层级的第一位。（因为第一位是所有上一个层级加和） Code1234567891011121314class Solution { public int countVowelStrings(int n) { int[] dp = new int[]{1,1,1,1,1}; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; 5; j++){ for(int k = j+1; k &lt; 5; k++){ dp[j] += dp[k]; } } } return dp[0]; }} Solution递归，使用成员变量计算有效递归次数。 Code123456789101112131415161718class Solution { int count; public int countVowelStrings(int n) { count = 0; count(n, 0); return count; } private void count(int n, int start){ if(n == 0){ count++; return; } for(int i = start; i &lt; 5; i++){ count(n-1, i); } }}","link":"/2022/05/11/1641-Count-Sorted-Vowel-Strings/"},{"title":"1647. Make Character Frequencies Unique","text":"Question A string s is called good if there are no two different characters in s that have the same frequency. Given a string s, return* the minimum number of characters you need to delete to make s good.* The frequency of a character in a string is the number of times it appears in the string. For example, in the string &quot;aab&quot;, the frequency of 'a' is 2, while the frequency of 'b' is 1. Solution数组统计+哈希表用数组统计记录每个字符出现的数量。count记录需要减少的字符数量。 遍历统计数组，如果哈希表中已经记录，则将数组统计减少，直到归零。每减少一次则为count加一。如果哈希表中未记录，则将当前数字添加到哈希表中。 Code12345678910111213141516171819class Solution { public int minDeletions(String s) { int count = 0; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); int[] bin = new int[26]; for(char c : s.toCharArray()){ bin[c - 'a']++; } for(int i = 0; i &lt; 26; i++){ while(bin[i] !=0 &amp;&amp; set.contains(bin[i])){ bin[i]--; count++; } set.add(bin[i]); } return count; }}","link":"/2022/06/28/1647-Make-Character-Frequencies-Unique/"},{"title":"1642. Furthest Building You Can Reach","text":"Question You are given an integer array heights representing the heights of buildings, some bricks, and some ladders. You start your journey from building 0 and move to the next building by possibly using bricks or ladders. While moving from building i to building i+1 (0-indexed), If the current building’s height is greater than or equal to the next building’s height, you do not need a ladder or bricks. If the current building’s height is less than the next building’s height, you can either use one ladder or (h[i+1] - h[i]) bricks. Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally. Solution贪心算法+优先级队列。 从第二栋楼开始遍历当前位置，下一栋楼与当前位置的高度差为h。如果h小于0，则无成本前进。否则如果剩余砖块，则优先使用砖块，并将使用砖块的个数加入大根堆中。如果剩余砖块不足，且有梯子剩余时，用梯子替换掉小号最多砖块的位置，增加剩余砖块的数量。如果剩余砖块和梯子都不足，则返回上一个位置。 如果遍历到最后，则返回最后一个建筑物的位置。 Code12345678910111213141516171819202122class Solution { public int furthestBuilding(int[] heights, int bricks, int ladders) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); for(int i = 1; i &lt; heights.length; i++){ int h = heights[i] - heights[i-1]; if(h &gt; 0){ pq.add(h); bricks-=h; if(bricks &lt; 0){ if(ladders &gt; 0){ ladders--; bricks += pq.poll(); } else{ return i-1; } } } } return heights.length - 1; }}","link":"/2022/06/21/1642-Furthest-Building-You-Can-Reach/"},{"title":"1658. Minimum Operations to Reduce X to Zero","text":"Question You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations. Return *the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return *-1. Solution将原有问题的从两边减去一定的值，寻找加和为x的问题转换为寻找滑动窗口中的总和为total - x的新问题。 滑动窗口初始化当前窗口内的sum，左侧指针left与右侧指针right。每次将一个新的元素nums[right]加入窗口范围。 当当前的sum大于寻找的target，则将nums[left]滑出窗口，更新left与sum的值。 如果当前窗口内的sum等于寻找的target，则更新记录最小操作次数的min。 Code1234567891011121314151617181920212223class Solution { public int minOperations(int[] nums, int x) { int total = 0, min = Integer.MAX_VALUE; for(int num : nums){ total += num; } int target = total - x; //将减去两侧元素并寻找和为x的结果的问题转换为用滑动窗口寻找total - x的结果。 int sum = 0, left = 0, right = 0; while(right &lt; nums.length){ sum += nums[right]; //调整右侧范围，加入新元素到窗口 right++; while(left &lt; right &amp;&amp; sum &gt; target){ //如果窗口内的和大于目标，则调整左侧范围 sum -= nums[left]; left++; } if(sum == target){ //如果窗口内的和等于目标，则更新最小操作次数 min = Math.min(min, nums.length - (right - left)); } } return min == Integer.MAX_VALUE ? -1 : min; }}","link":"/2022/06/11/1658-Minimum-Operations-to-Reduce-X-to-Zero/"},{"title":"167. Two Sum II - Input Array Is Sorted","text":"问题描述Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 由于是有序数列，因此可以采用双指针。左右两侧和不等于目标时，根据大小结果移动左右指针。 123456789101112131415161718192021222324class Solution { public int[] twoSum(int[] numbers, int target) { int i = 0; int j = numbers.length - 1; int[] ans = new int[2]; while( i &lt; j ){ int diff = target - numbers[j]; if ( diff == numbers[i]){ ans[0] = i+1; ans[1] = j+1; return ans; } else if ( diff &lt; numbers[i] ) { j--; } else{ i++; } } return ans; }}","link":"/2022/04/05/167-Two-Sum-II-Input-Array-Is-Sorted/"},{"title":"1679. Max Number of K-Sum Pairs","text":"Question You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array. Solution两种思路，第一种，哈希表统计总数，然后逐个排除。每次从数组中取一个数，先查询寻找的target是否在哈希表内。如果表内存在target，则将target的计数减一，对数加一。 如果target不在表内，则将当前的数字加入表内。最后返回结果。时间复杂度为O(n)。 Code1234567891011121314151617class Solution { public int maxOperations(int[] nums, int k) { HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0; for(int num : nums){ int target = k - num; if(map.containsKey(target) &amp;&amp; map.get(target) &gt; 0){ map.put(target, map.get(target)-1); count++; } else{ map.put(num, map.getOrDefault(num, 0)+1); } } return count; }} Solution 2第二种思路，先排序。然后双指针放在首尾。当两者的和等于目标值时增加计数器，并移动两个指针。当两者的和大于目标值时，右侧指针左移。当两者的和小于目标值时，左侧指针右移。最后返回结果。由于有排序存在，因此时间复杂度为O(nlogn) + O(n)。 Code123456789101112131415161718192021class Solution { public int maxOperations(int[] nums, int k) { Arrays.sort(nums); int left = 0, right = nums.length-1, count = 0; while(left &lt; right){ if(nums[left] + nums[right] == k){ count++; left++; right--; } else if(nums[left] + nums[right] &gt; k){ right--; } else{ left++; } } return count; }}","link":"/2022/05/04/1679-Max-Number-of-K-Sum-Pairs/"},{"title":"1689. Partitioning Into Deci-Binary Numbers","text":"Question A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not. Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n. Solution遍历所有字符，返回字符串中的最大整数。 Code123456789class Solution { public int minPartitions(String n) { char max = '0'; for(char s : n.toCharArray()){ if(s &gt; max) max = s; } return max - '0'; }}","link":"/2022/06/27/1689-Partitioning-Into-Deci-Binary-Numbers/"},{"title":"169. Majority Element","text":"问题Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Boyer-Moore投票算法基本思想：众数的值为+1，非众数的值为-1。其加和作为投票值。遍历整个数组，由于众数数量大于非众数，因此最后结果一定为正数。 设置count记录票数，遍历数组。当count为0时，则将当前的数组设为众数。当之后的数字与其相等，则count+1，反之则-1。遍历完成后返回当前的众数。 根据以上规则，每次我们选择的众数，都是已遍历数组范围内出现最多次数的数值之一。 由于给定的数组的众数超过半数，因此遍历到最后的众数，一定是整个数组中出现最多次的数值。 核心就是对拼消耗。玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。 那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。 最后能剩下的必定是自己人。 12345678910111213141516171819class Solution { public int majorityElement(int[] nums) { int count = 0; int major = 0; for(int num : nums){ if(count == 0){ major = num; } if(major == num){ count++; } else{ count--; } } return major; }} 遍历数组，并将各个数值出现的次数记录在哈希表中。当出现的次数大于数组的一半，则该数值是众数。 123456789101112class Solution { public int majorityElement(int[] nums) { HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int num : nums){ map.put(num, map.getOrDefault(num,0)+1); if(map.get(num) &gt; nums.length/2){ return num; } } return -1; }}","link":"/2022/04/16/169-Majority-Element/"},{"title":"1695. Maximum Erasure Value","text":"Question You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements. Return the maximum score you can get by erasing exactly one subarray. An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],...,a[r] for some (l,r). Solution滑动窗口+数组统计。 用sum记录窗口内的和，max记录和的最大值。当新滑入的右侧指针不为0时，从左侧滑出元素并将滑出的元素改为0。然后将右侧指针指针对应的数组统计改为1并更新当前的和max。 Code123456789101112131415161718class Solution { public int maximumUniqueSubarray(int[] nums) { int[] bin = new int[10001]; int left = 0, max = 0, sum = 0; for(int right = 0; right &lt; nums.length; right++){ sum += nums[right]; while(bin[nums[right]] != 0){ bin[nums[left]] = 0; sum -= nums[left]; left++; } bin[nums[right]] = 1; max = Math.max(max, sum); } return max; }}","link":"/2022/06/12/1695-Maximum-Erasure-Value/"},{"title":"17. Letter Combinations of a Phone Number","text":"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 回溯，每个回溯层级添加数字对应的字符。 12345678910111213141516171819202122232425262728293031323334class Solution { public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if(digits.equals(&quot;&quot;)) return ret; char[][] bin = new char[8][0]; bin[0] = new char[]{'a', 'b', 'c'}; bin[1] = new char[]{'d', 'e', 'f'}; bin[2] = new char[]{'g', 'h', 'i'}; bin[3] = new char[]{'j', 'k', 'l'}; bin[4] = new char[]{'m', 'n', 'o'}; bin[5] = new char[]{'p', 'q', 'r', 's'}; bin[6] = new char[]{'t', 'u', 'v'}; bin[7] = new char[]{'w', 'x', 'y', 'z'}; backtracking(ret, new StringBuffer(), bin, digits, 0); return ret; } private void backtracking(List&lt;String&gt; ret, StringBuffer sb, char[][] bin, String digits, int i){ if(sb.length() == digits.length() ){ ret.add(sb.toString()); return; } for(char c : bin[digits.charAt(i)-'2']){ sb.append(c); backtracking(ret, sb, bin, digits, i+1); sb.delete(sb.length()-1, sb.length()); } }}","link":"/2022/04/26/17-Letter-Combinations-of-a-Phone-Number/"},{"title":"1710. Maximum Units on a Truck","text":"Question You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxes&lt;sub&gt;i&lt;/sub&gt;, numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt;]: numberOfBoxes&lt;sub&gt;i&lt;/sub&gt; is the number of boxes of type i. numberOfUnitsPerBox&lt;sub&gt;i&lt;/sub&gt; is the number of units in each box of the type i. You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed truckSize. Return the maximum total number of units that can be put on the truck. Solution根据每个箱子可以装最多单元从大到小排序。遍历数组，如果truckSize还有剩余，则将res增加容量乘以箱子数量。然后将truckSize减少箱子数量个。 最后返回res即可。 Code1234567891011121314151617181920class Solution { public int maximumUnits(int[][] boxTypes, int truckSize) { int res = 0; Arrays.sort(boxTypes, (a,b) -&gt; b[1] - a[1]); for(int i = 0; i &lt; boxTypes.length; i++){ int numberOfBoxes = boxTypes[i][0]; int numberOfUnitesPerBox = boxTypes[i][1]; if(truckSize &lt;= numberOfBoxes){ res += numberOfUnitesPerBox * truckSize; break; } else{ truckSize -= numberOfBoxes; res += numberOfBoxes * numberOfUnitesPerBox; } } return res; }}","link":"/2022/07/01/1710-Maximum-Units-on-a-Truck/"},{"title":"1770. Max Score from Multiplication Operations","text":"QuestionYou are given two integer arrays nums and multipliers** **of size n and m respectively, where n &gt;= m. The arrays are 1-indexed. You begin with a score of 0. You want to perform exactly m operations. On the i&lt;sup&gt;th&lt;/sup&gt; operation (1-indexed), you will: Choose one integer x from **either the start or the end **of the array nums. Add multipliers[i] * x to your score. Remove x from the array nums. Return *the maximum score after performing *m operations. Solution动态规划，dp[][]数组记录左边取的个数和右边取的个数。 从取1开始到取multipliers的长度位置开始遍历。然后从left取0个开始，直到left取i个为止遍历。计算对应的right指针位置。 注意访问数组时需要访问left和right的上一个位置。 如果left为0，则只能取右侧的上一个位置加上右侧的上一个数值乘以mul。如果right为0，则只能取左侧的上一个位置加上左侧的上一个数值乘以mul。否则取两者之间的最大值。 最后遍历数组中left + right和为m的位置，并返回最大值。 Code1234567891011121314151617181920212223class Solution { public int maximumScore(int[] nums, int[] multipliers) { int n = nums.length, m = multipliers.length; int[][] dp = new int[m+1][m+1]; for(int i = 1; i &lt;= m; i++){ int mul = multipliers[i-1]; for(int l = 0; l &lt;= i; l++){ int r = i - l; int iL = l - 1, iR = n - r; if(l == 0) dp[l][r] = dp[l][r-1] + mul * nums[iR]; else if(r == 0) dp[l][r] = dp[l-1][r] + mul * nums[iL]; else dp[l][r] = Math.max(dp[l-1][r] + mul * nums[iL], dp[l][r-1] + mul * nums[iR]); } } int ans = Integer.MIN_VALUE; for(int l = 1; l &lt;= m; l++){ int r = m - l; ans = Math.max(ans, dp[l][r]); } return ans; }}","link":"/2022/09/16/1770-Max-Score-from-Multiplication-Operations/"},{"title":"173. Binary Search Tree Iterator","text":"Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.int next() Moves the pointer to the right, then returns the number at the pointer.Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. 此方法不用将所有节点一次性入栈，而是在获得next时更新栈内的节点，因此更省时间。将根节点的所有左子节点入栈，此时栈顶为最小值。next方法：返回当前的栈顶节点。如果栈顶节点存在右子节点，则将其所有的左子节点入栈。hasNext方法：返回栈是否为空的非值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class BSTIterator { Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) { stack = new Stack(); updateStack(root); } public int next() { TreeNode node = stack.pop(); updateStack(node.right); return node.val; } public boolean hasNext() { return !stack.isEmpty(); } private void updateStack(TreeNode root){ while(root != null){ stack.push(root); root = root.left; } }}/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ DFS搜索，中序搜索，从右子节点至左子节点，先将所有元素入栈。next方法：挤出栈顶并返回。hasNext方法： 返回栈是否为空的非值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class BSTIterator { Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) { stack = new Stack(); initiateStack(root); } public int next() { return stack.pop().val; } public boolean hasNext() { return !stack.isEmpty(); } private void initiateStack(TreeNode root){ if(root == null){ return; } initiateStack(root.right); stack.push(root); initiateStack(root.left); }}/** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */","link":"/2022/04/20/173-Binary-Search-Tree-Iterator/"},{"title":"1823. Find the Winner of the Circular Game","text":"There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 &lt;= i &lt; n, and moving clockwise from the nth friend brings you to the 1st friend. The rules of the game are as follows: 1.Start at the 1st friend. 2.Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once. 3.The last friend you counted leaves the circle and loses the game. 4.If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat. 5.Else, the last friend in the circle wins the game.Given the number of friends, n, and an integer k, return the winner of the game. 约瑟夫环问题。根据题目要求，当去除一个成员时，下一个节点的编号为k+1。当新的循环开始时，总人数n-1，同时k+1变为新循环中的1。 因此可以采用递归，当n剩下一个人时，返回其编号1。对应上层这个成员的位置为k+1，向上递归。由于k+1可以越界，因此每次返回需要对其取模。 1234567class Solution { public int findTheWinner(int n, int k) { if(n == 1) return 1; int ans = findTheWinner(n-1, k) + k; return ans % n == 0 ? n : ans % n; }}","link":"/2022/04/30/1823-Find-the-Winner-of-the-Circular-Game/"},{"title":"187. Repeated DNA Sequences","text":"The DNA sequence is composed of a series of nucleotides abbreviated as ‘A’, ‘C’, ‘G’, and ‘T’. For example, “ACGAATTCCG” is a DNA sequence.When studying DNA, it is useful to identify repeated sequences within the DNA. Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. 哈希表 + 滑动窗口 + 位操作。将四个字符映射到四个二进制字符上。这样字符串就可以用20bit表示。这样就可以用一个整数来表示这四个字符。然后采用哈希表记录出现次数。 12345678910111213141516171819202122232425262728class Solution { static final int L = 10; public List&lt;String&gt; findRepeatedDnaSequences(String s) { List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); if(s.length() &lt; L) return ret; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0; int right = 10; int[] bin = new int[26]; bin['A'-'A'] = 0; bin['T'-'A'] = 1; bin['C'-'A'] = 2; bin['G'-'A'] = 3; int x = 0; for(int i = 0; i &lt; L-1; i++){ x = (x &lt;&lt; 2) | bin[s.charAt(i)-'A']; } for(int i = 0; i &lt;= s.length() - L; i++){ x = ((x &lt;&lt; 2) | bin[s.charAt(i + L -1)-'A']) &amp; ((1 &lt;&lt; L * 2) - 1); map.put(x, map.getOrDefault(x, 0)+1); if(map.get(x) == 2) ret.add(s.substring(i, i+L)); } return ret; }} 遍历将字字符串加入哈希表并记录出现次数，然后返回出现次数大于1的字符串。注意在循环时就可以直接添加结果到列表，这样可以减少操作。 1234567891011121314151617class Solution { public List&lt;String&gt; findRepeatedDnaSequences(String s) { List&lt;String&gt; ret = new ArrayList&lt;String&gt;(); HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int left = 0; int right = 10; while(right &lt;= s.length()){ String sub = s.substring(left, right); map.put(sub, map.getOrDefault(sub, 0)+1); if(map.get(sub) == 2) ret.add(sub); left++; right++; } return ret; }}","link":"/2022/04/24/187-Repeated-DNA-Sequences/"},{"title":"189. Rotate Array","text":"Given an array, rotate the array to the right by k steps, where k is non-negative. 环型替换，先求出数列长度和轮转次数的最大公约数m。然后依次替换数列中的每个值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Rotate Arrayclass Solution { public void rotate(int[] nums, int k) { if (k != 0){ int m = gcd(nums.length,k); for (int n = 0; n &lt; m; n++ ) { int i = n + k; i %= nums.length; int temp = nums[n]; while( true ){ int tempI = nums[i]; nums[i] = temp; temp = tempI; i += k; i %= nums.length; if (i == n){ nums[n] = temp; break; } } } } } private int gcd(int a, int b){ int max = a; int min = b; if (max == min){ return min; } if ( a &lt; b ){ max = b; min = a; } return gcd(max - min, min); }}","link":"/2022/04/03/189-Rotate-Array/"},{"title":"19. Remove Nth Node From End of List","text":"问题Given the head of a linked list, remove the nth node from the end of the list and return its head. 双指针，同时记录前n个节点和当前节点。当前指针到链表尾部时，删除前面的指针，注意处理edge cases。 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode preNode = null; ListNode removedNode = head; ListNode fastNode = head; for ( int i = 0; i &lt; n; i++ ){ fastNode = fastNode.next; } while ( fastNode != null ){ fastNode = fastNode.next; preNode = removedNode; removedNode = removedNode.next; } if ( removedNode == head ){ head = head.next; } else if ( removedNode.next == null){ preNode.next = null; } else{ preNode.next = removedNode.next; } return head; }}","link":"/2022/04/07/19-Remove-Nth-Node-From-End-of-List/"},{"title":"190. Reverse Bits","text":"问题Reverse bits of a given 32 bits unsigned integer. Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. 创建返回值ans。每次向左移动一位ans，然后取n的尾数进行二进制或运算（相当于在尾部进行不进位的加和）。然后将n向左移动一位。 二进制下的或运算只保留两数间较大的位。(0011 | 0110 = 0111) 二进制下的与运算只保留两数间皆为1的位。(0011 &amp; 0110 = 0010) 掩码（Mask）是在二进制下进行与运算。以1作为掩码时，前面的31为皆为0，因此进行与运算后只保留最后一位。 因此(n &amp; 1)相当于n的二进制与000…001运算，只保留n的尾数。然后(ans &lt;&lt; 1)向左移动一位，用 | 操作将n的尾数加入ans。 1234567891011public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { int ans = 0; for(int i = 0; i &lt; 32; i++){ ans = (ans &lt;&lt; 1) | (n &amp; 1); n &gt;&gt;= 1; } return ans; }}","link":"/2022/04/16/190-Reverse-Bits/"},{"title":"191. Number of 1 Bits","text":"问题Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. 位运算，[n-1]的二进制数字为[n]的二进制数字退一位。二者的与运算结果相当于二进制下[n]减少最右侧的1。例如0100100的0100011两者的与运算结果为0100000。相当于减少了一位1。计算循环次数就可以得出1的总数。 1234567891011public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int count = 0; while(n != 0){ n = (n &amp; (n-1)); count++; } return count; }}","link":"/2022/04/14/191-Number-of-1-Bits/"},{"title":"198. House Robber","text":"问题You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. 动态规划。dp数组记录经过i个房子后可以获得的最大值。dp[i+1]的值等于dp[i-1]加上现有房子的钱（抢这个房子）与dp[i]的值（不抢这个房子）中的较大值。 12345678910111213141516class Solution { public int rob(int[] nums) { int[] money = new int[nums.length+1]; money[0] = 0; money[1] = nums[0]; for (int i = 1; i &lt; nums.length; i++){ money[i+1] = Math.max(money[i-1]+nums[i],money[i]); } return money[nums.length]; }}","link":"/2022/04/14/198-House-Robber/"},{"title":"199. Binary Tree Right Side View","text":"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. BFS搜索。层级遍历各个节点，当节点为该层级最后一个节点时，将其值加入返回列表。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if(root == null) return ret; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int size = 1; while(!q.isEmpty()){ for(int i = 0; i &lt; size; i++){ TreeNode curr = q.poll(); if(i == size - 1) ret.add(curr.val); if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); } size = q.size(); } return ret; }}","link":"/2022/05/02/199-Binary-Tree-Right-Side-View/"},{"title":"1996. The Number of Weak Characters in the Game","text":"Question You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attack&lt;sub&gt;i&lt;/sub&gt;, defense&lt;sub&gt;i&lt;/sub&gt;] represents the properties of the i&lt;sup&gt;th&lt;/sup&gt; character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character’s attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attack&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;&gt; attack&lt;sub&gt;i&lt;/sub&gt; and defense&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;&gt; defense&lt;sub&gt;i&lt;/sub&gt;. Return the number of weak characters. Solution本题与354. Russian Doll Envelopes相近。 首先对数组进行排序，根据角色的attack数值降序排序，如果两者的attack数值相等，则根据两者的defence升序排序。 记录一个遍历过的最大defence数值maxDefence，遍历数组，如果当前maxDef大于角色的防御值，则此时当前遍历角色的attack与defence均严格小于上一个计算的角色，因此count加一。否则更新maxDef。 *由于attack是降序的，因此可以确定遍历时下一组数组的attack一定更弱。（由于相同attack的角色是根据defence升序排列，因此记录maxDef时会逐个更新maxDef的值。） Code123456789101112131415161718class Solution { public int numberOfWeakCharacters(int[][] properties) { int count = 0, maxDef = Integer.MIN_VALUE; Arrays.sort(properties, new Comparator&lt;int[]&gt;(){ public int compare(int[] a, int[] b){ if(a[0] == b[0]) return a[1] - b[1]; return b[0] - a[0]; } }); for(int[] character : properties){ if(maxDef &gt; character[1]) count++; else maxDef = character[1]; } return count; }}","link":"/2022/09/11/1996-The-Number-of-Weak-Characters-in-the-Game/"},{"title":"20. Valid Parentheses","text":"问题Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 用栈储存遍历中的字符。如果是“（”，“{”或“[”，则入栈。如果是其他字符，且不与栈顶的字符成对，则返回false。其他情况需要pop掉栈顶。 toCharArray(): 将字符串转换为字符数组，便于遍历。 123456789101112131415161718192021class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack(); for (char c : s.toCharArray()){ if ( c == '(' || c == '{' || c == '[' ){ stack.push(c); } else if ( stack.size() == 0 || c == ')' &amp;&amp; stack.peek() != '(' || c == '}' &amp;&amp; stack.peek() != '{' || c == ']' &amp;&amp; stack.peek() != '[') { return false; } else{ stack.pop(); } } return stack.isEmpty(); }}","link":"/2022/04/10/20-Valid-Parentheses/"},{"title":"2. Add Two Numbers","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 递归，每次递归时建立root的next节点，然后将root移动到root.next。计算两个节点的和并填入root节点。每次计算时需要计算是否进位。递归两个节点的next节点，并将carry传入。当一个节点为null时，只递归和计算另一个节点。当两个节点为null时，如果有carry需要将其放入新节点，如果没有则返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode root = new ListNode(); addTwo(l1,l2,root,0); return root.next; } private void addTwo(ListNode l1, ListNode l2, ListNode root, int carry){ if(l1 == null &amp;&amp; l2 == null &amp;&amp; carry == 0){ return; } else if(l1 == null &amp;&amp; l2 == null){ root.next = new ListNode(); root = root.next; root.val = carry; return; } else if(l1 == null){ root.next = new ListNode(); root = root.next; root.val = (l2.val + carry) % 10; carry = (l2.val + carry) / 10; addTwo(null, l2.next, root, carry); return; } else if(l2 == null){ root.next = new ListNode(); root = root.next; root.val = (l1.val + carry) % 10; carry = (l1.val + carry) / 10; addTwo(null, l1.next, root, carry); return; } root.next = new ListNode(); root = root.next; root.val = (l1.val + l2.val + carry) % 10; carry = (l1.val + l2.val + carry) / 10; addTwo(l1.next, l2.next, root, carry); }}","link":"/2022/04/25/2-Add-Two-Numbers/"},{"title":"201. Bitwise AND of Numbers Range","text":"Question Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive. Solution进行按位和运算时，只要两个位不都是1就会为0。从left到right之间，如果left和right的前x位是一样的，那么两者之间必定有一个数字在x位上为1，后面的位上为0。因此和这个数字进行按位和运算必定为0。因此，我们只要保留前面两者相同的位的信息即可，后面均为0。 当left与right不相等时，将两者同时右移，并计算移动的总数。当两者相等时，向左移动计算的总数的位数。就保留了其相同的前缀。 Code123456789101112class Solution { public int rangeBitwiseAnd(int left, int right) { int count = 0; while(left != right){ left &gt;&gt;= 1; right &gt;&gt;= 1; count++; } return left &lt;&lt; count; }} Solution 2利用一串只有一个1的32位数字作为掩码，获得两个数字单独的位信息。32位整数的第一位是符号位。因此我们的掩码从第1位开始直到第31位。当对left和right进行该位的掩码操作后，如果两者相同，则掩码右移一位。并将答案和当前位进行位或运算。（相当于保存当前位的位信息。） 如果不同，或者掩码变为0，则返回结果。 Code123456789101112class Solution { public int rangeBitwiseAnd(int left, int right) { int mask = 1 &lt;&lt; 30; int ans = 0; while(mask &gt; 0 &amp;&amp; (mask &amp; left) == (mask &amp; right)){ ans |= (mask &amp; left); mask &gt;&gt;= 1; } return ans; }}","link":"/2022/05/05/201-Bitwise-AND-of-Numbers-Range/"},{"title":"200. Number of Islands","text":"Question Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Solution遍历所有点，如果等于1则对其进行DFS搜索。在搜索的同时将1设为0。如果等于0则递归返回。 Code12345678910111213141516171819202122232425262728293031323334353637class Solution { char[][] area; public int numIslands(char[][] grid) { area = grid; int count = 0; for(int i = 0; i &lt; area.length; i++){ for(int j = 0; j &lt; area[0].length; j++){ if(area[i][j] == '1'){ dfs(i, j); count++; } } } return count; } private void dfs(int i, int j){ if(area[i][j] == '0'){ return; } area[i][j] = '0'; if( i+1 &lt; area.length ){ dfs(i+1, j); } if( i-1 &gt;= 0 ){ dfs(i-1, j); } if( j+1 &lt; area[0].length ){ dfs(i, j+1); } if( j-1 &gt;= 0 ){ dfs(i, j-1); } }} Solution 2同样是dfs搜索遍历每个位置，然而这个方法使用visited[][]数组来记录点是否被访问过。 Code1234567891011121314151617181920212223242526272829303132class Solution { int[][] visited; char[][] map; int[][] operations; public int numIslands(char[][] grid) { visited = new int[grid.length][grid[0].length]; map = grid; int count = 0; operations = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; for(int i = 0; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if(visited[i][j] == 1 || map[i][j] == '0') continue; dfs(i, j); count++; } } return count; } private void dfs(int x, int y){ if(x &lt; 0 || x &gt;= map.length || y &lt; 0 || y &gt;= map[0].length ) return; if(visited[x][y] == 1 || map[x][y] == '0') return; visited[x][y] = 1; for(int[] operation : operations){ int m = x + operation[0]; int n = y + operation[1]; dfs(m, n); } }}","link":"/2022/04/20/200-Number-of-Islands/"},{"title":"202. Happy Number","text":"Question Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not. Solution首先证明，快乐数的计算不会趋近于无穷大。我们可以考虑每一个位数的最大数字（9999…999）。其下一个数值等于(81*n)。对于三位数以下，其最大的值得下一个结果不会大于243。对于四位数以上，下一个结果会快速收缩到三位数。因此计算结果不会趋近于无穷。 当我们计算快乐数的值时，形成了一个隐式链表。因此我们可以用快慢指针的方式，查询链表上是否有环。快指针比慢指针初始值快1个单位，且移动速度为慢指针的一倍。如果链表中有环，则两者终能相遇。如果fast指针先走到1，等于走到了链表的终点。 Code1234567891011121314151617181920class Solution { public boolean isHappy(int n) { int slow = n, fast = getNext(n); while(fast != 1 &amp;&amp; fast != slow){ fast = getNext(getNext(fast)); slow = getNext(slow); } return fast == 1; } private int getNext(int n){ int sum = 0; while(n != 0){ int digit = n % 10; sum += (digit * digit); n = n / 10; } return sum; }}","link":"/2022/05/06/202-Happy-Number/"},{"title":"203. Remove Linked List Elements","text":"问题Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. 设置哨兵节点，将其next指向头部。设置前节点，将其指向哨兵节点。设置尾部节点，并指向头部。移动当前节点尾部，如尾部的val等于需要删去的val，则将前节点的next指向尾部的next。尾部的next如为null，则前节点的next指向null。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode removeElements(ListNode head, int val) { if (head == null){ return head; } ListNode dummyHead = new ListNode(); dummyHead.next = head; ListNode preNode = dummyHead; ListNode tail = dummyHead.next; while( tail != null ){ if ( tail.next == null &amp;&amp; tail.val == val ){ preNode.next = null; break; } else if (tail.val == val){ preNode.next = tail.next; tail = preNode.next; } else{ preNode = preNode.next; tail = tail.next; } } return dummyHead.next; }}","link":"/2022/04/09/203-Remove-Linked-List-Elements/"},{"title":"206. Reverse Linked List","text":"问题Given the head of a singly linked list, reverse the list, and return the reversed list. 翻转列表，当链表长度不足时，直接返回原链表。将头元素设置到preNode，同时将其next设置为null，作为新链表的尾。将其余的元素设置到curNode。 当当前节点不为null时遍历： 将curNode的next保存在temp。 将curNode的next指向preNode，作为preNode的上一个节点。 将preNode指向curNode，完成交换。 将curNode指向temp，curNode变为原来的curNode的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode reverseList(ListNode head) { if( head == null ){ //if not enough, return head return head; } if ( head.next == null ){ return head; } ListNode preNode = head; //set head to preNode, it will be the last node in the end ListNode curNode = head.next; //curNode move to next preNode.next = null; //only preserve one head node ListNode temp; while( curNode != null ){ temp = curNode.next; //preserve nodes after curNode curNode.next = preNode; //cur -&gt; pre preNode = curNode; //set back reversed list to preNode curNode = temp; //put back preserved nodes, curNode move to the next } return preNode; }}","link":"/2022/04/10/206-Reverse-Linked-List/"},{"title":"208. Implement Trie (Prefix Tree)","text":"Question A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. Solution参考：实现 Trie :「二维数组」&amp;「TrieNode」方式 前缀树，字典树结构实现。 前缀树 Trie前缀树结构用“边”记录有无字符，用“点”记录单词结尾以及后续的字符串字符。root节点记录字典的根节点。 TrieNode节点用TrieNode节点实现前缀树。真值end记录是否为字符串的结尾，创建时默认为false。数组TrieNode[] children记录子节点。 insert()方法从根节点root开始，遍历字符串。如果对应的子节点位置为空，则创建新的TrieNode节点。向下移动当前节点。 将最后一个节点设置为end，使得整个字符串被字典记录。 search()方法从根节点root开始，遍历字符串。如果子节点位置为空，则这个字符串不在字典中，返回false。否则向下移动当前节点。 遍历完毕，如果当前节点的end为true，则存在该字符串，返回true。 startsWith()方法从根节点root开始，遍历前缀字符串。如果子节点位置为空，则这个前缀不在字典中，返回false。否则向下移动当前节点。 最后返回true。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Trie { class TrieNode { boolean end; TrieNode[] children = new TrieNode[26]; } TrieNode root; public Trie() { root = new TrieNode(); } public void insert(String word) { TrieNode curr = root; for(char c : word.toCharArray()){ int i = c - 'a'; if(curr.children[i] == null) curr.children[i] = new TrieNode(); curr = curr.children[i]; } curr.end = true; } public boolean search(String word) { TrieNode curr = root; for(char c : word.toCharArray()){ int i = c - 'a'; if(curr.children[i] == null) return false; curr = curr.children[i]; } return curr.end; } public boolean startsWith(String prefix) { TrieNode curr = root; for(char c : prefix.toCharArray()){ int i = c - 'a'; if(curr.children[i] == null) return false; curr = curr.children[i]; } return true; } }/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","link":"/2022/06/18/208-Implement-Trie-Prefix-Tree/"},{"title":"209. Minimum Size Subarray Sum","text":"Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, …, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead. 滑动窗口，先取最左侧数字。记录窗口的最小值。如果小于目标值，则右侧窗口向右移动，扩大窗口。更新窗口内的值。如果大于等于目标值，则左侧窗口向右移动，缩小窗口。更新窗口内的值。同时如果窗口大小小于最小值则更新窗口最小值。 1234567891011121314151617181920class Solution { public int minSubArrayLen(int target, int[] nums) { int min = Integer.MAX_VALUE; int left = 0; int right = 0; int sum = nums[0]; while(right &lt; nums.length){ if(sum &gt;= target){ min = Math.min(min, right - left + 1); sum -= nums[left]; left++; } else{ right++; if(right &lt; nums.length) sum += nums[right]; } } return min == Integer.MAX_VALUE ? 0 : min; }} 计算前缀和。前缀和[j]与前缀和的[i]的差就是i+1到j的和。因此需要找到sum[j] - sum[i] &gt;= k。暴力枚举的话需要O(n^2^)的时间复杂度。 由于前缀和是有序的，因此我们可以采用二分搜索。寻找sum[j] - k &gt;= sum[i]。Arrays.binarySearch方法可以返回查找到的目录。如果没有该值，方法会返回一个负数，其取反（x取反相当于[-(x+1)]）的值就是应该插入的目录。将ans设置为无限大，如果(index - i)小于最小值则更新到ans。 时间复杂度O(nlogn)。 123456789101112131415161718192021class Solution { public int minSubArrayLen(int target, int[] nums) { int[] sum = new int[nums.length+1]; for(int i = 1; i &lt;= nums.length; i++){ sum[i] = sum[i-1] + nums[i-1]; } int ans = Integer.MAX_VALUE; for(int i = 0; i &lt; sum.length; i++){ int search = sum[i] + target; int index = Arrays.binarySearch(sum, search); if(index &lt; 0){ index = ~index; } if(index &lt; sum.length){ ans = Math.min(ans, index - i); } } return ans == Integer.MAX_VALUE ? 0 : ans; }}","link":"/2022/04/20/209-Minimum-Size-Subarray-Sum/"},{"title":"21. Merge Two Sorted Lists","text":"You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. 先设置空的哨兵节点，然后将尾部指针指向这个节点。遍历两个链表，将尾部节点的下一个值指向两个节点中值较小的一个。然后将指针移动到下一个值。最后返回哨兵节点的下一个节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummyHead = new ListNode(); ListNode tail = dummyHead; while ( list1 != null &amp;&amp; list2 !=null ){ if (list1.val &lt; list2.val){ tail.next = list1; list1 = list1.next; tail = tail.next; } else{ tail.next = list2; list2 = list2.next; tail = tail.next; } } if ( list1 == null){ tail.next = list2; } else { tail.next = list1; } return dummyHead.next; }}","link":"/2022/04/09/21-Merge-Two-Sorted-Lists/"},{"title":"213. House Robber II","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. 动态规划，和普通的动态规划不同的是这道题是首尾相连的。因此分两种情况讨论——如果选择了头，就不选择尾。反之亦然。建立两个动态规划表，分别选择第一个和第二个数字作为第一次抢劫的目标。前一个最多抢劫到倒数第一个房子，后一个最多抢劫到最后一个房子。 12345678910111213141516171819202122class Solution { public int rob(int[] nums) { if(nums.length == 1) return nums[0]; int max = 0; int[] dp = new int[nums.length+1]; int[] dp2 = new int[nums.length+1]; dp[1] = nums[0]; for(int i = 2; i &lt; nums.length; i++){ dp[i] = Math.max(dp[i-2] + nums[i-1], dp[i-1]); } dp2[2] = nums[1]; for(int i = 3; i &lt;= nums.length; i++){ dp2[i] = Math.max(dp2[i-2] + nums[i-1], dp2[i-1]); } return Math.max(dp[dp.length-2], dp2[dp2.length-1]); }}","link":"/2022/04/26/213-House-Robber-II/"},{"title":"215. Kth Largest Element in an Array","text":"Problem Given an integer array nums and an integer k, return the k&lt;sup&gt;th&lt;/sup&gt; largest element in the array. Note that it is the k&lt;sup&gt;th&lt;/sup&gt; largest element in the sorted order, not the k&lt;sup&gt;th&lt;/sup&gt; distinct element. Solution直接排序数组，返回倒数第k个值。 Code123456class Solution { public int findKthLargest(int[] nums, int k) { Arrays.sort(nums); return nums[nums.length - k]; }} Solution 2采用优先级队列，将所有元素加入队列，采用倒序比较器。挤出前k-1个值，然后返回第k个值。 Code123456789101112class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); for(int num : nums){ pq.add(num); } for(int i = 0; i &lt; k-1; i++){ pq.poll(); } return pq.peek(); }}","link":"/2022/05/05/215-Kth-Largest-Element-in-an-Array/"},{"title":"216. Combination Sum III","text":"Question Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. Solution回溯，创建一个成员变量visited[]记录访问情况。 剪枝优化，遍历所有可选择的数字，将其加和，如果加和大于target则返回。剪枝优化，每层级遍历的范围大于传入列表中的最后一个元素。回溯，向下递归。 如果k等于0并且sum等于target则添加arr到列表ret中。 Code1234567891011121314151617181920212223242526272829class Solution { int[] visited; List&lt;List&lt;Integer&gt;&gt; ret; public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { visited = new int[9]; ret = new ArrayList&lt;&gt;(); backTracking(k, n, new ArrayList&lt;&gt;(), 0); return ret; } private void backTracking(int k, int target, List&lt;Integer&gt; arr, int sum){ if(k == 0 &amp;&amp; sum == target) ret.add(new ArrayList&lt;&gt;(arr)); int start = 1; if(arr.size() != 0) start = arr.get(arr.size()-1)+1; for(int i = start ; i &lt;= 9; i++){ if(visited[i-1] == 1) continue; sum+=i; if(sum &gt; target) return; visited[i-1] = 1; arr.add(i); backTracking(k-1, target, arr, sum); sum-=i; arr.remove(new Integer(i)); visited[i-1] = 0; } }}","link":"/2022/05/10/216-Combination-Sum-III/"},{"title":"225. Implement Stack using Queues","text":"Question Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack. boolean empty() Returns true if the stack is empty, false otherwise. Notes: You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations. Solution用两个队列实现栈。一个队列存放压入的元素。 push()将当前元素加入到第一个队列。 top() &amp; pop()当需要挤出或者查看栈顶时，第一个队列只保留一个元素，其余元素加入第二个队列。最后一个元素就是栈顶。当第一个队列为空时，交换第一个队列与第二个队列。 empty()返回两个队列是否均为空。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyStack { Queue&lt;Integer&gt; q1; Queue&lt;Integer&gt; q2; public MyStack() { q1 = new LinkedList&lt;Integer&gt;(); q2 = new LinkedList&lt;Integer&gt;(); } public void push(int x) { q1.add(x); } public int pop() { move(); return q1.poll(); } public int top() { move(); return q1.peek(); } public boolean empty() { return q1.isEmpty() &amp;&amp; q2.isEmpty(); } private void move(){ if(q1.isEmpty()){ Queue&lt;Integer&gt; temp = q1; q1 = q2; q2 = temp; } while(q1.size() != 1){ q2.add(q1.poll()); } }}/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */","link":"/2022/05/05/225-Implement-Stack-using-Queues/"},{"title":"22. Generate Parentheses","text":"Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. 回溯，记录左右括号的出现次数。每次递归都添加左侧括号。左侧括号的数量大于右侧括号时递归下一级才可以添加右侧括号。当左侧括号和右侧括号达到n时，返回字符串。 12345678910111213141516171819202122232425262728293031class Solution { int N; List&lt;String&gt; ret; StringBuffer sb; public List&lt;String&gt; generateParenthesis(int n) { ret = new ArrayList&lt;&gt;(); sb = new StringBuffer(); N = n; backtracking(0, 0); return ret; } private void backtracking(int left, int right){ if(left &gt; N || right &gt; N){ return; } if(left == N &amp;&amp; right == N){ ret.add(sb.toString()); return; } if(left &gt; right){ sb.append(')'); backtracking(left, right+1); sb.delete(sb.length()-1, sb.length()); } sb.append('('); backtracking(left+1, right); sb.delete(sb.length()-1, sb.length()); }}","link":"/2022/04/26/22-Generate-Parentheses/"},{"title":"226. Invert Binary Tree","text":"问题Given the root of a binary tree, invert the tree, and return its root. 翻转二叉树。交换当前节点的左右子节点。分别递归其左右子节点。当当前节点的两个节点均为null时返回。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode invertTree(TreeNode root) { if (root == null){ return root; } invert(root); return root; } private void invert(TreeNode root){ if ( root.left == null &amp;&amp; root.right == null){ return; } TreeNode temp = root.left; root.left = root.right; root.right = temp; if ( root.left != null ){ invert(root.left); } if ( root.right != null ){ invert(root.right); } }}","link":"/2022/04/13/226-Invert-Binary-Tree/"},{"title":"2273. Find Resultant Array After Removing Anagrams","text":"Problem You are given a 0-indexed string array words, where words[i] consists of lowercase English letters. In one operation, select any index i such that 0 &lt; i &lt; words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions. Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, &quot;dacb&quot; is an anagram of &quot;abdc&quot;. Solution由于只用查看上一个元素。记录一个prev[]数组记录上一个元素的字符情况。遍历words，用数组bin[]统计每个字母出现的次数，同时减去prev数组的统计数字。如果数组中的每个统计结果都为0，则是上一个字符串的Anagram。否则是一个新的字符串，将其加入结果。然后将上一个数组prev更新为当前的统计数组bin[]。 Code12345678910111213141516171819202122232425262728class Solution { public List&lt;String&gt; removeAnagrams(String[] words) { int[] prev = new int[26]; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for(String word : words){ int[] bin = new int[26]; char[] chars = word.toCharArray(); for(int i = 0; i &lt; chars.length; i++){ prev[chars[i]-'a']--; bin[chars[i]-'a']++; } if(!allZero(prev)){ ans.add(word); } prev = bin; } return ans; } private boolean allZero(int[] bin){ for(int num : bin){ if(num != 0) return false; } return true; }}","link":"/2022/05/15/2273-Find-Resultant-Array-After-Removing-Anagrams/"},{"title":"2275. Largest Combination With Bitwise AND","text":"Problem The bitwise AND of an array nums is the bitwise AND of all integers in nums. For example, for nums = [1, 5, 3], the bitwise AND is equal to 1 &amp; 5 &amp; 3 = 1. Also, for nums = [7], the bitwise AND is 7. You are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination. Return *the size of the largest combination of candidates with a bitwise AND greater than *0. Solution相当于将各个数字进行掩码操作，计算各个数组的同一个位上1的数量即可。 bin[]数组记录各个数字的各个位上的1的数量。如果当前数字与1进行掩码操作后等于1，则将该位数量加一。然后将当前数字向右移动一位，直至将所有的位都统计完。 最后返回各个位上的最大值即可。 Code1234567891011121314151617181920class Solution { public int largestCombination(int[] candidates) { int[] bin = new int[31]; int res = 0; for(int candidate : candidates){ int count = 0; while(count &lt; 31){ if((candidate &amp; 1) == 1){ bin[count]++; } candidate = candidate &gt;&gt; 1; count++; } } for(int time : bin){ res = Math.max(res, time); } return res; }}","link":"/2022/05/15/2275-Largest-Combination-With-Bitwise-AND/"},{"title":"2274. Maximum Floors Without Special Floors","text":"Question Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be special floors, used for relaxation only. You are given two integers bottom and top, which denote that Alice has rented all the floors from bottom to top (inclusive). You are also given the integer array special, where special[i] denotes a special floor that Alice has designated for relaxation. Return the maximum number of consecutive floors without a special floor. Solution可以视为特殊的动态规划。 计算每个特殊房间与上一个特殊房间的层数。（可以将底层的上一个房间视为特殊房间，需要将第一个房间设置为bottom-1）。当距离大于当前结果时则更新res。 最后需要计算最后一层到上一个特殊房间的距离。（可以将顶楼的上一层视为特殊房间，因此直接计算top - lastRoom的层数即可） Code123456789101112131415161718class Solution { public int maxConsecutive(int bottom, int top, int[] special) { int res = 0; int lastRoom = bottom-1; Arrays.sort(special); for(int room : special){ int temp = room - lastRoom - 1; res = Math.max(res, temp); lastRoom = room; } int temp = top - lastRoom; res = Math.max(res, temp); return res; }}","link":"/2022/05/15/2274-Maximum-Floors-Without-Special-Floors/"},{"title":"2278. Percentage of Letter in String","text":"Question Given a string s and a character letter, return* the percentage of characters in s that equal letter rounded down to the nearest whole percent.* Solution一次遍历，计算字符出现的次数。返回字符出现的次数除以字符长度乘以100。 Code1234567891011class Solution { public int percentageLetter(String s, char letter) { int count = 0; for(int i = 0; i &lt; s.length(); i++){ if(s.charAt(i) == letter){ count++; } } return count * 100 / s.length(); }}","link":"/2022/05/22/2278-Percentage-of-Letter-in-String/"},{"title":"2279. Maximum Bags With Full Capacity of Rocks","text":"Question You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The i&lt;sup&gt;th&lt;/sup&gt; bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags. Return* the maximum number of bags that could have full capacity after placing the additional rocks in some bags.* Solution计算每个背包的剩余空间，然后进行排序。按从小到大的顺序依次减少石头的总数。设置i作为选取石头的计数。每次循环将i增加，直到剩余的石头数量小于0。如果最后剩下的石头仍然大于等于0，则返回计数。否则返回计数-1。 Code12345678910111213141516class Solution { public int maximumBags(int[] capacity, int[] rocks, int additionalRocks) { int[] diff = new int[capacity.length]; for(int i = 0 ; i &lt; capacity.length; i++){ diff[i] = capacity[i] - rocks[i]; } Arrays.sort(diff); int i = 0; while(additionalRocks &gt; 0 &amp;&amp; i &lt; diff.length){ additionalRocks -= diff[i]; i++; } return additionalRocks &gt;= 0 ? i : i - 1; }}","link":"/2022/05/22/2279-Maximum-Bags-With-Full-Capacity-of-Rocks/"},{"title":"2280. Minimum Lines to Represent a Line Chart","text":"Question You are given a 2D integer array stockPrices where stockPrices[i] = [day&lt;sub&gt;i&lt;/sub&gt;, price&lt;sub&gt;i&lt;/sub&gt;] indicates the price of the stock on day day&lt;sub&gt;i&lt;/sub&gt; is price&lt;sub&gt;i&lt;/sub&gt;. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below: Solution如果只有一个点，无法组成线段则返回0。否则至少可以组成1条线段。 首先将所有点根据x的位置排序，然后一次比较连续的各个向量的方向。为了防止除法精度问题，计算两个向量（三个点组成两个向量）的叉乘，如果叉乘为0，则说明两个向量是平行的，此时不需要增加计数。如果叉乘结果不等于0，则将计数+1。 最后返回计数的结果。 Code12345678910111213141516171819class Solution { public int minimumLines(int[][] stockPrices) { if(stockPrices.length == 1) return 0; Arrays.sort(stockPrices, (a,b) -&gt; a[0] - b[0]); int count = 1, lastX = 0, lastY = 0; for(int i = 1; i &lt; stockPrices.length; i++){ int x = stockPrices[i][0] - stockPrices[i-1][0]; int y = stockPrices[i][1] - stockPrices[i-1][1]; int k = lastX * y - lastY * x; if(k != 0) count++; lastX = x; lastY = y; } return count; }}","link":"/2022/05/22/2280-Minimum-Lines-to-Represent-a-Line-Chart/"},{"title":"2281. Sum of Total Strength of Wizards","text":"Question As the ruler of a kingdom, you have an army of wizards at your command. You are given a 0-indexed integer array strength, where strength[i] denotes the strength of the i&lt;sup&gt;th&lt;/sup&gt; wizard. For a contiguous group of wizards (i.e. the wizards’ strengths form a subarray of strength), the total strength is defined as the product of the following two values: The strength of the weakest wizard in the group. The total of all the individual strengths of the wizards in the group. Return the sum of the total strengths of all contiguous groups of wizards. Since the answer may be very large, return it modulo 10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7. A subarray is a contiguous non-empty sequence of elements within an array. Solution参考连接 根据题意，我们需要的结果是所有子数列乘以该子数列中最小值之和。 数组strength[]中的每一个元素，都充当一定范围内的子数列的最小值。因此我们需要**确定每个元素充当最小值的范围(left, right)**。然后计算这个元素可以组成的子数列的和与这个元素的乘积。 我们的问题相当于确定下一个更小元素，而单调栈专门处理这一类问题——“下一个更大/更小元素”496. Next Greater Element I 通过单调栈，我们可以确定最小值为strength[i]的子数列的范围(left, right)，并将其保存在两个数组left[]与right[]中。 最后通过前缀和的计算，来确定(left, right)范围内的子数列之和。 单调栈新建两个数组left[]， right[]保存以strength[i]为最小值的范围。 维护两个单调栈，保证下列关系：strength[left] &lt; strength[i]strength[right] &lt;= strength[i] 其中，left取小于号，而right可以等于是为了取值不重复。 注意，单调栈保存的是下标，这样使用起来更加灵活。 前缀和为了得到范围（left, right）内的所有子数列之和。我们可以观察left, i, right之间的关系。 …left-1, left, left + 1, left + 2, … i-1, i, i+1, … right-1, right, right+1… 开始于 left+1的子数列:sum(left+1, … i) = prefix[i + 1] - prefix[left + 1]sum(left+1, … i+1) = prefix[i + 2] - prefix[left + 1]…sum(left+1, … right-1) = prefix[right] - prefix[left + 1] 开始于left+2的子数列:sum(left+2, … i) = prefix[i + 1] - prefix[left + 2]sum(left+2, … i+1) = prefix[i + 2] - prefix[left + 2]…sum(left+2, … right-1) = prefix[right] - prefix[left + 2]… 开始于i的子数列:sum(i, … i) = prefix[i + 1] - prefix[i]sum(i, … i+1) = prefix[i + 2] - prefix[i]…sum(i, … right-1) = prefix[right] - prefix[i] 合并这些式子，我们可以得到： 正数 部分:(prefix[i + 1] + prefix[i + 2] + ... + prefix[right]) * (i - left) 负数 部分:(prefix[left + 1] + prefix[left + 2] + ... + prefix[i]) * (right - i) 最后我们可以提前计算前缀和的前缀和来优化计算步骤，注意计算时需要将各个部分模除以保证不超过范围。正数部分模除后需要加上MOD以保证其减去负数部分的结果大于0。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution { public int totalStrength(int[] strength) { long MOD = 1_000_000_007; int n = strength.length; Deque&lt;Integer&gt; mono = new ArrayDeque&lt;&gt;(); int[] left = new int[n], right = new int[n]; for(int i = 0; i &lt; strength.length; i++){ //单调栈，记录比当前元素strength[i]小的第一个左侧位置strength[left] while(!mono.isEmpty() &amp;&amp; strength[mono.peek()] &gt;= strength[i]){ mono.pop(); } left[i] = mono.isEmpty() ? -1 : mono.peek(); mono.push(i); } mono.clear(); for(int i = n-1; i &gt;=0; i--){ //单调栈，记录比当前元素strength[i]小的第一个右侧位置strength[right] while(!mono.isEmpty() &amp;&amp; strength[mono.peek()] &gt; strength[i]){ mono.pop(); } right[i] = mono.isEmpty() ? n : mono.peek(); mono.push(i); } long[] prefix = new long[n+1], prefix_sum = new long[n+2]; for(int i = 1; i &lt;= strength.length; i++){ //计算前缀和 prefix[i] = (prefix[i-1] + strength[i-1]) % MOD; } for(int i = 2; i &lt;= strength.length+1; i++){ //计算前缀和的前缀和 prefix_sum[i] = (prefix_sum[i-1] + prefix[i-1]) % MOD; } long res = 0; for(int i = 0; i &lt; n; i++){ res += ((prefix_sum[right[i] + 1] - prefix_sum[i + 1]) * (i - left[i]) % MOD + MOD - //这里加MOD是为了保证前项大于后项，防止出现负数 (prefix_sum[i + 1] - prefix_sum[left[i] + 1]) * (right[i] - i) % MOD ) * strength[i]; res %= MOD; } return (int) res; }}","link":"/2022/05/22/2281-Sum-of-Total-Strength-of-Wizards/"},{"title":"230. Kth Smallest Element in a BST","text":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. DFS搜索，遍历的时候更新全局变量count。采用中序搜索，当count等于k时，将全局变量ans设置为root.val。搜索完毕返回ans。 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int ans; int count; public int kthSmallest(TreeNode root, int k) { ans = -1; count = 0; dfs(root,k); return ans; } private void dfs(TreeNode root, int k){ if(root == null){ return; } dfs(root.left,k); count++; if (k == count){ ans = root.val; } dfs(root.right,k); }}","link":"/2022/04/18/230-Kth-Smallest-Element-in-a-BST/"},{"title":"2299. Strong Password Checker II","text":"Question A password is said to be strong if it satisfies all the following criteria: It has at least 8 characters. It contains at least one lowercase letter. It contains at least one uppercase letter. It contains at least one digit. It contains at least one special character. The special characters are the characters in the following string: &quot;!@#$%^&amp;*()-+&quot;. It does not contain 2 of the same character in adjacent positions (i.e., &quot;aab&quot; violates this condition, but &quot;aba&quot; does not). Given a string password, return true* if it is a strong password*. Otherwise, return false. Solution直接遍历，记录四个真值对应四个符号，初始化为false，和上一个字符last。每次遍历检查当前字符，如果等于上个字符则直接返回false。根据字符范围来改变四个真值，最后返回四个真值的和运算。 Code1234567891011121314151617181920class Solution { public boolean strongPasswordCheckerII(String password) { if(password.length() &lt; 8) return false; char last = ' '; boolean hasLower = false, hasUpper = false, hasDigit = false, hasSpecial = false; char[] word = password.toCharArray(); for(int i = 0; i &lt; password.length(); i++){ char cur = word[i]; if(last == cur) return false; if(cur &gt;= 'a' &amp;&amp; cur &lt;= 'z') hasLower = true; else if(cur &gt;= 'A' &amp;&amp; cur &lt;= 'Z') hasUpper = true; else if(cur &gt;= '0' &amp;&amp; cur &lt;= '9') hasDigit = true; else hasSpecial = true; last = cur; } return hasLower &amp;&amp; hasUpper &amp;&amp; hasDigit &amp;&amp; hasSpecial; }}","link":"/2022/06/12/2299-Strong-Password-Checker-II/"},{"title":"2300. Successful Pairs of Spells and Potions","text":"Question You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the i&lt;sup&gt;th&lt;/sup&gt; spell and potions[j] represents the strength of the j&lt;sup&gt;th&lt;/sup&gt; potion. You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success. Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the i&lt;sup&gt;th&lt;/sup&gt; spell. Solution 1排序+二分搜索。同时记录success与spells[i]的比值来减小计算量。 排序首先对potions[]进行排序，这样可以使用二分搜索查找分界值。数组scales[]记录success与spells[i]的比值，以此为界大于等于scales[i]的位置都可以计入ret[]数组。 二分搜索这里有一些tricky。 由于Arrays.binarySearch()方法无法返回重复的数字，因此在搜索时我们将查找值scale减去一个小值，保证在搜索时一定返回负值。（查找值的插入位置的负数-1）将ret[i]记录为potions[]的总数减去正确的插入位置即可。 Code12345678910111213141516171819class Solution { public int[] successfulPairs(int[] spells, int[] potions, long success) { int[] ret = new int[spells.length]; Arrays.sort(potions); double[] scales = new double[potions.length]; for(int i = 0; i &lt; potions.length; i++){ scales[i] = (double) potions[i]; } for(int i = 0; i &lt; spells.length; i++){ double scale = (double) success / spells[i] - 0.000001; //确保浮点数不在scale中出现，binarySearch方法返回的结果必定为上一个插入位置 int index = Arrays.binarySearch(scales, scale); ret[i] = potions.length + (index + 1); } return ret; }} Solution 2由于Arrays.binarySearch()无法正确的搜索有重复元素的数组，因此采用辅助方法binarySearch()来搜索最左侧的下标。 直接在binarySearch()方法中查找target，比较的对象为spell和potions[i]的乘积。 为了搜寻重复的第一个元素，当遇到target时不直接返回，而是继续修改right的位置，直到left等于right。 如果未搜索到，则返回数组的总长度。 Code123456789101112131415161718192021class Solution { public int[] successfulPairs(int[] spells, int[] potions, long success) { int[] ret = new int[spells.length]; Arrays.sort(potions); for(int i = 0; i &lt; spells.length; i++){ int index = binarySearch(potions, spells[i], success); ret[i] = potions.length - index; } return ret; } private int binarySearch(int[] potions, long spell, long target){ int left = 0, right = potions.length - 1; while(left &lt; right){ int mid = left + (right - left) / 2; if(potions[mid] * spell &lt; target) left = mid + 1; else right = mid; } return potions[left] * spell &lt; target ? potions.length : left; }}","link":"/2022/06/12/2300-Successful-Pairs-of-Spells-and-Potions/"},{"title":"231. Power of Two","text":"问题Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. 位运算，由于2^n^的二进制为[100…00]，当2^n^-1时，其二进制为[11..11]（少一位）。两者进行按位与（&amp;）运算，得到[000…00]，与0相等。 12345678class Solution { public boolean isPowerOfTwo(int n) { if (n &lt;= 0){ return false; } return (n &amp; (n - 1)) == 0; }} 递归，当（n &lt;= 0）时，返回false。当n等于1时，返回true。当（n % 2）有余数时，返回false。递归（n / 2）。 1234567891011121314class Solution { public boolean isPowerOfTwo(int n) { if (n &lt;= 0){ return false; } if (n == 1){ return true; } if (n%2 != 0){ return false; } return isPowerOfTwo(n/2); }}","link":"/2022/04/14/231-Power-of-Two/"},{"title":"2302. Count Subarrays With Score Less Than K","text":"Question The score of an array is defined as the product of its sum and its length. For example, the score of [1, 2, 3, 4, 5] is (1 + 2 + 3 + 4 + 5) * 5 = 75. Given a positive integer array nums and an integer k, return the number of non-empty subarrays of nums whose score is strictly less than k. A subarray is a contiguous sequence of elements within an array. Solution第一次在contest中做出hard题目，而且还是超过100%，庆祝一下！（不过因为前一道题做的太久没提交上去…… 滑动窗口数组内全部为正整数，当选择的子数组的尺寸增加时，其乘积是单调递增的。因此可以采用滑动窗口，在循环时维护窗口内数字的和sum和当前的乘积product。 每次将一个新的右侧元素滑入窗口，更新窗口内的sum值，并计算product值。当当前product大于k时，则将左侧的元素滑出窗口，并更新sum和product值。 调整完窗口尺寸后，由于新的right位置可以和前面的每一个子数组组成一个新的数组，因此将count加上当前的left到right的个数即可。 循环结束后返回count。 Code1234567891011121314151617181920class Solution { public long countSubarrays(int[] nums, long k) { long count = 0, sum = 0; int left = 0, right = 0; while(right &lt; nums.length){ sum += nums[right]; //右侧滑入窗口 long product = sum * (right - left + 1); while(product &gt;= k){ //当乘积大于k时，左侧滑出窗口 sum -= nums[left]; left++; product = sum * (right - left + 1); } count += right - left + 1; //计算新的right位置可组成的新组合 right++; } return count; }}","link":"/2022/06/12/2302-Count-Subarrays-With-Score-Less-Than-K/"},{"title":"2315. Count Asterisks","text":"Question You are given a string s, where every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd '|' make a pair, the 3rd and 4th '|' make a pair, and so forth. Return *the number of '*' in s, excluding the '*' between each pair of *'|'. Note that each '|' will belong to exactly one pair. Solution统计“|”字符出现的数量，如果数量为偶数时，则计算出现的“*”符号。 Code12345678910class Solution { public int countAsterisks(String s) { int num = 0, count = 0; for(char c : s.toCharArray()){ if(c == '|') num++; else if((num &amp; 1) == 0 &amp;&amp; c == '*') count++; } return count; }}","link":"/2022/06/26/2315-Count-Asterisks/"},{"title":"2316. Count Unreachable Pairs of Nodes","text":"Question You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;] denotes that there exists an undirected edge connecting nodes a&lt;sub&gt;i&lt;/sub&gt; and b&lt;sub&gt;i&lt;/sub&gt;. Return the number of pairs of different nodes that are unreachable from each other. Solution并查集，将所有元素union，然后计算每个元素所在集之外的元素和相加即可。注意由于是无向图，因此计算加和时每两个点之间都计算了两次，因此需要将结果除以2。 路径压缩在进行find()查找时，将经过的每一个节点设置为根节点。这样做可以有效的降低树高，减少操作次数。采用递归的形式实现。 按秩合并用size[]数组记录当前位置的节点数量。在合并两个数字时，将秩较小的数字指向秩较大的数字。并更新根节点的size[]值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public long countPairs(int n, int[][] edges) { UnionFind uf = new UnionFind(n); long res = 0; for(int[] edge : edges){ uf.union(edge[0], edge[1]); } for(int i = 0; i &lt; n; i++){ res += ( n - uf.getSize(i) ); } return res/2; //无向图，因此每两个节点计算了两次 } class UnionFind { int[] parent; int[] size; public UnionFind(int n){ parent = new int[n]; size = new int[n]; for(int i = 0; i &lt; n; i++){ parent[i] = i; size[i] = 1; } } private int find(int id){ return parent[id] == id ? id : find(parent[id]); //路径压缩，将路径上的所有节点归结到根节点上 } private boolean union(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; if(size[p1] &gt; size[p2]){ //按秩进行压缩 parent[p2] = p1; size[p1] += size[p2]; } else{ parent[p1] = p2; size[p2] += size[p1]; } return true; } public int getSize(int num){ return size[find(num)]; } }}****","link":"/2022/06/26/2316-Count-Unreachable-Pairs-of-Nodes/"},{"title":"2317. Maximum XOR After Operations","text":"Question You are given a 0-indexed integer array nums. In one operation, select any non-negative integer x and an index i, then update nums[i] to be equal to nums[i] AND (nums[i] XOR x). Note that AND is the bitwise AND operation and XOR is the bitwise XOR operation. Return the maximum possible bitwise XOR of all elements of nums after applying the operation any number of times. Solution异或运算相当于不进位的加和。和运算相当于掩码操作。或运算相当于保留该位上的1。 由于我们要对所有数字进行异或运算，因此只要能改变某一位对应的数字，我们就可以确保这一位在进行异或运算时结果可以为1。（当不改变时改为的异或运算结果为0，则我们只需要改变改为即可得到1） 将所有我们可以操作的位置变为1，就可以得到最大值。 因此，我们只需要确定哪些位是我们可以操作的即可： nums[i]与任意正整数进行异或运算可以得到任意整数。在这个条件下我们可以得到任意的32位整数。 然而和运算相当于掩码操作，如果nums[i]对应二进制的某一位上位0，则我们无法通过和运算将这一位改变为1。 只要该位出现过1，则我们可以控制这个位。因此我们可以通过或运算所有数字，保留所有可控制的位。 Code123456789class Solution { public int maximumXOR(int[] nums) { int sum = 0; for(int num : nums){ sum |= num; } return sum; }}","link":"/2022/06/26/2317-Maximum-XOR-After-Operations/"},{"title":"2318. Number of Distinct Roll Sequences","text":"Question You are given an integer n. You roll a fair 6-sided dice n times. Determine the total number of distinct sequences of rolls possible such that the following conditions are satisfied: The greatest common divisor of any adjacent values in the sequence is equal to 1. There is at least a gap of 2 rolls between equal valued rolls. More formally, if the value of the i&lt;sup&gt;th&lt;/sup&gt; roll is equal to the value of the j&lt;sup&gt;th&lt;/sup&gt; roll, then abs(i - j) &gt; 2. Return the* total number** of distinct sequences possible*. Since the answer may be very large, return it modulo 10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7. Two sequences are considered distinct if at least one element is different. SolutionDFS+记忆化搜索剪枝。辅助方法getValidNext计算前两个位置为last1和last2时的所有的下一个有效值，将返回值储存在next[][]数组中。 DFS搜索DFS搜索，传入剩余骰子数量n，前两个骰子的值x和y。从next[x][y]中得到所有有效值。并进行递归。将返回结果加和并返回。当n等于0时，只有一个组合，因此返回1。 记忆化搜索在搜索时会重复计算很多相同的x，y与n的组合，因此可以采用记忆化搜索进行剪枝。用memo[][][]数组记录x，y与n的状态。如果此前已经计算过其结果，则直接返回memo[x][y][n]。 Code123456789101112131415161718192021222324252627282930313233343536373839class Solution { List&lt;Integer&gt;[][] next; int[][][] memo; public int distinctSequences(int n) { next = new ArrayList[7][7]; for(int i = 0; i &lt;= 6; i++){ for(int j = 0; j &lt;= 6; j++){ next[i][j] = getValidNext(i, j); } } memo = new int[7][7][10001]; return count(n, 0, 0); } private int count(int n, int x, int y){ if(n == 0) return 1; if(memo[x][y][n] != 0) return memo[x][y][n]; List&lt;Integer&gt; validNext = next[x][y]; int sum = 0; for(int z : validNext){ sum += count(n-1, y, z); sum %= 1000000007; } memo[x][y][n] = sum; return sum; } private List&lt;Integer&gt; getValidNext(int last1, int last2){ List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); for(int i = 1; i &lt;= 6; i++){ if(last1 == 0 &amp;&amp; last2 == 0) arr.add(i); else if(i == last1 || i == last2) continue; else if((last2 &amp; 1) == 0 &amp;&amp; (i &amp; 1) == 0) continue; else if((last2 == 3 || last2 == 6) &amp;&amp; (i == 3 || i == 6)) continue; else arr.add(i); } return arr; }}","link":"/2022/06/26/2318-Number-of-Distinct-Roll-Sequences/"},{"title":"2319. Check if Matrix Is X-Matrix","text":"Question A square matrix is said to be an X-Matrix if both of the following conditions hold: All the elements in the diagonals of the matrix are non-zero. All other elements are 0. Given a 2D integer array grid of size n x n representing a square matrix, return true* if grid is an X-Matrix*. Otherwise, return false. Solution遍历，直接判断是否在对角线上，如果在且位置为0，则返回false。如果不在对角线上，且位置部位0，则返回false。 Code1234567891011121314class Solution { public boolean checkXMatrix(int[][] grid) { int n = grid.length; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ if(i == j || i + j == n - 1){ if(grid[i][j] == 0) return false; } else if(grid[i][j] != 0) return false; } } return true; }}","link":"/2022/06/26/2319-Check-if-Matrix-Is-X-Matrix/"},{"title":"232. Implement Queue using Stacks","text":"问题Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise.Notes: You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. 创建两个栈。当入队列时，将元素压入第一个栈。当出队列或进行其他操作时，如第二个栈为空，则将第一个栈的元素倒出到第二个栈。此时第二个栈内的内容为顺序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyQueue { Stack&lt;Integer&gt; s1; Stack&lt;Integer&gt; s2; public MyQueue() { s1 = new Stack(); s2 = new Stack(); } public void push(int x) { s1.add(x); } public int pop() { if (s2.isEmpty()){ while (!s1.isEmpty()){ s2.add(s1.pop()); } return s2.pop(); } else{ return s2.pop(); } } public int peek() { if (s2.isEmpty()){ while (!s1.isEmpty()){ s2.add(s1.pop()); } return s2.peek(); } else{ return s2.peek(); } } public boolean empty() { return s1.isEmpty() &amp;&amp; s2.isEmpty(); }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","link":"/2022/04/12/232-Implement-Queue-using-Stacks/"},{"title":"2320. Count Number of Ways to Place Houses","text":"Question There is a street with n * 2 plots, where there are n plots on each side of the street. The plots on each side are numbered from 1 to n. On each plot, a house can be placed. Return the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. Since the answer may be very large, return it modulo 10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7. Note that if a house is placed on the i&lt;sup&gt;th&lt;/sup&gt; plot on one side of the street, a house can also be placed on the i&lt;sup&gt;th&lt;/sup&gt; plot on the other side of the street. Solution计算单侧河道可以放置的种类。一开始用的是DFS搜素来计算可以放置的种类。计算后发现是以（2，3）开始的斐波那契数列。 因此直接计算n位置的斐波那契数列值即可。然后两边可以匹配的种类就是其平方。 记忆化搜索在计算斐波那契数列时，由于要多次重复计算前面的位置，因此可以采用记忆化搜索记录对应的斐波那契额值。 Code12345678910111213141516171819class Solution { long[] memo; public int countHousePlacements(int n) { memo = new long[n+1]; long res = fibo(n); res *= res; res %= 1000000007; return (int) res; } private long fibo(int n){ if(n == 1) return 2; else if(n == 2) return 3; if(memo[n] != 0) return memo[n]; memo[n] = fibo(n-1) % 1000000007 + fibo(n-2) % 1000000007; return memo[n]; }}","link":"/2022/06/26/2320-Count-Number-of-Ways-to-Place-Houses/"},{"title":"2321. Maximum Score Of Spliced Array","text":"Question You are given two 0-indexed integer arrays nums1 and nums2, both of length n. You can choose two integers left and right where 0 &lt;= left &lt;= right &lt; n and swap the subarray nums1[left...right] with the subarray nums2[left...right]. For example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and you choose left = 1 and right = 2, nums1 becomes [1,&lt;strong&gt;&lt;u&gt;12,13&lt;/u&gt;&lt;/strong&gt;,4,5] and nums2 becomes [11,&lt;strong&gt;&lt;u&gt;2,3&lt;/u&gt;&lt;/strong&gt;,14,15]. You may choose to apply the mentioned operation once or not do anything. The score of the arrays is the maximum of sum(nums1) and sum(nums2), where sum(arr) is the sum of all the elements in the array arr. Return the maximum possible score. A subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive). Solution滑动窗口。一开始想用dp解决的。后来发现可以优化到直接记录连续的最大差值即可。以后有提到连续的一定要想到滑动窗口实现。 辅助方法getMinContigouousDiff()用来计算两个数组间连续的最小的差值和。当sum为负数时，窗口向右侧扩展，将新的位置加入sum，并更新最小值min。当扩展后sum大于0时，则放弃之前的所有元素，将sum归零。最后返回最小值min。 计算两个数组的所有数字之和t1和t2。分别计算nums1[]和nums2[]的差min1和nums2[]和nums1[]的差min2。在其中替换连续的部分则为t1-min1，t2-min2。取两者中较大的数字返回即可。 Code1234567891011121314151617181920212223242526class Solution { public int maximumsSplicedArray(int[] nums1, int[] nums2) { int n = nums1.length; int t1 = 0, t2 = 0; for(int i = 0; i &lt; n ;i++){ //计算两个数组未替换前的和 t1 += nums1[i]; t2 += nums2[i]; } int min1 = getMinContiguousDiff(nums2, nums1); int min2 = getMinContiguousDiff(nums1, nums2); return Math.max(t1 - min1, t2 - min2); //替换连续的部分，两者中取最大值 } private int getMinContiguousDiff(int[] nums1, int[] nums2){ //滑动窗口，求连续元素间的最小差值 int sum = 0, min = 0; for(int i = 0; i &lt; nums1.length; i++){ if(sum &lt;= 0){ //当sum为负数时，窗口向右侧扩展，将新的位置加入sum int diff = nums2[i] - nums1[i]; sum += diff; if(diff &lt; 0) min = Math.min(min, sum); //更新最小值 if(sum &gt; 0) sum = 0; //当sum为正数时，抛弃前面的元素，重新开始计算sum } } return min; }}","link":"/2022/06/26/2321-Maximum-Score-Of-Spliced-Array/"},{"title":"234. Palindrome Linked List","text":"Question Given the head of a singly linked list, return true if it is a palindrome. Solution 1快慢指针，快指针遍历到底时慢指针正好到一半。根据快指针的位置判断奇数个还是偶数个。如果是奇数个则翻转链表时需要向前移动一位。 接下来翻转后半段链表。翻转完成后从第一段的头部和翻转过的链表头部开始遍历。如果两个节点的值不同则返回false。 遍历完毕返回true。 Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public boolean isPalindrome(ListNode head) { int len = 0; ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } ListNode curr = fast == null ? slow : slow.next, prev = null; //make sure curr is the head of the 2nd part while(curr != null){ //reverse the 2nd part of the nodes ListNode temp = curr.next; //preserve nodes that after current node curr.next = prev; //add previous node to the current node's next prev = curr; //save previous node curr = temp; //update current node } while(head != null &amp;&amp; prev != null){ if(head.val != prev.val) return false; prev = prev.next; head = head.next; } return true; }} Solution 2快慢指针的原理，不是记录长度而是当快指针遍历到链表尾时停止。然后对照栈内的值是否和剩余的值相等。 Code123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public boolean isPalindrome(ListNode head) { ListNode slow = head, fast = head; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while(fast != null &amp;&amp; fast.next != null){ stack.add(slow); slow = slow.next; fast = fast.next.next; } if(fast != null) slow = slow.next; while(!stack.isEmpty()){ if(stack.pop().val != slow.val) return false; slow = slow.next; } return true; }} Solution 3回文，先计算链表长度。记录链表长度是否为奇数。 如果链表长度为偶数，则将一半的节点放入栈中。如果为奇数则抛弃一个节点。剩下一半的节点和栈顶节点比较，如果值不相同则返回false。 遍历完成返回true。 Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public boolean isPalindrome(ListNode head) { int len = 0; ListNode root = head; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while(root != null){ root = root.next; len++; } root = head; for(int i = 0; i &lt; len/2; i++){ stack.add(root); root = root.next; } if(len % 2 != 0) root = root.next; for(int i = 0; i &lt; len/2; i++){ if(stack.peek().val == root.val) stack.pop(); else return false; root = root.next; } return true; }}","link":"/2022/08/22/234-Palindrome-Linked-List/"},{"title":"235. Lowest Common Ancestor of a BST","text":"问题Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” DFS搜索，如果当前节点为null，则返回null。如果当前节点小于p和q的值，则递归其左子节点。反之递归其右子节点。如果当前节点在p与q之间，则返回当前节点。该节点是p与q的Lowest Common Ancestor。 123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null){ return null; } if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val){ return lowestCommonAncestor(root.left, p, q); } if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val){ return lowestCommonAncestor(root.right, p, q); } return root; }}","link":"/2022/04/16/235-Lowest-Common-Ancestor-of-a-BST/"},{"title":"236. Lowest Common Ancestor of a Binary Tree","text":"Question Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” SolutionDFS搜索，后序遍历。当当前节点是p或者q，返回节点自身，代表已经找到节点。（如两个节点最终只访问了一个，说明那一个节点本身就是LCA。） 分别递归搜索左右子节点。 如果左子节点为空，则返回右子节点，反之亦然，保证找到的节点可以被返回。如果左右子节点均不等于null，则当前节点是最低公共祖先（LCA），返回当前节点。 Code123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; if(root == p) return p; //found target and return if(root == q) return q; //found target and return TreeNode left = lowestCommonAncestor(root.left, p, q); //search left branch TreeNode right = lowestCommonAncestor(root.right, p, q); //search right branch if(left == null) return right; //if left not found target, return the right branch else if(right == null) return left; //if right not found target, return the left branch else return root; //if both found target, return the root }}","link":"/2022/05/03/236-Lowest-Common-Ancestor-of-a-Binary-Tree/"},{"title":"238. Product of Array Except Self","text":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. 当前数字之外的积等于左边所有数字的积乘以右边所有数字的积。因此可以维护两个数组，分别计算从左到右的乘积，和从右到左的乘积。 由于返回答案不算占用空间，因此可以将左侧乘积的数组保存在答案数组上。然后在遍历时，从右至左遍历，使用一个变量储存右边的乘积，直接将两者的乘积更新在答案数组上。此时空间复杂度为O(1)。 123456789101112131415161718class Solution { public int[] productExceptSelf(int[] nums) { int[] ans = new int[nums.length]; ans[0] = 1; for(int i = 1; i &lt; nums.length; i++){ ans[i] = ans[i-1] * nums[i-1]; } int rightProduct = 1; for(int j = nums.length-1; j &gt;=0; j--){ ans[j] = ans[j] * rightProduct; rightProduct *= nums[j]; } return ans; }}","link":"/2022/04/20/238-Product-of-Array-Except-Self/"},{"title":"24. Swap Nodes in Pairs","text":"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) 先建立一个哨兵节点，next指向head。交换时同时传入前一个节点pre和当前节点root。当当前节点非null且下一个节点非null，则可以交换两个节点。首先保存当前节点的下一个节点next和下一个节点的下一个节点last。 1.将pre指向next。 2.将next指向root。 3.将root指向last。 4.处理下一组节点，root作为pre，root.next作为root递归。最后返回哨兵节点的next。 1234567891011121314151617181920212223242526272829303132/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(0, head); swap(dummy, head); return dummy.next; } private void swap(ListNode pre, ListNode root){ if(root == null || root.next == null){ return; } else if(root != null &amp;&amp; root.next != null){ ListNode last = root.next.next; ListNode next = root.next; pre.next = next; next.next = root; root.next = last; } swap(root, root.next); }}","link":"/2022/04/26/24-Swap-Nodes-in-Pairs/"},{"title":"240. Search a 2D Matrix II","text":"Question Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Solution将起始点设置为第一行的最后一列。如果搜寻目标大于该点则向下搜索。如果搜寻目标小于该点则向左搜索。 Code123456789101112class Solution { public boolean searchMatrix(int[][] matrix, int target) { int i = 0, j = matrix[0].length - 1; while(i &lt; matrix.length &amp;&amp; j &gt;= 0){ if(matrix[i][j] == target) return true; else if(matrix[i][j] &gt; target) j--; else i++; } return false; }}","link":"/2022/04/18/240-Search-a-2D-Matrix-II/"},{"title":"242. Valid Anagram","text":"Problem Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Solution两数组相等时，直接遍历两个数组并记录各个字符出现的数量。一个数组遍历时用做加法，另一个做减法。如果最后每个字符出现的数量均为0，则返回真。 Code12345678910111213141516171819class Solution { public boolean isAnagram(String s, String t) { if (s.length()!=t.length()){ return false; } int[] dic = new int[26]; for (int i = 0; i &lt; s.length(); i++){ dic[s.charAt(i)-'a']++; dic[t.charAt(i)-'a']--; } for(int num : dic){ if ( num != 0 ){ return false; } } return true; }}","link":"/2022/04/06/242-Valid-Anagram/"},{"title":"25. Reverse Nodes in k-Group","text":"Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is. You may not alter the values in the list’s nodes, only nodes themselves may be changed. 采用直接更改节点的方法可以使用O(1)的空间完成操作。 递归，DFS搜索，首先初始化一个哨兵节点。将哨兵节点记录为first，下一个节点记录为second。 将first与second传入递归方法。向下递归下一个节点，并将长度k-1。当长度k等于1时，则递归到当前所需的栈底。将当前节点指向上一个节点，并将当前节点记录为last，下一个节点记录为next，返回true。当curr为null时，返回false。 当递归返回为true时（即剩余的链表有k个节点以供翻转），上级的节点们都指向其前一个节点。当返回到的栈顶（即k等于最开始的值）时，将first指向last，将second指向next。 继续向下递归first与second。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { int K; ListNode next; ListNode prev; ListNode last; ListNode first; ListNode second; public ListNode reverseKGroup(ListNode head, int k) { if(k == 1) return head; K = k; ListNode dummy = new ListNode(0); dummy.next = head; prev = dummy; next = null; last = null; first = prev; second = prev.next; reverse(prev, dummy.next, k); return dummy.next; } private boolean reverse(ListNode prev, ListNode curr, int k){ if(curr == null) return false; if(k == 1){ last = curr; next = curr.next; curr.next = prev; return true; } if( reverse(curr, curr.next, k-1) ){ curr.next = prev; if(k == K){ first.next = last; second.next = next; first = curr; second = curr.next; reverse(first, second, k); } return true; } return false; } private void print(ListNode root){ while(root != null){ root = root.next; } }}","link":"/2022/04/28/25-Reverse-Nodes-in-k-Group/"},{"title":"26. Remove Duplicates from Sorted Array","text":"QuestionGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k* after placing the final result in the first k slots of *nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Solution由于数组本身已经排序，只要比较当前nums中的元素是否大于上一个保存的数值就可以决定是否保留。创建一个k记录遍历的位置，每次比较nums[k]与nums[i]的位置元素的大小，如果当前的nums[i]大于nums[k]，则将k位置向后移动1，并将下一个位置记录为nums[i]。 最后返回k+1。 Code123456789101112class Solution { public int removeDuplicates(int[] nums) { int k = 0; for(int i = 0; i &lt; nums.length; i++){ if(nums[k] &lt; nums[i]){ k++; nums[k] = nums[i]; } } return k + 1; }}","link":"/2022/11/11/26-Remove-Duplicates-from-Sorted-Array/"},{"title":"268. Missing Number","text":"Question Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Solution 1采用数学方法，从0到n的和减去从nums中的每个元素的和，得到的即是缺失的数字。循环所有下标，每次在结果上加上下标的值，并减去下标对应的元素。最后需要再加上nums内元素数量+1的值。 Code1234567891011class Solution { public int missingNumber(int[] nums) { int sum = nums.length; for(int i = 0; i &lt; nums.length; i++){ sum -= nums[i]; sum += i; } return sum; }} Solution 2遍历，采用一个数组found[]记录是否访问过。再次遍历，如果存在未访问过的位置，则返回下标。 Code1234567891011121314class Solution { public int missingNumber(int[] nums) { int res = 0; int[] found = new int[nums.length+1]; for(int i = 0; i &lt; nums.length; i++){ found[nums[i]] = 1; } for(int i = 0; i &lt;= nums.length; i++){ if(found[i] == 0) res = i; } return res; }}","link":"/2022/05/28/268-Missing-Number/"},{"title":"283. Move Zeroes","text":"问题描述Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. 双指针，i指针左侧保留大于零的元素，j指针左侧保留等于零的元素。 1234567891011121314151617class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = 0; while ( j &lt; nums.length ){ if ( nums[j] != 0 ){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; } j++; } }}","link":"/2022/04/05/283-Move-Zeroes/"},{"title":"284. Peeking Iterator","text":"Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: PeekingIterator(Iterator nums) Initializes the object with the given integer iterator iterator. int next() Returns the next element in the array and moves the pointer to the next element. boolean hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer. Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions. 使用队列储存迭代器里的数据，根据需要返回队列里的数据。 123456789101112131415161718192021222324252627282930// Java Iterator interface reference:// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.htmlclass PeekingIterator implements Iterator&lt;Integer&gt; { Queue&lt;Integer&gt; q; public PeekingIterator(Iterator&lt;Integer&gt; iterator) { // initialize any member here. q = new LinkedList&lt;&gt;(); while(iterator.hasNext()){ q.add(iterator.next()); } } // Returns the next element in the iteration without advancing the iterator. public Integer peek() { return q.peek(); } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next() { return q.poll(); } @Override public boolean hasNext() { return !q.isEmpty(); }}","link":"/2022/04/25/284-Peeking-Iterator/"},{"title":"289. Game of Life","text":"问题According to Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.” The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state. 辅助方法，计算每个位置四周有生命的总和。根据规则填写到新数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { public void gameOfLife(int[][] board) { int[][] ans = new int[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++){ for (int j = 0; j &lt; board[0].length; j++){ int neighbors = countNeighbors(board, i, j); if ( neighbors &lt; 2 &amp;&amp; board[i][j] == 1 ){ ans[i][j] = 0; } else if( neighbors &lt;= 3 &amp;&amp; board[i][j] == 1 ){ ans[i][j] = 1; } else if( neighbors &gt; 3 &amp;&amp; board[i][j] == 1 ){ ans[i][j] = 0; } else if( neighbors == 3 &amp;&amp; board[i][j] == 0){ ans[i][j] = 1; } } } for (int i = 0; i &lt; board.length; i++){ for (int j = 0; j &lt; board[0].length; j++){ board[i][j] = ans[i][j]; } } } private int countNeighbors(int[][] board, int r, int c){ int neighbors = 0; int row = board.length; int col = board[0].length; if(r + 1 &lt; row &amp;&amp; board[r+1][c] == 1){ neighbors++; } if(r - 1 &gt;= 0 &amp;&amp; board[r-1][c] == 1){ neighbors++; } if(c + 1 &lt; col &amp;&amp; board[r][c+1] == 1){ neighbors++; } if(c - 1 &gt;= 0 &amp;&amp; board[r][c-1] == 1){ neighbors++; } if(r + 1 &lt; row &amp;&amp; c + 1 &lt; col &amp;&amp; board[r+1][c+1] == 1){ neighbors++; } if(r + 1 &lt; row &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r+1][c-1] == 1 ){ neighbors++; } if(r - 1 &gt;= 0 &amp;&amp; c + 1 &lt; col &amp;&amp; board[r-1][c+1] == 1 ){ neighbors++; } if(r - 1 &gt;= 0 &amp;&amp; c - 1 &gt;= 0 &amp;&amp; board[r-1][c-1] == 1 ){ neighbors++; } return neighbors; }}","link":"/2022/04/12/289-Game-of-Life/"},{"title":"29. Divide Two Integers","text":"Question Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return *the quotient after dividing dividend by *divisor. **Note: **Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;− 1]. For this problem, if the quotient is strictly greater than 2&lt;sup&gt;31&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;- 1, then return 2&lt;sup&gt;31&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;- 1, and if the quotient is strictly less than -2&lt;sup&gt;31&lt;/sup&gt;, then return -2&lt;sup&gt;31&lt;/sup&gt;. Solution解题思路类似于快速幂。 使用快速乘法来快速的获得商。 计算过程相当于：60/8 = (60-32)/8 + 4 = (60-32-16)/8 + 2 + 4 = 1 + 2 + 4 = 7 需要注意的是由于只使用了整数（int）而不是长整数（long）储存数据，因此计算时需要处理各种溢出问题。 整数溢出由于采用32位整数记录数字，负数要比正数的值范围大1。因此当divisor为负数时，如果负数为整数最小值，则需要返回对应的整数最大值。 同时，为了在计算时防止整数溢出，因此将被除数与除数统一转为负数计算。（负数的数值比整数范围大）当向下递归时，要保持dividend和divisor的正负性不变。 快速乘只要被除数大于除数，则商至少为1。循环，当被除数大于两倍的除数时，则商的结果可以直接翻倍。 否则将被除数减去当前的除数，然后向下递归新的被除数和除数。最后返回快速乘中计算出的商加上向下递归返回的结果。 Code123456789101112131415161718192021class Solution { public int divide(int dividend, int divisor) { if(dividend == 0) return 0; if(divisor == 1) return dividend; if(divisor == -1) return dividend == Integer.MIN_VALUE ? Integer.MAX_VALUE : -dividend; //当dividend为最小整数时，其负数溢出，此时返回Integer.MAX_VALUE int a = dividend, b = divisor; int sign = a &gt; 0 &amp;&amp; b &gt; 0 || a &lt; 0 &amp;&amp; b &lt; 0 ? 1 : -1; //记录除数与被除数是否同号 if(dividend &gt; 0) a = -a; //将除数与被除数转换为负数，因为负数能记录的数值比正数大1，防止溢出 if(divisor &gt; 0) b = -b; if(a &gt; b) return 0; //被除数小于除数时返回0 int res = 1; while(a &lt;= b+b &amp;&amp; b+b &lt; 0){ //算法核心，快速乘法 b += b; //除数每次翻倍，直到大于被除数 res += res; //商的结果翻倍 } res = sign == 1 ? res : -res; //根据是否同号记录商 divisor = dividend &gt; 0 ? -divisor : divisor; //当原有被除数是正数时，要将除数取反 return res + divide(a-b, divisor); }}","link":"/2022/05/31/29-Divide-Two-Integers/"},{"title":"290. Word Pattern","text":"Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. 先将s分割成数组。如果words的长度和pattern的长度不同则返回false。用长度为26的数组储存pattern的字符。同时遍历words和pattern，将pattern的字符换算成数字作为index，将words[i]填入数组。如果数组中已经有word存在，则检查新的word和数组内的word是否相等。如果不相等，则返回false。 最后遍历数组，比对各个字符中对应的word是否相等，如果有相等的，则返回false。由于数组长度固定，因此这个操作的时间复杂度是O(1)。 1234567891011121314151617181920212223242526272829303132333435class Solution { public boolean wordPattern(String pattern, String s) { String[] words = s.split(&quot; &quot;); String[] alphabet = new String[26]; if(words.length != pattern.length()){ return false; } for(int i = 0; i &lt; pattern.length(); i++){ if( alphabet[pattern.charAt(i) - 'a'] != null){ if(!alphabet[pattern.charAt(i) - 'a'].equals(words[i])){ return false; } } else{ alphabet[pattern.charAt(i) - 'a'] = words[i]; } } for(int i = 0; i &lt; alphabet.length; i++){ for(int j = i+1; j &lt; alphabet.length; j++){ if(alphabet[i] == null || alphabet[j] == null){ continue; } if(alphabet[i].equals(alphabet[j])){ return false; } } } return true; }}","link":"/2022/04/21/290-Word-Pattern/"},{"title":"297. Serialize and Deserialize Binary Tree","text":"Question Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Solution编码过程编码时采用BFS搜索，将二叉树按层级组成字符串。当当前节点不等于null时，添加当前节点的值和一个符号。然后将其左右子节点加入队列。当当前节点为null时，添加一个非数字字符和一个符号。 解码过程解码时同样采用BFS搜索，按层级恢复二叉树。首先将字符串根据符号进行分割，变为字符串数组。如果第一个字符表示为null，返回null。 否则将第一个数字组成根节点并加入队列。创建一个指针i记录位置。当队列不为空，且指针i未越界时，根据指针i上的字符串创建当前节点的左子节点。将指针右移，如果没有越界则创建当前节点的右子节点，然后将指针右移。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */public class Codec { // Encodes a tree to a single string. public String serialize(TreeNode root) { StringBuilder data = new StringBuilder(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty()){ TreeNode curr = q.poll(); if(curr == null) data.append(&quot;n,&quot;); else { data.append(curr.val + &quot;,&quot;); q.add(curr.left); q.add(curr.right); } } return data.toString(); } // Decodes your encoded data to tree. public TreeNode deserialize(String data) { String[] values = data.split(&quot;,&quot;); if(values[0].equals(&quot;n&quot;)) return null; TreeNode root = new TreeNode(Integer.parseInt(values[0])); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); int i = 1; while(!q.isEmpty() &amp;&amp; i &lt; values.length){ TreeNode curr = q.poll(); curr.left = values[i].equals(&quot;n&quot;) ? null : new TreeNode(Integer.parseInt(values[i])); if(i++ &lt; values.length) curr.right = values[i].equals(&quot;n&quot;) ? null : new TreeNode(Integer.parseInt(values[i])); if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); i++; } return root; }}// Your Codec object will be instantiated and called as such:// Codec ser = new Codec();// Codec deser = new Codec();// TreeNode ans = deser.deserialize(ser.serialize(root));","link":"/2022/05/05/297-Serialize-and-Deserialize-Binary-Tree/"},{"title":"3. Longest Substring Without Repeating Characters","text":"Question Given a string s, find the length of the longest substring without repeating characters. Solution 1滑动窗口加数组统计。用一个数组bin[]记录各个字符的访问情况。（数组尺寸由字符串的总数决定） 当指针j第一次遍历到一个字符时，如果该字符对应的位置为0，则将其设置为1。否则对前面的i指针进行遍历，并将i经过的位置重新设置为0。如果i的字符与当前j字符相等，则将bin[index]设置为0，计算当前的长度j-i并更新最大值best。 Code1234567891011121314151617181920212223242526272829class Solution { public int lengthOfLongestSubstring(String s) { int best = 0, i = 0, j = 0; char[] word = s.toCharArray(); int[] bin = new int[128]; while(j &lt; s.length()){ int index = word[j] - ' '; if(bin[index] == 0){ bin[index] = 1; j++; } else{ while(i &lt; j){ int temp = word[i] - ' '; if(temp == index &amp;&amp; bin[index] == 1){ bin[index] = 0; best = Math.max(best, j - i); i++; break; } bin[temp] = 0; i++; } } best = Math.max(best, j - i); } return best; }} Solution 2滑动窗口，哈希表记录访问过的字符的元素。如果重复，则放弃前一个重复的字符，更新左指针。注意：只有在新指针大于现有指针时才更新！ Code1234567891011121314151617181920212223242526272829class Solution { public int lengthOfLongestSubstring(String s) { int best = 0; int i = 0; int j = 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); while ( j &lt; s.length() ){ char curChar = s.charAt(j); if ( !map.containsKey(curChar) ){ map.put( curChar, j ); } else{ if ( map.get(curChar) + 1 &gt; i){ i = map.get(curChar) + 1; } map.put( curChar, j ); } if ((j - i + 1) &gt; best){ best = (j - i + 1); } j++; } return best; }}","link":"/2022/04/07/3-Longest-Substring-Without-Repeating-Characters/"},{"title":"300. Longest Increasing Subsequence","text":"Question Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. Solution贪心算法创建一个数组记录达到升序的长度时升序数列的最小末尾值。如果想要增加数组的长度（即增加最大的升序数列长度），则新的数字必须要大于该数组最后一位的大小。因此在这种情况下，该数组必然是单调递增的。 二分搜索将第一个数字填入数组。然后遍历数组，当新一项大于数组的最后一个值时，最大长度加一，并将其加入数组的尾部。当新一项小于数组的最后一个值时，该数字需要与之前的数组组成新的升序数列。我们可以替换掉之前数组中比该数字大的第一个数字，代表新组成的数组。（最长数组之间的数字无所谓，只记录最小的末尾值即可。）我们可以用二分搜索查到该数字需要加入的index。然后替换掉数组中的数字。单次二分搜索的时间复杂度为O($logn$)。总的时间复杂度为O($nlogn$)。 Code123456789101112131415161718192021class Solution { public int lengthOfLIS(int[] nums) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int len = 1; ans.add(nums[0]); for(int i = 1; i &lt; nums.length; i++){ if(nums[i] &gt; ans.get(ans.size()-1)){ ans.add(nums[i]); len++; } else{ int index = Collections.binarySearch(ans, nums[i]); if(index &lt; 0){ ans.set(-(index+1), nums[i]); } } } return len; }} Solution 2动态规划，创建一个数组dp[]用来记录最大长度，创建max记录最大值。遍历，先将数组dp[]上的所有位置都填上1。从0到i-1遍历j。当nums[i] &gt; nums[j]时，更新dp[i]为dp[i]与dp[j]+1中的较大值。当更新dp[i]时将其和max比较，如果比max大则更新max。最后返回max值。时间复杂度为O($n_2$) Code123456789101112131415161718192021class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; int max = 1; for(int i = 0; i &lt; n; i++){ dp[i] = 1; for(int j = i-1; j &gt;= 0; j--){ if(nums[i] &gt; nums[j]){ dp[i] = Math.max(dp[i], dp[j]+1); if(max &lt; dp[i]){ max = dp[i]; break; } } } } return max; }}","link":"/2022/05/01/300-Longest-Increasing-Subsequence/"},{"title":"304. Range Sum Query 2D - Immutable","text":"Question Given a 2D matrix matrix, handle multiple queries of the following type: Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Implement the NumMatrix class: NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Solution前缀和/动态规划，用一个dp[][]数组记录到matrix[0][0]到matrix[i][j]区域的和。 计算两个点之间形成的总数只需用外侧的位置的前缀和加上内侧位置的前缀和，然后减去两者交换长宽位置的前缀和即可。 递推公式计算dp[][]数组时，需要将其上侧与左侧所有数字加和，并加上matrix[][]上该位置对应的元素。用dp[i][j-1] - dp[i-1][j-1]计算出左侧所有数字之和，dp[i-1][j]则是上侧所有数字之和。 Code1234567891011121314151617181920212223class NumMatrix { int[][] dp; public NumMatrix(int[][] matrix) { int m = matrix.length, n = matrix[0].length; dp = new int[m+1][n+1]; for(int i = 1; i &lt;= matrix.length; i++){ for(int j = 1; j &lt;= matrix[0].length; j++){ dp[i][j] = dp[i][j-1] - dp[i-1][j-1] + dp[i-1][j] + matrix[i-1][j-1]; } }; } public int sumRegion(int row1, int col1, int row2, int col2) { return dp[row1][col1] + dp[row2+1][col2+1] - dp[row1][col2+1] - dp[row2+1][col1]; }}/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */ Solution 2暴力搜索，直接计算从row1, col1到row2, col2的元素加和。 Code12345678910111213141516171819202122class NumMatrix { int[][] mat; public NumMatrix(int[][] matrix) { mat = matrix; } public int sumRegion(int row1, int col1, int row2, int col2) { int sum = 0; for(int i = row1; i &lt;= row2; i++){ for(int j = col1; j &lt;= col2; j++){ sum += mat[i][j]; } } return sum; }}/** * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); */","link":"/2022/06/03/304-Range-Sum-Query-2D-Immutable/"},{"title":"31. Next Permutation","text":"A permutation of an array of integers is an arrangement of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). For example, the next permutation of arr = [1,2,3] is [1,3,2].Similarly, the next permutation of arr = [2,3,1] is [3,1,2].While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.Given an array of integers nums, find the next permutation of nums. The replacement must be in place and use only constant extra memory. 从数组末尾开始遍历第i个元素。如果后一项小于前一项，则排序关系正确。反之则将i与遍历过的部分中比i大的第一个数字交换。然后对已遍历的部分排序。 1234567891011121314151617181920212223242526272829303132class Solution { public void nextPermutation(int[] nums) { int flag = 0; //标记，如果没有下一个排列时，排序数组。 if (nums.length != 1){ int i = nums.length -2; while (i &gt;= 0){ if (nums[i + 1] &lt;= nums[i]) { //从尾部开始，比较元素是否是大到小 i--; continue; } else { //排序关系不正确时 for (int j = nums.length-1;j&gt;i;j--){ if (nums[j] &lt;= nums[i]){ continue; } int temp = nums[j]; //将i元素和遍历过的元素中第一个比nums[i]大的交换。 nums[j] = nums[i]; nums[i] = temp; Arrays.sort(nums,i+1,nums.length); //排序i之后的数组。 flag = 1; break; } break; } } if (flag == 0 ){ //如果全部从大到小，则排序整个数组。 Arrays.sort(nums); } } }}","link":"/2022/04/04/31-Next-Permutation/"},{"title":"318. Maximum Product of Word Lengths","text":"Question Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0. Solution正常的思路可能是用哈希表保存字符串中出现过的字符。此时表的大小是26也是一个常数。 我们可以采用位运算进行状态压缩，通过一个整数的二进制位保存二十六个字符的存在状态。 状态压缩我们采用一个整数数组bin[]储存状态压缩后的整数。 遍历每个字符串，在字符串中遍历每一个字符。初始化整数bit为0。在遍历字符时计算当前字符与字符’a’距离的差n，然后将1左移n位，填入（或运算）整数bit中。 比较遍历words[]中的两个字符串，当bin[i]与bin[j]进行与运算结果为0时，则两个字符串没有共同字符。此时更新二者长度乘积的最大值max。 最后返回max即可。 时间复杂度：O(L + n2)。L为所有字符的总长度。 Code12345678910111213141516171819202122class Solution { public int maxProduct(String[] words) { int max = 0; int bin[] = new int[words.length]; for(int i = 0; i &lt; words.length; i++){ int bit = 0; for(int j = 0; j &lt; words[i].length(); j++){ bit |= (1 &lt;&lt; (words[i].charAt(j) - 'a')); } bin[i] = bit; } for(int i = 0; i &lt; words.length; i++){ for(int j = i+1; j &lt; words.length; j++){ if((bin[i] &amp; bin[j]) == 0) max = Math.max(max, words[i].length() * words[j].length()); } } return max; }}","link":"/2022/05/29/318-Maximum-Product-of-Word-Lengths/"},{"title":"32. Longest Valid Parentheses","text":"Question Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Solution如果有右括号先出现于左括号，则其永远无法配对。而如果是左括号先出现，则其有可能可以和之后的右括号进行配对。 因此我们可以将左括号的位置入栈，等待配对。并记录上一个不能配对的右括号的位置。以此来确定当前位置的有效括号长度。 首先将上一个不能组队的右括号lastRightParenthese初始化为-1。初始化一个最大有效长度best。 然后遍历字符串： 当遇到左括号时： 将当前下标i压入栈。（记录等待配对的左括号） 遇到右括号时： 如果栈为空，则更新上一个不能组队的右括号的位置为当前下标i。（此时出现的右括号一定无法配对） 如果栈不为空，则挤出上一个左括号的下标，与右括号配对。 挤出上一个左括号后，如果栈为空。则将当前的有效括号总长度为i - lastRightParenthese。（当前的右括号和上一个不能配对的右括号的差） 否则当前的有效括号总长度为i - stack.peek()。（当前的右括号和上一个不配对的左括号的差。） Code123456789101112131415161718192021222324252627class Solution { public int longestValidParentheses(String s) { Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); int best = 0; int lastRightParenthese = -1; //上一个不能配对的右括号位置，初始化为-1 for(int i = 0; i &lt; s.length(); i++){ if(s.charAt(i) == '('){ //如果当前位置是左括号，则将下标入栈 stack.push(i); } else{ //如果当前位置是右括号... if(stack.isEmpty()){ //如果没有可以配对的左括号，则更新不能配对的右括号的位置 lastRightParenthese = i; } else{ stack.pop(); //如果有可以配对的右括号，则从栈中挤出 if(stack.isEmpty()){ //挤出后如果没有剩余的左括号了，则当前有效括号长度为当前位置减去上一个无法配对的右括号的位置 best = Math.max(best, i - lastRightParenthese); } else{ //如果挤出后栈内仍有剩余的左括号存在，则当前有效括号长度为当前位置减去栈顶的左括号的位置 best = Math.max(best, i - stack.peek()); } } } } return best; }}","link":"/2022/05/24/32-Longest-Valid-Parentheses/"},{"title":"322. Coin Change","text":"Question You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. Solution动态规划，首先将amount长度的数组填满最大值。双重遍历数组和硬币，不取当前硬币的上一个状态加一（dp[i - coin]+1）就是当前可取的最小值。注意先取硬币，将amount的起始值设置为硬币面值可以增快速度。（减少了面值大于总额的情况。） Code123456789101112131415class Solution { public int coinChange(int[] coins, int amount) { if(amount == 0) return 0; int dp[] = new int[amount+1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for(int coin : coins){ for(int i = coin; i &lt;= amount; i++){ if(dp[i-coin] != Integer.MAX_VALUE) dp[i] = Math.min(dp[i],dp[i - coin]+1); } } return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount]; }}","link":"/2022/05/03/322-Coin-Change/"},{"title":"326. Power of Three","text":"Question Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3&lt;sup&gt;x&lt;/sup&gt;. Solution与isPowerOfFour相同，如果n小于0则返回false。如果n等于1则返回true。递归，如果n可以整除3，则返回isPowerOfThree(n / 3)。否则返回false。 Code12345678class Solution { public boolean isPowerOfThree(int n) { if(n &lt;= 0) return false; if(n == 1) return true; if(n % 3 == 0) return isPowerOfThree(n / 3); else return false; }}","link":"/2022/08/23/326-Power-of-Three/"},{"title":"329. Longest Increasing Path in a Matrix","text":"Question Given an m x n integers matrix, return *the length of the longest increasing path in *matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed). Solution第一次就通过DFS和DP的知识自己摸索出了记忆化搜索，非常开心！: ) 记忆化搜索，采用DFS搜索，并动态规划的思想保存搜索结果。 递归计算从x, y点出发的最大长度，并在递归中记录子位置的最大长度。通过子位置的最大长度对递归树进行剪枝。 记忆化搜索初始化一个memo[][]数组，记录已经搜索过的x, y位置的最大长度。对所有下一个位置进行DFS搜索，如果越界或不满足递增规律，则返回最大长度1。（这里应该返回0，但是为了下一步的记忆化搜索判断的遍历因此返回1。如果返回0的话则后面返回最大值不需要-1，但此时由于会重复搜索因此速度会降低。） 如果x, y的位置已经搜索过了（即memo[x][y] != 0），则直接返回memo[x][y]的值+1。 搜索完所有位置的最大长度，将其中的最大值保存在memo[][]中。最后返回最大值+1。 将每个位置遍历，返回memo[][]中的最大值。 Code1234567891011121314151617181920212223242526272829303132class Solution { int[][] mat, memo, moves = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int m, n, max; public int longestIncreasingPath(int[][] matrix) { mat = matrix; m = matrix.length; n = matrix[0].length; memo = new int[m][n]; max = 0; for(int x = 0; x &lt; m; x++){ for(int y = 0; y &lt; n; y++){ dfs(x, y, -1); max = Math.max(max, memo[x][y]); } } return max; } private int dfs(int x, int y, int parent){ if(x &lt; 0 || y &lt; 0 || x &gt;= m || y &gt;= n || parent &gt;= mat[x][y]) return 1; if(memo[x][y] != 0) return memo[x][y] + 1; int best = 0; for(int[] move : moves){ int count = dfs(x + move[0], y + move[1], mat[x][y]); best = Math.max(best, count); } memo[x][y] = best; return best + 1; }}","link":"/2022/05/19/329-Longest-Increasing-Path-in-a-Matrix/"},{"title":"33. Search in Rotated Sorted Array","text":"There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2]. Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. 二分搜索，二分后将会形成两个区间，一个区间是顺序的，另一个是无序的。如果target等于中间值则返回。分别处理两种情况下移动指针的方式。当顺序区间在左半边时：当target在顺序区间内，则更新右指针的位置。否则更新左指针位置。当顺序区间在右半边时：当target在顺序区间内，则更新左指针的位置。否则更新右指针位置。 123456789101112131415161718192021222324252627282930313233class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length-1; while(left &lt;= right){ int mid = (right - left) / 2 + left; if(nums[mid] == target){ return mid; } if( nums[mid] &gt;= nums[0] ){ if(target &gt;= nums[0] &amp;&amp; target &lt; nums[mid] ){ right = mid - 1; } else{ left = mid + 1; } } else{ if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[nums.length-1]){ left = mid + 1; } else{ right = mid -1; } } } return -1; }}","link":"/2022/04/17/33-Search-in-Rotated-Sorted-Array/"},{"title":"334. Increasing Triplet Subsequence","text":"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false. 贪心算法。将first与second初始化为最大值。first保存遍历过的最小值。second保存遍历过的大于之前最小值的最小值。 遍历数组。条件一：如果数字小于现在第一个值，则更新第一个值。（此时一定不满足条件二，因此可以安全地更新更小的数字。）条件二：如果数字大于第一个值，且小于第二个值，则更新第二个值。（此时第一个值已经被更新过了，满足第一个值小于第二个值。）条件三：如果数字大于第二个值，则返回true。（此时两个值一定都被更新过了，满足第一个值小于第二个值小于第三个值。） 注意：更新first后，second不会更新，但是second的存在可以确保曾经存在first小于second。如果此时数字大于second，则数组中存在Triplet Subsequence。 12345678910111213141516171819class Solution { public boolean increasingTriplet(int[] nums) { int first = Integer.MAX_VALUE; int second = Integer.MAX_VALUE; for(int num : nums){ if(num &lt; first){ first = num; } else if(num &gt; first &amp;&amp; num &lt; second){ second = num; } else if(num &gt; second){ return true; } } return false; }} 双向遍历，逐渐收紧搜索窗口。设置i，k两个指针分别在头尾。当nums[j] &lt;= nums[i]，则更新i指针为j。当nums[j] &gt;= nums[k]，则更新k指针为j。如果找到符合条件的nums[i] &lt; nums[j] &lt; nums[k]则返回。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public boolean increasingTriplet(int[] nums) { boolean flag = true; int i = 0; int k = nums.length -1 ; int j; int count = 1; while(i &lt; k &amp;&amp; i + count &lt; k){ if(flag){ j = i + count; if(nums[i] &gt;= nums[j]){ i = j; count = 1; flag = true; continue; } else if(nums[j] &lt; nums[k]){ return true; } flag = !flag; } else{ j = k - count; if(nums[k] &lt;= nums[j]){ k = j; count = 1; flag = true; continue; } else if(nums[j] &gt; nums[i]){ return true; } else{ count++; } flag = !flag; } } return false; }}","link":"/2022/04/20/334-Increasing-Triplet-Subsequence/"},{"title":"34. Find First and Last Position in Sorted Array","text":"问题Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. 二分搜索，搜索中间项。中间项等于左侧和右侧指针的中点，根据搜索左侧边界和右侧边界选择二分向下舍去或是二分向上补足。当中间项小于目标，则更新左侧边界。若中间项大于目标，则更新右侧边界。当中间项等于目标时，根据搜索左侧边界还是右侧边界选择更新左侧或右侧。由于有可能有重复元素存在，因此需要继续二分搜索下去，直到右侧边界大于左侧边界。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { public int[] searchRange(int[] nums, int target) { return new int[]{searchLeft(nums,target),searchRight(nums,target)}; } private int searchRight(int[] nums, int target){ int left = 0; int right = nums.length-1; int mid = 0; int result = -1; while(left &lt;= right){ mid = (right-left)/2+left; if(nums[mid] &lt; target){ left = mid+1; } else if(nums[mid] &gt; target){ right = mid-1; } else{ result = mid; left = mid+1; } } return result; } private int searchLeft(int[] nums, int target){ int left = 0; int right = nums.length-1; int mid = 0; int result = -1; while(left &lt;= right){ mid = (right-left+1)/2+left; if(nums[mid] &lt; target){ left = mid+1; } else if(nums[mid] &gt; target){ right = mid-1; } else{ result = mid; right = mid-1; } } return result; }}","link":"/2022/04/16/34-Find-First-and-Last-Position-in-Sorted-Array/"},{"title":"34. Find the Element in Sorted Array","text":"Question Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. Solution二分搜索，首先搜索target。如果搜索到结果为负数，则返回[-1, -1]。如果搜索到target，则记录index。然后从index向两边搜索，直到找到界限并返回。 Code12345678910111213141516171819class Solution { public int[] searchRange(int[] nums, int target) { int[] ret = new int[2]; int index = 0; index = Arrays.binarySearch(nums, target); if(index &lt; 0){ ret[0] = -1; ret[1] = -1; return ret; } int less = index, more = index; while(less &gt;= 0 &amp;&amp; nums[less] == target) less--; while(more &lt; nums.length &amp;&amp; nums[more] == target) more++; ret[0] = less + 1; ret[1] = more - 1; return ret; }}","link":"/2022/07/24/34-Find-the-Element-in-Sorted-Array/"},{"title":"342. Power of Four","text":"Question Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4&lt;sup&gt;x&lt;/sup&gt;. Solution递归，如果n小于等于零则返回false。如果n等于1则返回true。 如果n可以除以4，则递归返回n/4。 Code123456789class Solution { public boolean isPowerOfFour(int n) { if(n &lt;= 0) return false; if(n == 1) return true; if(n % 4 == 0) return isPowerOfFour(n / 4); else return false; }}","link":"/2022/08/22/342-Power-of-Four/"},{"title":"343. Integer Break","text":"Question Given an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers. Return the maximum product you can get. Solution动态规划，用数组dp[]记录最大乘积。在n &lt; 4之前为特例，由于必须拆分，因此乘积小于自身。但由于之后的数字要用到拆分的特性，因此这三个数字要特殊设置为自身。在此之后，每个数字可以拆分成两个数的加和，然后乘积等于对应两个数的乘积。（dp[4]可以不设置计算得出，但是指定值的话可以加快速度。） Code1234567891011121314151617181920class Solution { public int integerBreak(int n) { if(n &lt;= 1) return 0; if(n == 2) return 1; if(n == 3) return 2; int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; dp[3] = 3; dp[4] = 4; for(int i = 4; i &lt;= n; i++){ for(int j = 1; j &lt;= (i/2)+1; j++){ int k = i - j; dp[i] = Math.max(dp[i], dp[j] * dp[k]); } } return dp[n]; }} Solution 2数学方法，当两数之和大于4时，拆分成两个更小的加和可以得到更大的乘积。而当等于4时，可以拆分为两个2相乘。因此，最终有意义的拆分结果只会有2和3。 拆分规则： 最优： 3 。把数字 n 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。 次优： 2 。若余数为 2 ；则保留，不再拆为 1+1 。 最差： 1 。若余数为 1 ；则应把一份 3+1 替换为 2 + 22+2，因为 2 * 2 &gt; 3 * 1 Code123456789101112131415161718class Solution { public int integerBreak(int n) { if (n &lt;= 3) { return n - 1; } int quotient = n / 3; int remainder = n % 3; if (remainder == 0) { return (int) Math.pow(3, quotient); } else if (remainder == 1) { return (int) Math.pow(3, quotient - 1) * 4; } else { return (int) Math.pow(3, quotient) * 2; } }} Solution 3同样，我们可以将之前的结论用在动态规划上，j只取2或3，将时间复杂度从O(n^2)降低到O(n)。 Code1234567891011121314151617181920class Solution { public int integerBreak(int n) { if(n &lt;= 1) return 0; if(n == 2) return 1; if(n == 3) return 2; int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; dp[3] = 3; dp[4] = 4; for(int i = 4; i &lt;= n; i++){ for(int j = 2; j &lt;= 3; j++){ int k = i - j; dp[i] = Math.max(dp[i], dp[j] * dp[k]); } } return dp[n]; }}","link":"/2022/05/04/343-Integer-Break/"},{"title":"341. Flatten Nested List Iterator","text":"Question You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: NestedIterator(List&lt;NestedInteger&gt; nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. Your code will be tested with the following pseudocode: initialize iterator with nestedListres = []while iterator.hasNext()append iterator.next() to the end of resreturn res If res matches the expected flattened list, then your code will be judged as correct. Solution将所有的NestedInteger展开后加入全局变量队列。 辅助方法buildQueue():递归，如果当前元素是列表，则向下递归列表内的所有元素。如果当前元素是单个整数，则将其加入队列。 next():返回并挤出队列中的下一个元素，返回其整数。 hasNext():返回队列是否为空。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger { * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return empty list if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * } */public class NestedIterator implements Iterator&lt;Integer&gt; { Queue&lt;NestedInteger&gt; q; public NestedIterator(List&lt;NestedInteger&gt; nestedList) { q = new LinkedList&lt;&gt;(); for(NestedInteger item : nestedList){ buildQueue(item); } } private void buildQueue(NestedInteger ni){ if(!ni.isInteger()){ for(NestedInteger item : ni.getList()){ buildQueue(item); } } else{ q.offer(ni); } } @Override public Integer next() { return q.poll().getInteger(); } @Override public boolean hasNext() { return !q.isEmpty(); }}/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */","link":"/2022/05/08/341-Flatten-Nested-List-Iterator/"},{"title":"344. Reverse String","text":"问题简述Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. 双指针，同时更新并交换两个数值。 12345678910111213141516class Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; while( i &lt; j ) { char temp = s[i]; s[i] = s[j]; s[j] = temp; i++; j--; } }}","link":"/2022/04/05/344-Reverse-String/"},{"title":"350. Intersection of Two Arrays II","text":"问题描述Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 遍历一个数组，将所有元素添加到哈希表中。遍历第二个数组，如果在哈希表中则添加到数组中。 123456789101112131415161718192021222324252627282930313233class Solution { public int[] intersect(int[] nums1, int[] nums2) { HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); int count = 0; for ( int i = 0 ; i &lt; nums1.length ; i++ ){ if (!map.containsKey(nums1[i])){ map.put(nums1[i],1); } else{ map.put(nums1[i],map.get(nums1[i])+1); } } for ( int i = 0 ; i &lt; nums2.length ; i++ ){ if (map.containsKey(nums2[i])){ if (map.get(nums2[i]) &gt; 0){ count++; arr.add(nums2[i]); map.put(nums2[i],map.get(nums2[i])-1); } } } int[] ans = new int[count]; for (int i = 0 ; i &lt; arr.size() ; i++){ ans[i] = arr.get(i); } return ans; }}","link":"/2022/04/04/350-Intersection-of-Two-Arrays-II/"},{"title":"363. Max Sum of Rectangle No Larger Than K","text":"Question Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k. It is guaranteed that there will be a rectangle with a sum no larger than k. Solution前缀和，计算矩阵中每个位置对应的方形的和。遍历方形的两个对角线上的点。其面积等于大块加小块的面积减去两个长方形的面积。如果面积有小于k的，则记录其最大值并返回。 Code1234567891011121314151617181920212223242526class Solution { public int maxSumSubmatrix(int[][] matrix, int k) { int x = matrix.length, y = matrix[0].length, max = Integer.MIN_VALUE; int[][] sum = new int[x+1][y+1]; for(int i = 1; i &lt;= x; i++){ int total = 0; for(int j = 1; j &lt;= y; j++){ total += matrix[i-1][j-1]; sum[i][j] = sum[i-1][j] + total; } } for(int i = 0; i &lt;= x; i++){ for(int j = 0; j &lt;= y; j++){ for(int m = i + 1; m &lt;= x; m++){ for(int n = j + 1; n &lt;= y; n++){ int area = sum[m][n] + sum[i][j] - sum[m][j] - sum[i][n]; if(area &lt;= k) max = Math.max(max, area); } } } } return max; }}","link":"/2022/08/27/363-Max-Sum-of-Rectangle-No-Larger-Than-K/"},{"title":"347. Top K Frequent Elements","text":"Question Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Solution遍历，使用哈希表保存遍历次数。再次遍历，根据元素出现的次数将其填入优先级队列实现的大根堆。遍历取出k个最大值。 getOrDefault()：方便的遍历并生成哈希表。 lambda：（）内表示传入的数值。-&gt; 后表示返回值。 Code1234567891011121314151617class Solution { public int[] topKFrequent(int[] nums, int k) { int[] ans = new int[k]; HashMap&lt;Integer,Integer&gt; map = new HashMap(); for (int num : nums){ map.put( num, map.getOrDefault(num , 0) + 1 ); } PriorityQueue&lt;Integer&gt; pq = new PriorityQueue((a,b) -&gt; map.get(b) - map.get(a)); for (int key : map.keySet()){ pq.add(key); } for (int i = 0; i &lt; k ; i++){ ans[i] = pq.poll(); } return ans; }}","link":"/2022/04/10/347-Top-K-Frequent-Elements/"},{"title":"36. Valid Sudoku","text":"问题Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. 遍历并创建三组不同的哈希表，每个表内包含一组哈希集合。如果访问的元素已在哈希集合内，则返回false 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public boolean isValidSudoku(char[][] board) { HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; rowMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; colMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); HashMap&lt;Integer,HashSet&lt;Character&gt;&gt; blockMap = new HashMap&lt;Integer,HashSet&lt;Character&gt;&gt;(); for (int i = 0; i &lt; board[0].length; i++ ){ for (int j = 0; j &lt; board.length; j++ ){ char curChar = board[i][j]; if (curChar == '.'){ continue; } if (!rowMap.containsKey(i)){ rowMap.put(i, new HashSet&lt;Character&gt;()); } if (!colMap.containsKey(j)){ colMap.put(j, new HashSet&lt;Character&gt;()); } if (!blockMap.containsKey(j/3*3+i/3)){ blockMap.put(j/3*3+i/3, new HashSet&lt;Character&gt;()); } HashSet&lt;Character&gt; curRow = rowMap.get(i); HashSet&lt;Character&gt; curCol = colMap.get(j); HashSet&lt;Character&gt; curBlock = blockMap.get(j/3*3+i/3); if ( !curRow.contains(curChar) &amp;&amp; !curCol.contains(curChar) &amp;&amp; !curBlock.contains(curChar) ){ curRow.add(curChar); curCol.add(curChar); curBlock.add(curChar); } else{ return false; } } } return true; }}","link":"/2022/04/07/36-Valid-Sudoku/"},{"title":"383. Ransom Note","text":"Question Given two strings ransomNote and magazine, return true* if ransomNote can be constructed by using the letters from magazine and false otherwise*. Each letter in magazine can only be used once in ransomNote. Solution数组统计，统计magazine内的字符。遍历ransomNote，如果对字符数组位置为0则返回false。每次遍历减少数组统计结果。 最后返回true。 Code12345678910111213class Solution { public boolean canConstruct(String ransomNote, String magazine) { char[] bin = new char[26]; for(char c : magazine.toCharArray()) bin[c-'a']++; for(char c : ransomNote.toCharArray()){ if(bin[c-'a'] == 0) return false; bin[c-'a']--; } return true; }}","link":"/2022/08/25/383-Ransom-Note/"},{"title":"377. Combination Sum IV","text":"Question Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target. The test cases are generated so that the answer can fit in a 32-bit integer. Solution记忆化搜索，memo[]数组用来记录达到某个总和时的可行方案数量。辅助方法count记录累计的总和memo[total]。 递归DFS，记忆化剪枝，如果memo[]数组不为空，则直接返回记忆内容。当total等于target时，该组合成立，返回1。 遍历nums[]数组中的每个元素，并将总组合数相加记录到memo[total]中。最后返回总组合数memo[total]。 *非常奇怪的是，当我使用int[]数组进行记忆化搜索时部分case会超时，推测是因为我判断int[]数组是否被记录是通过是否等于0而非是否为空导致的。 Code12345678910111213141516171819202122class Solution { int[] numbers; Integer[] memo; public int combinationSum4(int[] nums, int target) { numbers = nums; memo = new Integer[target+1]; return count(0, target); } private int count(int total, int target){ if(memo[total] != null) return memo[total]; if(total == target) return 1; int sum = 0; for(int i = 0; i &lt; numbers.length; i++){ if(total + numbers[i] &lt;= target) sum += count(total + numbers[i], target); } memo[total] = sum; return memo[total]; }}","link":"/2022/08/05/377-Combination-Sum-IV/"},{"title":"384. Shuffle an Array","text":"Question Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling. Implement the Solution class: Solution(int[] nums) Initializes the object with the integer array nums. int[] reset() Resets the array to its original configuration and returns it. int[] shuffle() Returns a random shuffling of the array. SolutionFisher-Yates洗牌算法。将数组分为两组部分，一组为已打乱的部分，一组为未打乱的部分。每次从未打乱部分中取一个元素，随机和一个未打乱部分的元素（包括自身）交换，则该位置变为已打乱的部分。 Code12345678910111213141516171819202122232425262728293031323334353637class Solution { int[] data; int[] shuffle; Random r; public Solution(int[] nums) { data = nums; shuffle = new int[nums.length]; r = new Random(); for(int i = 0; i &lt; data.length; i++){ shuffle[i] = nums[i]; } } public int[] reset() { return data; } public int[] shuffle() { for(int i = data.length-1 ; i &gt;= 0; i--){ swap(i, r.nextInt(i+1)); } return shuffle; } private void swap(int i, int j){ int temp = shuffle[i]; shuffle[i] = shuffle[j]; shuffle[j] = temp; }}/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int[] param_1 = obj.reset(); * int[] param_2 = obj.shuffle(); */ Solution 2将静态数组转换为动态数组，每次随机取动态数组里的一个index。将其按顺序填入result数组，并删除动态数组这个位置。最后返回result。 Code12345678910111213141516171819202122232425262728293031323334class Solution { int[] data; Random r; public Solution(int[] nums) { data = nums; r = new Random(); } public int[] reset() { return data; } public int[] shuffle() { ArrayList&lt;Integer&gt; bin = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; data.length; i++){ bin.add(data[i]); } int[] ret = new int[data.length]; for(int i = 0 ; i &lt; data.length; i++){ int random = r.nextInt(bin.size()); ret[i] = bin.get(random); bin.remove(random); } return ret; }}/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int[] param_1 = obj.reset(); * int[] param_2 = obj.shuffle(); */","link":"/2022/05/05/384-Shuffle-an-Array/"},{"title":"387. First Unique Character in a String","text":"Problems Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. Solution遍历，数组统计记录出现次数。如果数组未记录过，则将其index添加进列表中保存。 遍历列表，如果数组统计结果为1，则返回对应的index。否则返回-1。 Code 11234567891011121314151617class Solution { public int firstUniqChar(String s) { List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); int[] bin = new int[26]; for(int i = 0; i &lt; s.length(); i++){ if(bin[s.charAt(i) - 'a'] == 0) arr.add(i); bin[s.charAt(i) - 'a']++; } for(int i = 0; i &lt; arr.size(); i++){ if(bin[s.charAt(arr.get(i)) - 'a'] == 1) return arr.get(i); } return -1; }} Solution遍历，建立哈希表，记录出现次数。再次遍历，如果出现次数为1，则返回下标。 Code 212345678910111213141516171819202122class Solution { public int firstUniqChar(String s) { HashMap&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;(); for ( int i = 0; i &lt; s.length(); i++ ){ char curChar = s.charAt(i); if ( !map.containsKey(curChar) ){ map.put(curChar, 1); } else{ map.put(curChar, map.get(curChar)+1); } } for ( int i = 0; i &lt; s.length(); i++ ){ char curChar = s.charAt(i); if ( map.get(curChar) == 1 ){ return i; } } return -1; }}","link":"/2022/04/06/387-First-Unique-Character-in-a-String/"},{"title":"39. Combination Sum","text":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input. 回溯，记录当前加和。遍历所有数组元素，当sum大于target时返回，等于target时加入数组并返回。每次遍历并回溯元素时只递归当前元素和其之后的元素。（防止重复。） 12345678910111213141516171819202122232425class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); backtracking(candidates, ret, new ArrayList&lt;&gt;(), target, 0, 0); return ret; } private void backtracking(int[] candidates, List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int target, int sum, int level){ if(sum &gt; target ){ return; } else if (sum == target){ ret.add(new ArrayList&lt;&gt;(arr)); return; } for(int i = level; i &lt; candidates.length; i++){ arr.add(candidates[i]); sum+= candidates[i]; backtracking(candidates, ret, arr, target, sum, i); sum-= candidates[i]; arr.remove(arr.size()-1); } }}","link":"/2022/04/25/39-Combination-Sum/"},{"title":"393. UTF-8 Validation","text":"Question Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters). A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character, the first n bits are all one’s, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10. x denotes a bit in the binary form of a byte that may be either 0 or 1. **Note: **The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data. Solution位运算，循环更新UTF头部的位置start。getByte()方法用来计算位数。check()方法用来检查从start+1开始直到位数结束是否二进制位数以10开头。isStartWith10()方法使用掩码判断二进制是否以10开头。 Code123456789101112131415161718192021222324252627282930313233343536class Solution { int[] dt; final int MASK = 0b11000000; public boolean validUtf8(int[] data) { dt = data; int start = 0; while(start &lt; data.length){ int bit = getByte(start); if(bit == -1 || start + bit &gt; data.length) return false; if(!check(start, bit)) return false; start += bit; } return true; } private int getByte(int start){ int bit = 5; for(int i = 0; i &lt; 8; i++){ if((dt[start] &amp; 1) == 0) bit = 7 - i; dt[start] &gt;&gt;= 1; } if(bit == 0) return 1; else if(bit == 1 || bit &gt; 4) return -1; else return bit; } private boolean check(int start, int bit){ for(int i = start + 1; i &lt; start + bit; i++) if(!isStartWith10(dt[i])) return false; return true; } private boolean isStartWith10(int num){ return (num &amp; MASK) == 0b10000000; }}","link":"/2022/09/14/393-UTF-8-Validation/"},{"title":"399. Evaluate Division","text":"You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?. Return the answers to all queries. If a single answer cannot be determined, return -1.0. Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction. 这道题的核心是边上带权的并查集。如何在find以及union时计算并更新权重是最重要的。组合过后，根节点的权重依然为1，以其为标准更新其他节点的权重。 先通过一个哈希表建立字符串与id的映射关系，为每个字符串生成一个单独的id。 然后将一个equation里的两个字符串进行union操作。并查集初始化时，所有权重为1。 在find时，执行路径压缩时需要用当前的权重weight[id]更新为其自身乘以其上一级的权重weight[origin]。这里需要注意计算的顺序需要从根上的权重，以递归的形式计算到当前权重。因此我们需要先单独保存parents[id]的位置。然后find(parents[id])，先计算出其上级的weight。最后再将weight[id]更新为更新后的上一级的权重乘以自身权重。 123int origin = parents[id];parents[id] = find(parents[id]);weight[id] *= weight[origin]; 在union时，将两个集合中的一个的根指向另一个。例如当结合a与b两个节点时，我们已经计算过了(a -&gt; b)的权重关系，以及(d -&gt; c)的权重关系。我们将(b -&gt; d)。这时我们可以通过values[i]得到(a -&gt; d)的权重关系。因此我们可以据此得出以下公式： weight[(b-&gt;c)] = weight[(d-&gt;c)] × values[(a-&gt;d)]/weight[(a-&gt;b)] 12parents[p1] = parents[p2];weight[p1] = weight[id2]*val/weight[id1]; 最后，当所有节点都被合并后，我们可以遍历queries。从哈希表获得对应字符串的id。当有字符串未在哈希表中时，返回-1.0。否则计算两个id对应的权重，并添加到答案中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution { public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) { double[] ret = new double[queries.size()]; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); UnionFind uf = new UnionFind(equations.size() * 2); int id = 0; for(int i = 0; i &lt; equations.size(); i++){ String var1 = equations.get(i).get(0); String var2 = equations.get(i).get(1); if( !map.containsKey( var1 ) ){ map.put( var1, id ); id++; } if( !map.containsKey( var2 ) ){ map.put( var2, id ); id++; } uf.union(map.get(var1), map.get(var2), values[i]); } for(int i = 0 ; i &lt; queries.size(); i++){ String var1 = queries.get(i).get(0); String var2 = queries.get(i).get(1); Integer id1 = map.get(var1); Integer id2 = map.get(var2); if(id1 == null || id2 == null) ret[i] = -1.0; else ret[i] = uf.isConnected(id1, id2); } return ret; } class UnionFind{ int[] parents; double[] weight; public UnionFind(int n){ parents = new int[n]; weight = new double[n]; for(int i = 0; i &lt; parents.length; i++){ parents[i] = i; weight[i] = 1.0; } } public int find(int id){ if (id != parents[id]) { int origin = parents[id]; parents[id] = find(parents[id]); weight[id] *= weight[origin]; } return parents[id]; } public boolean union(int id1, int id2, double val){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return false; parents[p1] = parents[p2]; weight[p1] = weight[id2]*val/weight[id1]; return true; } public double isConnected(int id1, int id2){ int p1 = find(id1); int p2 = find(id2); if(p1 == p2) return weight[id1] / weight[id2]; else return -1.0; } }}","link":"/2022/05/01/399-Evaluate-Division/"},{"title":"40. Combination Sum II","text":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. 由于有重复性元素，因此先将数组排序。储存一个数组，记录元素是否被选择。回溯，遍历选择元素，并计算加和，并记录选择的元素。当选择的元素与上一个元素重复时，则跳过。 1234567891011121314151617181920212223242526272829class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(candidates); backtracking(candidates, ret, new ArrayList&lt;&gt;(), new int[candidates.length], target, 0, 0); return ret; } private void backtracking(int[] candidates, List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] visited, int target, int sum, int level){ if(sum &gt; target ){ return; } else if (sum == target){ ret.add(new ArrayList&lt;&gt;(arr)); return; } for(int i = level; i &lt; candidates.length; i++){ if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i-1] &amp;&amp; visited[i-1] == 0) continue; visited[i] = 1; arr.add(candidates[i]); sum+= candidates[i]; backtracking(candidates, ret, arr, visited, target, sum, i+1); visited[i] = 0; sum-= candidates[i]; arr.remove(arr.size()-1); } }}","link":"/2022/04/25/40-Combination-Sum-II/"},{"title":"409. Longest Palindrome","text":"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, “Aa” is not considered a palindrome here. 回文字符串除了中心一个元素，其他的字符必须成对出现。因此可以直接统计字符串里有几组成对的字符。 用数组记录字符出现的次数。如果数组中某个字符出现了两次，则可以将其归零。然后可以组成的最长回文数字加2。如果字符串还剩下其他字符未选择，则最长回文数可以加一。 1234567891011121314151617181920212223class Solution { public int longestPalindrome(String s) { int[] alphabet = new int['z' - 'A' + 1]; int count = 0; int total = s.length(); for(int i = 0; i &lt; s.length(); i++){ int index = s.charAt(i) - 'A'; alphabet[index]+=1; if( alphabet[index] == 2 ){ total -= 2; count += 2; alphabet[index] = 0; } } if(total != 0){ count++; } return count; }}","link":"/2022/04/21/409-Longest-Palindrome/"},{"title":"413. Arithmetic Slices","text":"An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.Given an integer array nums, return the number of arithmetic subarrays of nums. A subarray is a contiguous subsequence of the array. 动态规划，遍历一次记录所有数字的差。然后遍历并计算连续相同的数字数量temp。当不相同时，则计算temp长度可以选择的组合数，将其添加到count。 123456789101112131415161718192021222324252627282930class Solution { public int numberOfArithmeticSlices(int[] nums) { if(nums.length == 1) return 0; int[] difference = new int[nums.length-1]; for(int i = 0; i &lt; nums.length-1; i++){ difference[i] = nums[i+1] - nums[i]; } int count = 0; int temp = 1; int prev = difference[0]; for(int j = 1; j &lt; nums.length-1; j++){ if(difference[j] == prev){ temp++; } else{ count += combinations(temp); temp = 1; } prev = difference[j]; } count += combinations(temp); return count; } private int combinations(int n){ return (n * (n-1)) / 2; }}","link":"/2022/04/29/413-Arithmetic-Slices/"},{"title":"354. Russian Doll Envelopes","text":"Question You are given a 2D array of integers envelopes where envelopes[i] = [w&lt;sub&gt;i&lt;/sub&gt;, h&lt;sub&gt;i&lt;/sub&gt;] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope’s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope. Solution 1最长递增子数列这道题是LIS问题（Longest Increasing Subsequence） 的升级版。后一个数组中的两个元素应该同时严格大于前一个数组中的两个元素。因此我们需要维护一个宽度和高度同时严格单调递增的数列。 排序我们可以对数组以宽度进行比较排序。当二者的宽度相等时，以高度的倒序排序。（采用倒序排序是为了下面处理时排除不严格大于上一个数组的情况。） 递增数列我们可以维护一个递增动态数组arr，记录高度组成的单调递增数列。（LIS）首先将数组中的第一个元素的高度加入动态数组。然后遍历数组envelopes[]： 如果当前数组的高度height大于单调递增数列的最大值： 则当前的数组的宽度和高度均严格大于数组中最后一个高度对应的数组。 数组是优先以宽度的顺序排列，相等时以高度的倒序排列。由于相同宽度时高度大的在前，因此当当前高度大于之前的最大高度，则宽度也一定大于之前的最大宽度。 如果小于或者等于单调递增数列的最大值： 单调数列中高度的增长越平缓，我们在后面找到更多严格大于height的可能性就越大，因此可以用贪心思想，更新单调数列中的第一个大于当前高度的值。 由于单调递增数列是有序的，因此可以采用二分搜索来寻找第一个大于当前高度的值的下标，并将其更新为当前的height。 排序的时间复杂度为O(nlogn)，遍历数组的时间复杂度为O(n)，二分搜索的时间复杂度为O(logn)。总的时间复杂度为O(nlogn)。 Code1234567891011121314151617181920class Solution { public int maxEnvelopes(int[][] envelopes) { Arrays.sort(envelopes, (a,b) -&gt; a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]); List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); arr.add(envelopes[0][1]); for(int i = 1; i &lt; envelopes.length; i++){ int height = envelopes[i][1]; if(height &gt; arr.get(arr.size()-1)){ arr.add(height); } else{ int index = Collections.binarySearch(arr, height); if(index &lt; 0) index = -index-1; arr.set(index, height); } } return arr.size(); }} Solution 2注意这个方法在LeetCode中会超时，仅仅是记录一下思路，也可以采用动态规划的方法。记忆化搜索剪枝。记忆化搜索每个envelope。 memorazation()方法，返回当前的envelope中可以包含的最大数量。当数组memo[i]不等于0时，返回memo[i]。否则初始化最大值max为1。遍历数组中的所有元素，如果宽度于长度都大于envelopes[i]，则向下递归搜索该元素。比较并更新max和递归结果的返回值+1。最后将当前位置memo[i]设置为包含的最大数量max。 遍历所有元素时间复杂度O(n)。记忆化搜索元素的子项时间复杂度O(n)。时间复杂度为O(n2)。 Code1234567891011121314151617181920212223242526272829class Solution { int[][] dolls; int[] memo; public int maxEnvelopes(int[][] envelopes) { dolls = envelopes; memo = new int[dolls.length]; int res = 0; for(int i = 0; i &lt; dolls.length; i++){ if(memo[i] != 0) continue; memorazation(i); res = Math.max(res, memo[i]); } return res; } private int memorazation(int i){ if(memo[i] != 0){ return memo[i]; } int max = 1; for(int k = 0; k &lt; dolls.length; k++){ if(dolls[k][0] &lt; dolls[i][0] &amp;&amp; dolls[k][1] &lt; dolls[i][1]){ max = Math.max(max, memorazation(k) + 1); } } return memo[i] = max; }}","link":"/2022/05/25/354-Russian-Doll-Envelopes/"},{"title":"415. Add Strings","text":"Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. 按照正常加法计算方法即可。先将指针设置在两个String的末尾。每次计算位置上加和的结果。最后需要将字符串翻转过来。 1234567891011121314151617181920212223class Solution { public String addStrings(String num1, String num2) { int i = num1.length() - 1; int j = num2.length() - 1; int carry = 0; StringBuffer ans = new StringBuffer(); while( i &gt;= 0 || j &gt;= 0 || carry &gt; 0){ int x = i &gt;= 0 ? num1.charAt(i) - '0' : 0; int y = j &gt;= 0 ? num2.charAt(j) - '0' : 0; int result = x + y + carry; ans.append(result % 10); carry = result / 10; i--; j--; } ans.reverse(); return ans.toString(); }}","link":"/2022/04/21/415-Add-Strings/"},{"title":"42. Trapping Rain Water","text":"QuestionGiven n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining. Solution双指针，设置当前左侧的最大高度left和右侧的最大高度right。 分别从两侧遍历height[]数组，当出现更高的height时更新left和right。否则记录left和right与height[i]的差值，并记录在数组waterLeft[]和waterRight[]中。 遍历两个数组，添加两者中的最小值到volume。 *由于单个参数只记录了一侧的最大值，因此最大值另一侧的水的体积会被多计算，因此分别从两侧遍历来获得最小值。 Code12345678910111213141516171819202122class Solution { public int trap(int[] height) { int n = height.length, left = 0, right = 0, volume = 0; int[] waterLeft = new int[n], waterRight = new int[n]; for(int i = 0; i &lt; n; i++){ if(left &lt;= height[i]) left = height[i]; else waterLeft[i] = left - height[i]; } for(int i = n - 1; i &gt;= 0; i--){ if(right &lt;= height[i]) right = height[i]; else waterRight[i] = right - height[i]; } for(int i = 0; i &lt; n; i++){ volume += Math.min(waterLeft[i], waterRight[i]); } return volume; }}","link":"/2022/09/18/42-Trapping-Rain-Water/"},{"title":"429. N-ary Tree Level Order Traversal","text":"Question Given an n-ary tree, return the level order traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). SolutionBFS搜索，层序遍历。用level记录上一层的个数。当队列不为空时，每次挤出level个节点，并将其子节点加入队列。将当前层次的节点值加入列表。最后更新level的数量。 Code123456789101112131415161718192021222324252627282930313233343536373839404142/*// Definition for a Node.class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; }};*/class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); int level = 1; while(!q.isEmpty()){ List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; level; i++){ Node curr = q.poll(); for(Node child : curr.children){ q.offer(child); } arr.add(curr.val); } res.add(arr); level = q.size(); } return res; }}","link":"/2022/09/04/429-N-ary-Tree-Level-Order-Traversal/"},{"title":"438. Find All Anagrams in a String","text":"Given two strings s and p, return an array of all the start indices of p’s anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 滑动窗口。采用两个数组分别计算两个字符串中字符出现的数量。 滑动窗口时，维护数组中字符串中字符出现的次数。循环，判断两个字符串是否相等，如果相等，则将当前的左指针添加进答案。移动窗口的左右指针，在数组中减少前一项出现的次数，增加后一项出现的次数。 通过维护一个表示两个字符串中字符差值的数组，可以将算法优化算法，而不必进行两个数组的比较。 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { List&lt;Integer&gt; ans = new ArrayList(); if(p.length()&gt;s.length()){ return ans; } int[] alphabet = new int[26]; int[] window = new int[26]; for(int i = 0; i &lt; p.length(); i++){ alphabet[p.charAt(i) - 'a']++; window[s.charAt(i) - 'a']++; } int i = 0; int j = p.length(); while(j &lt; s.length()){ if(Arrays.equals(alphabet, window)){ ans.add(i); } window[s.charAt(i) - 'a']--; window[s.charAt(j) - 'a']++; i++; j++; } if(Arrays.equals(alphabet, window)){ ans.add(i); } return ans; }}","link":"/2022/04/20/438-Find-All-Anagrams-in-a-String/"},{"title":"45. Jump Game II","text":"Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. You can assume that you can always reach the last index. 设置一个当前可以访问的最大范围limit，在遍历中对其进行更新。和当前可访问位置中的最远距离end，每次访问到达end时，计算步数。 遍历数组，比较limit和当前i能访问的最远距离i+nums[i]，保留较大值。当i达到end时，更新end为之前记录的可访问最远距离limit。步数+1。 1234567891011121314151617class Solution { public int jump(int[] nums) { int count = 0; int limit = 0; int end = 0; for(int i = 0; i &lt; nums.length-1; i++){ limit = Math.max(limit, i + nums[i]); if(i == end){ end = limit; count++; } } return count; }}","link":"/2022/04/28/45-Jump-Game-II/"},{"title":"435. Non-overlapping Intervals","text":"Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. 首先对intervals按照后一项的大小进行排序。（直接将两数字相减作为比较值比Integer.compare方法更快。）贪心算法，将已取得的最大值max设置为最小整数值。遍历intervals，如果当前interval的左侧小于max，则不能选择该interval，计数加一。反之则可以选择interval，更新max的值为interval的最大值。返回总数。 12345678910111213141516class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a,b) -&gt; a[1] - b[1]); int max = Integer.MIN_VALUE; int count = 0; for(int[] interval : intervals){ if(interval[0] &lt; max){ count++; } else{ max = interval[1]; } } return count; }}","link":"/2022/04/19/435-Non-overlapping-Intervals/"},{"title":"43. Multiply Strings","text":"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Note: You must not use any built-in BigInteger library or convert the inputs to integer directly. 两个字符串的位数做乘法，每次计算进位。当前位等于自身加上计算结果的个位（由于有之前的进位存在。），下一位等于计算结果的十位。 123456789101112131415161718192021222324252627282930class Solution { public String multiply(String num1, String num2) { int m = num1.length(); int n = num2.length(); if( num1.equals(&quot;0&quot;) || num2.equals(&quot;0&quot;)){ return &quot;0&quot;; } int[] product = new int[m+n]; char[] arr1 = num1.toCharArray(); char[] arr2 = num2.toCharArray(); for(int i = m-1; i &gt;= 0; i--){ for(int j = n-1; j &gt;=0; j--){ int sum = product[i+j+1] + (arr1[i] - '0') * (arr2[j] - '0'); int curr = sum % 10; int carry = sum / 10; product[i+j] += carry; product[i+j+1] = curr; } } StringBuffer sb = new StringBuffer(); for(int k = 0; k &lt; m+n; k++ ){ if(k == 0 &amp;&amp; product[k] == 0 ) continue; sb.append(product[k]); } return sb.toString(); }}","link":"/2022/04/23/43-Multiply-Strings/"},{"title":"450. Delete Node in a BST","text":"Problem Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove. If the node is found, delete the node. Solution二叉搜索树（BST）的递增排序的访问顺序是中序遍历。（Left -&gt; Root -&gt; Right） 因此二叉搜索树的前驱者（小于当前节点的最大值）和继任者（大于当前节点的最小值）对于修改二叉树至关重要。 辅助方法getPredecessor() 和getSuccessor() 可以获得前驱者和继任者的值。分别为当前根节点的左子节点的最右子节点（二叉搜索树下的最大值）和当前根节点右子节点的最左子节点。（二叉搜索树下的最小值） deleteNode() 方法搜索key。如果当前值大于搜索值则搜索并修改其左子节点，反之搜索并修改右子节点。（由于要修改，因此向下递归子节点时需要将返回的结果传入该子节点。） 当搜索值等于当前值时，存在三种情况：1.该子节点存在右子节点。此时我们将当前值设置为继任者的值，然后递归搜索右子节点中继任者的值进行删除。2.该子节点存在左子节点。此时我们将当前值设置为前驱者的值，然后递归搜索左子节点中前驱者的值进行删除。3.该子节点是叶子节点。直接删除当前节点。 最后返回修改后的根节点即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null) return null; if(root.val &gt; key) root.left = deleteNode(root.left, key); //如果当前值大于搜索值则搜索左子节点，否则搜索右子节点 else if(root.val &lt; key) root.right = deleteNode(root.right, key); else{ //如果当前值等于搜索值，根据子节点情况删除节点 if(root.right != null){ //右子节点不为空则将当前root的值设置为继任者的值，然后向下递归删除继任者 root.val = getSuccessor(root); root.right = deleteNode(root.right, root.val); } else if(root.left != null){ //左子节点不为空则将当前root的值设置为前驱者的值，然后向下递归删除继任者 root.val = getPredecessor(root); root.left = deleteNode(root.left, root.val); } else{ root = null; } } return root; } private int getSuccessor(TreeNode root){ root = root.right; while(root.left != null){ root = root.left; } return root.val; } private int getPredecessor(TreeNode root){ root = root.left; while(root.right != null){ root = root.right; } return root.val; }}","link":"/2022/05/07/450-Delete-Node-in-a-BST/"},{"title":"451. Sort Characters By Frequency","text":"Question Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them. Solution哈希表记录字符出现的频率。然后将其添加到优先队列中。最后根据优先级队列的顺序，加入每个字符对应的哈希表中记录的字符数。理论上也可以用数组记录频率，但是问题中字符较复杂故未采用。 Code1234567891011121314151617181920class Solution { public String frequencySort(String s) { HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;((a,b) -&gt; map.get(b) - map.get(a)); StringBuffer sb = new StringBuffer(); for(char c : s.toCharArray()){ map.put(c, map.getOrDefault(c, 0)+1); } for(char c : map.keySet()){ pq.add(c); } while(!pq.isEmpty()){ char c = pq.poll(); for(int i = 0; i &lt; map.get(c); i++){ sb.append(c); } } return sb.toString(); }}","link":"/2022/05/05/451-Sort-Characters-By-Frequency/"},{"title":"456. 132 Pattern","text":"Question Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &lt; j &lt; k and nums[i] &lt; nums[k] &lt; nums[j]. Return true if there is a 132 pattern in nums, otherwise, return false. Solution单调栈，专门用于找某一个元素的左边/右边第一个比自己大/小的位置。递增单调栈会提出波峰，留下波谷。递减单调栈会剔除波谷，留下波峰。 我们需要找到同时满足j &lt; k和nums[k] &lt;[j]情况的位置。因此采用单调栈正合适。我们枚举132模式中的“3”，由于我们要找到波谷，因此可以采用递增栈。 递增单调栈的实现： 当遍历的当前值小于栈顶元素时，不满足递增规律，因此挤出栈顶。循环此操作直至当前栈顶于当前值满足递增规律或栈空。此时的当前值是nums[j]，而最后一个被挤出的值就是nums[k]。由于递增单调栈的性质，此时的nums[k] &lt; nums[j]且nums[k]大于被挤出的所有元素。 对于nums[i]，我们可以通过遍历nums[]数组，计算出其在i位置的最小值，并存在放minOfLeft[]中。 Code12345678910111213141516171819202122class Solution { public boolean find132pattern(int[] nums) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] minOfLeft = new int[nums.length]; minOfLeft[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++){ minOfLeft[i] = Math.min(minOfLeft[i-1], nums[i]); } for(int j = nums.length-1; j &gt;= 0; j--){ int k = Integer.MIN_VALUE; while(!stack.isEmpty() &amp;&amp; nums[j] &gt; stack.peek()){ k = stack.pop(); } if(minOfLeft[j] &lt; k){ return true; } stack.push(nums[j]); } return false; }}","link":"/2022/05/08/456-132-Pattern/"},{"title":"46. Permutations","text":"问题Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. 回溯，建立搜索树。每次遍历nums中的元素。如果未遍历过该元素，则向链表及set中添加。向下递归，链表长度达到nums的长度时返回。然后从set和链表中移除上一个值，回溯到上一个节点。 1234567891011121314151617181920212223242526class Solution { List&lt;List&lt;Integer&gt;&gt; ans; HashSet&lt;Integer&gt; set; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { ans = new ArrayList(); set = new HashSet(); backTrack(new LinkedList(), nums, nums.length, nums.length); return ans; } private void backTrack(LinkedList&lt;Integer&gt; list,int[] nums, int n, int k){ if(k == 0){ ans.add(new ArrayList(list)); return; } for(int i = 0; i &lt; n ; i++){ if(!set.contains(nums[i])){ list.add(nums[i]); set.add(nums[i]); backTrack(list, nums , n, k-1); set.remove(nums[i]); list.removeLast(); } } }}","link":"/2022/04/13/46-Permutations/"},{"title":"47. Permutations II","text":"Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. 首先排序，对于有重复数据的数组，排序可以方便剪枝。回溯，每次遍历数组内的元素。创建一个数组记录元素是否已被遍历。遍历时如果数组已经被记录，或者当前元素与数组中的上一个元素相等，且上一个数组未被选择，则跳过。（如果上一个同样的数字没被选择，则放弃这个排列。即在元素相同时，优先选择前面的元素进行排列） 123456789101112131415161718192021222324252627class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(nums); int[] visited = new int[nums.length]; backtracking(ret, new ArrayList&lt;&gt;(), visited , nums); return ret; } private void backtracking(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] visited, int[] nums){ if(arr.size() == nums.length){ ret.add(new LinkedList&lt;&gt;(arr)); return; } for(int i = 0; i &lt; nums.length; i++){ if(visited[i] == 1) continue; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; visited[i-1] == 0) continue; arr.add(nums[i]); visited[i] = 1; backtracking(ret, arr, visited, nums); visited[i] = 0; arr.remove(arr.size()-1); } }}","link":"/2022/04/25/47-Permutations-II/"},{"title":"474. Ones and Zeroes","text":"Question You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0‘s and n 1‘s in the subset. A set x is a subset of a set y if all elements of x are also elements of y. Solution 10-1背包问题的升级版。经典的背包问题只有一种容量，而这个问题实际等于有两种容量。 经典背包问题需要用二维数组动态规划，分别为物品和容量。而这道题需要用三维数组动态规划，分别为字符串，0的容量和1的容量。 我们采用一个三维数组dp[i][j][k]保存可取最多物品的数量。对于每个物品i，我们都可以取（数量+1）或不取（保持上一个物品的状态）。j和k相当于分别记录了取“0”的总数和“1”的总数 遍历三个维度，并计算字符串中0和1的个数。 如果当总容量大于当前物品中zeros和ones的数量，则可以取当前的物品。 如果取当前的物品，则dp[]数组的总数等于上一个物品的状态加一，即dp[i-1][j-zeros][k-ones]。 也可以不取当前的物品，则dp[]数组的总数直接保持上一个物品的状态。 如果当前背包总容量小于zeros和ones的数量，则不能取当前物品。 数组dp[]保持上一个物品的状态。 时间复杂度：O(lmn + L)，L是数组中所有字符串长度之和。空间复杂度：O(lmn)。 Code123456789101112131415161718192021class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][][] dp = new int[strs.length+1][m+1][n+1]; for(int i = 1; i &lt;= strs.length; i++){ int zeros = 0, ones = 0; for(char c : strs[i-1].toCharArray()){ if(c == '0') zeros++; else ones++; } for(int j = 0; j &lt;= m; j++){ for(int k = 0; k &lt;= n; k++){ if(j - zeros &gt;= 0 &amp;&amp; k - ones &gt;=0) dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones] + 1); else dp[i][j][k] = dp[i-1][j][k]; } } } return dp[strs.length][m][n]; }} Solution 2由于dp[i][][]的上一个状态只涉及到dp[i-1][][]，因此我们可以采用滚动数组，去掉数组的一个维度，压缩空间。此时需要从m到zeros，从n到ones倒序遍历，保证dp[i][][]转移过来的是dp[i-1][][]的元素。 此时的空间复杂度降低为O(mn)。 Code1234567891011121314151617181920class Solution { public int findMaxForm(String[] strs, int m, int n) { int[][] dp = new int[m+1][n+1]; for(String s : strs){ //记录每个位置对应的0和1数量 int zeros = 0, ones = 0; for(char c : s.toCharArray()){ if(c == '0') zeros++; else ones++; } for(int i = m; i &gt;= zeros; i--){ for(int j = n; j &gt;= ones; j--){ dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + 1); } } } return dp[m][n]; }} Solution 3递归+记忆化搜索，保存并返回每个位置的最大长度。如果位置越界则返回0。如果memo[i][zero][one]不为0，则返回memo[i][zero][one]。 如果当前字符串的“0”和“1”的个数大于剩余的“0”和“1”的个数，则可以取当前字符串，递归下一个位置并加一。也可以不取当前的字符串，递归下一个位置。当前位置memo[i][zero][one]等于两者中的最大值。 否则无法取当前字符串，直接递归下一个位置。当前位置等于0。 Code1234567891011121314151617181920212223242526272829303132333435class Solution { String[] s; int[] zeros, ones; int[][][] memo; public int findMaxForm(String[] strs, int m, int n) { s = strs; zeros = new int[strs.length]; ones = new int[strs.length]; memo = new int[strs.length][m+1][n+1]; for(int i = 0; i &lt; strs.length; i++){ //记录每个位置对应的0和1数量 for(int j = 0; j &lt; strs[i].length(); j++){ if(s[i].charAt(j) == '0') zeros[i]++; else ones[i]++; } } return dfs(0, m, n); } private int dfs(int i, int zero, int one){ if(i &gt;= s.length){ return 0; } if(memo[i][zero][one] != 0) return memo[i][zero][one]; int maxPossibleSubset = 0; if(zero-zeros[i] &gt;= 0 &amp;&amp; one-ones[i] &gt;= 0){ maxPossibleSubset = 1 + dfs(i+1, zero-zeros[i], one-ones[i]); } memo[i][zero][one] = Math.max(maxPossibleSubset, dfs(i+1, zero, one)); return memo[i][zero][one]; }}","link":"/2022/05/23/474-Ones-and-Zeroes/"},{"title":"473. Matchsticks to Square","text":"Question You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. Return true if you can make this square and false otherwise. Solution回溯，用int[] edges记录边长。 先计算所有火柴棍的长度之和是否能被4整除，如果不能则返回false。将所有火柴排序，以减少回溯时的计算量。 Backtracking 回溯当遍历越界时（传入index为-1），则返回true。 每次将当前火柴matchsticks[index]添加到一个edges[i]中。当edges[i] &lt;= sum / 4，且向前回溯前一个位置index-1返回结果为真，则返回true。然后将当前火柴从edges[i]中取出。 Code1234567891011121314151617181920212223class Solution { int[] edges; public boolean makesquare(int[] matchsticks) { int sum = 0; for(int i = 0; i &lt; matchsticks.length; i++) sum += matchsticks[i]; if(sum % 4 != 0) return false; edges = new int[4]; Arrays.sort(matchsticks); return backtracking(matchsticks, matchsticks.length-1, sum/4); } public boolean backtracking(int[] matchsticks, int index, int len){ if(index == -1) return true; for(int i = 0; i &lt; 4; i++){ edges[i] += matchsticks[index]; if(edges[i] &lt;= len &amp;&amp; backtracking(matchsticks, index - 1, len)) return true; edges[i] -= matchsticks[index]; } return false; }}","link":"/2022/07/13/473-Matchsticks-to-Square/"},{"title":"48. Rotate Image","text":"Question You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Solution 1此方法是in-place算法。 visited[][]数组记录访问情况，遍历所有位置，如果已访问则跳过。循环替换矩阵上的每一个位置，如果已经访问过则break。如果未访问则将要替换位置的值保存，并且在visited[][]数组上记录。然后继续遍历替换过的位置。 Code123456789101112131415161718192021222324class Solution { public void rotate(int[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] visited = new int[m][n]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(visited[i][j] == 1) continue; int x = i, y = j; int value = matrix[i][j]; while(true){ int s = n-1-x, t = y; if(visited[t][s] == 1) break; int temp = matrix[t][s]; matrix[t][s] = value; value = temp; visited[t][s] = 1; x = t; y = s; } } } }} Solution 2此方法类似Solution 1，但是并非原地算法。 Code123456789101112131415161718class Solution { public void rotate(int[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] mat = new int[m][n]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ int s = n-1-i, t = j; mat[t][s] = matrix[i][j]; } } for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ matrix[i][j] = mat[i][j]; } } }} Solution 3辅助方法getPixel计算旋转后的像素位置。旋转时候矩阵内的四个分区的像素会互相替换。因此需要将需要旋转的初始位置记录进入队列。旋转图像时根据getPixel方法计算出需要替换的位置。然后依次替换像素。 Code12345678910111213141516171819202122232425262728293031323334class Solution { public void rotate(int[][] matrix) { int n = matrix.length; Queue&lt;Integer&gt; queue = new LinkedList(); for (int p = 0; p &lt; n/2; p++){ for(int q = 0; q &lt; (n+1)/2; q++){ queue.offer(p * n + q); } } while(!queue.isEmpty()){ int i = queue.poll(); int INDEX = i; boolean flag = true; int temp = matrix[i/n][i%n]; while(i != INDEX || flag ){ flag = false; int j = getPixel(n, i); int swap = matrix[j / n][j % n]; matrix[j / n][j % n] = temp; temp = swap; i = j; } } } private int getPixel(int n, int o){ int row = o / n; int col = o % n; int newRow = col; int newCol = n - (row + 1); return (newRow * n) + newCol; }}","link":"/2022/04/18/48-Rotate-Image/"},{"title":"49. Group Anagrams","text":"Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. 利用JAVA中字符串会固定内存地址。（因此在进行字符串操作时是生成了新的对象。）遍历每个单词，记录26个字母出现的次数，并映射到字符数组上。将字符数组转换成字符串，生成一个新的字符串。 将字符串作为key放入map中，value储存原有单词。（字符串的内存地址固定，因此同样的字符串可以被搜索到。） 123456789101112131415161718192021class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { List&lt;List&lt;String&gt;&gt; ret = new ArrayList&lt;&gt;(); HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String word : strs){ char[] alphabet = new char[26]; for(int j = 0; j &lt; word.length(); j++){ alphabet[word.charAt(j)-'a']++; } String s = new String(alphabet); List&lt;String&gt; str = map.getOrDefault(s, new ArrayList&lt;String&gt;()); str.add(word); map.put(s, str); } for(String key : map.keySet()){ ret.add(map.get(key)); } return ret; }}","link":"/2022/04/23/49-Group-Anagrams/"},{"title":"5. Longest Palindromic Substring","text":"Question Given a string s, return the longest palindromic substring in s. Solution马拉车算法，专门用于计算最大回文子字符串长度。 预处理首先需要对字符串进行预处理，将每两个字符之间（包括两端）加上一个符号’#’。然后在字符串的前后加入任意两个不同的符号。（防止中心扩展时继续搜索） 这个操作使得偶数项的回文字符串变为奇数项的回文字符串，便于接下来进行统一的中心扩展操作。 Manacher算法参考资料：一文让你彻底明白马拉车算法 用一个数组p[]记录处理后字符串位置的中心展开长度。 初始化一个回文中心的下标位置i，和当前回文中心的右侧范围r。在进行算法时维护这两个参数。 遍历字符串中除了首尾两个字符以外的位置。 初始化i位置关于c的镜像位置m为2*c-i。由于回文字符串的对称特性，此时p[i]的中心拓展长度应等于p[m]。 有几种特例情况，p[i]不等于p[m]： 如果p[m] + m的和大于r，则以m为中心扩展的范围超过当前c的中心扩展范围的右界。此时p[i]无法保证等于p[m]。但是可以确保p[i]至少可以扩展到r，因此将p[i]更新为r-i。 如果i的位置等于r，则可扩展距离为0。 如果m的位置为原字符串的左边界，则此时将p[i]赋值为1是不正确的。因为p[m]的计算是遇到了边界停止的，而p[i]则没有遇到边界，接下来对i位置从i+p[i]与i-p[i]开始继续进行中心扩展即可。 中心扩展奇数项的回文字符串由中心扩展，只需要保证i+p[i]+1与i-p[i]-1（两个位置分别表示当前中心扩展的边缘再前进1）的字符相同，则可以继续向下扩展，将p[i]++。 c与r的更新由于要保证i在r的范围之内，当从i出发的中心扩展范围大于c的中心扩展范围r，需要更新c与r。 时间复杂度在进行扩展时，每次访问过的位置不会进入中心扩展算法。（比较从中心扩展的边缘开始，即i+p[i]+1与i-p[i]-1）因此总的时间复杂度为O(n)。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { int n; int[] p; String newString; public String longestPalindrome(String s) { n = s.length(); StringBuffer sb = new StringBuffer(); if(n == 0) { //对字符串进行处理 sb.append(&quot;^$&quot;); } else{ sb.append(&quot;^&quot;); for(int i = 0; i &lt; s.length(); i++){ sb.append('#'); sb.append(s.charAt(i)); } sb.append(&quot;#$&quot;); } p = new int[sb.length()]; newString = sb.toString(); manacher(); int c = 0; for(int i = 0; i &lt; sb.length(); i++){ if(p[i] &gt; p[c]) c = i; } return s.substring( (c-p[c])/2, (c-p[c])/2+p[c] ); } private void manacher(){ int c = 0, r = 0; for(int i = 1; i &lt; p.length - 1; i++){ int m = 2 * c - i; if(i &lt; r){ //当i在r的范围内时，p[i]的值与p[m]相等。 p[i] = Math.min(r-i, p[m]); //当p[m] + i超过了r时(当前中心拓展边界)，p[i]至少可以取值到r-i } else{ p[i] = 0; //当i等于r时，该位置拓展距离为0 } while (newString.charAt(i+p[i]+1) == newString.charAt(i-p[i]-1)) { //中心拓展算法，当两个位置相等时则可拓展距离+1 p[i]++; } if(i + p[i] &gt; r){ //当当前位置的右侧边界大于现有边界时，更新位置r c = i; r = i + p[i]; //新的右侧边界为新的中心+拓展长度p[i] } } }} Solution 2getLength方法，计算每一个字符位置的回文长度。（将left填成i+1，right填成i则可以搜索偶数回文的长度。）如果出现更长的回文，则根据返回的长度，和当前的i计算出字符串的范围。 Code12345678910111213141516171819202122232425262728class Solution { public String longestPalindrome(String s) { int best = 0; int left = 0; int right = 0; for(int i = 0; i &lt; s.length(); i++){ int length = Math.max(getLength(s,i,i), getLength(s,i+1,i)); if(best &lt; length){ left = i-((length-1)/2-1); right = i+(length/2); best = length; } } return s.substring(left,right); } private int getLength(String s, int left, int right){ while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; left &lt; s.length()){ if(s.charAt(left) == s.charAt(right)){ left--; right++; } else break; } return right - left + 1; }}","link":"/2022/04/24/5-Longest-Palindromic-Substring/"},{"title":"509. Fibonacci Number","text":"Question The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n). Solution 1记忆化搜索，在递归时递归过的n放入数组memo中记录。 Code1234567891011121314class Solution { int[] memo; public int fib(int n) { if(n == 0 || n == 1) return n; memo = new int[n+1]; return fibo(n); } private int fibo(int n){ if(n == 0 || n == 1) return n; if(memo[n] == 0) memo[n] = fibo(n-1) + fibo(n-2); return memo[n]; }} Solution 2递归，当n等于0或者1时返回固定值。否则返回fib(n-1)+fib(n-2)。 Code123456class Solution { public int fib(int n) { if(n == 0 || n == 1) return n; return fib(n-1) + fib(n-2); }}","link":"/2022/07/07/509-Fibonacci-Number/"},{"title":"51. N-Queens","text":"Question The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space, respectively. Solution话说今天出这道题真的不是搞事情嘛？ 八皇后问题，回溯+剪枝。按顺序搜索可以减少情况的重复计算。由于棋盘的大小为n * n，要放n个皇后，因此每一行（列）上都有且只有一位皇后。我们可以依顺序逐行回溯，对逐行的每一列进行回溯。由于每一行的可选位置都减少1，因此时间复杂度为O(N!)。 回溯通过一个char数组board[][]记录棋子状态。将board[][]初始化为’.’。遍历这一行的所有列，如果该位置有效，则board[i][j]改为’Q’，将这个点设置为有棋子，并递归下一行。回溯，将board[i][j]重新设置为’.’。 当递归次数达到n时，将char[]数组转换为字符串加入答案。 辅助方法 isValid检测该位置是否有效。即该位置的路径上是否已经有棋子，或该位置已经有棋子。由于我们的回溯方法是逐行确定棋子位置，因此不需要查看全部八个方向，而是查看之前已经遍历过的行即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { List&lt;List&lt;String&gt;&gt; ret; int size; int[][] operations; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { ret = new ArrayList&lt;&gt;(); size = n; operations = new int[][]{{-1,-1},{-1,1},{-1,0}}; char[][] board = new char[n][n]; for(char[] s : board){ Arrays.fill(s,'.'); } backtracking(board,0,0); return ret; } private void backtracking(char[][] board, int n, int i){ if(n == size){ List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for(char[] s : board) ans.add(new String(s)); ret.add(ans); return; } for(int j = 0; j &lt; size; j++){ if(isValid(board, i, j)){ board[i][j] = 'Q'; backtracking(board, n+1, i+1); board[i][j] = '.'; } } } private boolean isValid(char[][] board, int i, int j){ for(int[] operation : operations){ int p = i + operation[0]; int q = j + operation[1]; while(p &gt;= 0 &amp;&amp; p &lt; size &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; size){ if(board[p][q] == 'Q') return false; p += operation[0]; q += operation[1]; } } return true; }} Solution 2简单回溯。在回溯时搜索二维位置，因此增加了时间复杂度，正常是过不了的。通过按顺序进行搜索（只搜索当前行之后的位置）进行剪枝。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { List&lt;List&lt;String&gt;&gt; ret; int size; int[][] operations; HashSet&lt;String&gt; set; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { ret = new ArrayList&lt;&gt;(); size = n; operations = new int[][]{{1,1},{1,-1},{1,0},{0,1},{0,-1}}; backtracking(new int[n][n],0,0); return ret; } private void backtracking(int[][] border, int n, int start){ if(n == size){ //print(border); List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; size; i++){ StringBuffer sb = new StringBuffer(); for(int j = 0; j &lt; size; j++){ if(border[i][j] == 1){ sb.append(&quot;Q&quot;); } else{ sb.append(&quot;.&quot;); } } ans.add(sb.toString()); } ret.add(ans); return; } for(int i = start; i &lt; size; i++){ for(int j = 0; j &lt; size; j++){ if(border[i][j] == 0){ border[i][j] = 1; List&lt;int[]&gt; temp = new ArrayList&lt;&gt;(); for(int[] operation : operations){ int p = i, q = j; while(p &gt;= 0 &amp;&amp; p &lt; size &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; size){ if(border[p][q] == 0){ border[p][q] = 2; temp.add(new int[]{p,q}); } p += operation[0]; q += operation[1]; } } backtracking(border, n+1, i+1); for(int[] t : temp){ border[t[0]][t[1]] = 0; } border[i][j] = 0; } } } }}","link":"/2022/06/04/51-N-Queens/"},{"title":"52. N-Queens II","text":"Question The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Solution和昨天的题目51. N-Queens一样。只是不需要转换并记录字符串了，递归结束时直接将res+1即可。 Code1234567891011121314151617181920212223242526272829303132333435363738class Solution { int target; int res; int[][] operations; public int totalNQueens(int n) { target = n; res = 0; operations = new int[][]{{-1,0},{-1,1},{-1,-1}}; backtracking(new int[n][n], 0, 0); return res; } private void backtracking(int[][] board, int i, int n){ if(n == target){ res++; return; } for(int j = 0; j &lt; target; j++){ if(isValid(board, i, j)){ board[i][j] = 1; backtracking(board, i+1, n+1); board[i][j] = 0; } } } private boolean isValid(int[][] board, int i, int j){ for(int[] operation : operations){ int p = i + operation[0], q = j + operation[1]; while(p &gt;= 0 &amp;&amp; p &lt; target &amp;&amp; q &gt;= 0 &amp;&amp; q &lt; target){ if(board[p][q] == 1) return false; p += operation[0]; q += operation[1]; } } return true; }}","link":"/2022/06/05/52-N-Queens-II/"},{"title":"535. Encode and Decode TinyURL","text":"Note: This is a companion problem to the System Design problem: Design TinyURL.TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL. Implement the Solution class: Solution() Initializes the object of the system. String encode(String longUrl) Returns a tiny URL for the given longUrl. String decode(String shortUrl) Returns the original long URL for the given shortUrl. It is guaranteed that the given shortUrl was encoded by the same object. 计算传入连接的哈希值。将其作为key放入map中。解码时将url转换为key，取出map中的value。 12345678910111213141516171819public class Codec { HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); // Encodes a URL to a shortened URL. public String encode(String longUrl) { int key = longUrl.hashCode(); map.put(key, longUrl); return Integer.toString(key); } // Decodes a shortened URL to its original URL. public String decode(String shortUrl) { return map.get(Integer.parseInt(shortUrl)); }}// Your Codec object will be instantiated and called as such:// Codec codec = new Codec();// codec.decode(codec.encode(url));","link":"/2022/04/23/535-Encode-and-Decode-TinyURL/"},{"title":"538. Convert BST to Greater Tree","text":"问题Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only &gt;-&gt;- nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */DFS搜索，设置一个成员变量记录上一个节点的值。先递归右侧节点。设置当前节点的值为自身的值加上temp中的值。更新temp中的值，再递归左侧节点。class Solution { int temp; public TreeNode convertBST(TreeNode root) { temp = 0; dfs(root); return root; } private void dfs(TreeNode root){ if(root == null){ return; } dfs(root.right); root.val += temp; temp = root.val; dfs(root.left); }}","link":"/2022/04/16/538-Convert-BST-to-Greater-Tree/"},{"title":"542. 01 Matrix","text":"问题Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.The distance between two adjacent cells is 1. 由于是搜索最近的距离，因此可以采用BFS搜索。首先创建一个距离矩阵，将所有原矩阵为0的位置填上距离0，将其他位置填上无穷大。使用BFS搜索，将所有0的坐标放入队列。取出队列头元素，将其周围的距离矩阵的元素与自身距离矩阵的元素+1比较，将较小的值设置在周围的距离矩阵上。同时，将改变数值的坐标再次放入队列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution{ public int[][] updateMatrix(int[][] mat) { Queue&lt;Integer&gt; q = new LinkedList(); int row = mat.length; int col = mat[0].length; int[][] ans = new int[row][col]; for ( int i = 0; i &lt; row; i++ ){ for (int j = 0; j &lt; col; j++){ if (mat[i][j] == 0){ ans[i][j] = 0; q.add(i*col + j); } else{ ans[i][j] = Integer.MAX_VALUE; } } } while(!q.isEmpty()){ int i = q.peek() / col; int j = q.poll() % col; if(i-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i-1][j]){ ans[i-1][j] = ans[i][j]+1; q.add((i-1)*col + j); } if(i+1 &lt; row &amp;&amp; ans[i][j]+1 &lt; ans[i+1][j]){ ans[i+1][j] = ans[i][j]+1; q.add((i+1)*col + j); } if(j-1 &gt;= 0 &amp;&amp; ans[i][j]+1 &lt; ans[i][j-1]){ ans[i][j-1] = ans[i][j]+1; q.add(i*col + (j-1)); } if(j+1 &lt; col &amp;&amp; ans[i][j]+1 &lt; ans[i][j+1]){ ans[i][j+1] = ans[i][j]+1; q.add(i*col + (j+1)); } } return ans; }}","link":"/2022/04/10/542-01-Matrix/"},{"title":"56. Merge Intervals","text":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. 先对数组进行排序。遍历数组，当前一个子数组与后一个子数组有重叠时，合并数组。 1234567891011121314151617181920212223class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a,b) -&gt; Integer.compare(a[0],b[0])); int i = 0; List&lt;int[]&gt; ans = new ArrayList(); while( i &lt; intervals.length-1 ){ if(intervals[i][1] &gt;= intervals[i+1][0]){ intervals[i+1][0] = intervals[i][0]; intervals[i+1][1] = Math.max(intervals[i][1], intervals[i+1][1]); intervals[i] = null; } i++; } for(int[] interval : intervals){ if(interval != null){ ans.add(interval); } } return ans.toArray(new int[ans.size()][2]); }}","link":"/2022/04/18/56-Merge-Intervals/"},{"title":"55. Jump Game","text":"You are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. 反向查找，动态规划。到达目标点前必须到达上一个节点，且上一个节点能前进的步数必须大于目标点。设置目标点goal，反向遍历goal以外的点。如果该点能前进的步数加上自身的位置i大于目标点，则可以从上一个点到达goal。更新goal的位置到上一个点。如果遍历结束后，能返回到起始点0，则可以到达终点。 123456789class Solution { public boolean canJump(int[] nums) { int goal = nums.length-1; for(int i = nums.length-2; i &gt;=0; i--){ if(nums[i] &gt;= goal - i) goal = i; } return goal == 0; }} 贪心算法，储存一个到i时可以到达的最远值maxJump。遍历数组，如果i大于maxJump，则无法到达下一个点，返回false。在当前点可以到达的最大范围为nums[i]+i，如果大于maxJump则更新该值。遍历完毕返回true。 12345678910class Solution { public boolean canJump(int[] nums) { int maxJump = 0; for(int i = 0; i &lt; nums.length; i++){ if(i &gt; maxJump) return false; maxJump = Math.max(maxJump, nums[i] + i); } return maxJump &gt;= nums.length-1; }} 设置一个数组记录可访问的范围。当遍历时，如果可以访问，则将当前位置可以进一步访问的位置变为1。如果访问范围大于等于数组末尾，则返回真。 1234567891011121314151617class Solution { public boolean canJump(int[] nums) { int[] reach = new int[nums.length]; reach[0] = 1; for(int i = 0; i &lt; nums.length; i++){ if(reach[i] == 1){ if(i == nums.length-1) return true; for(int j = 0; j &lt; nums[i]; j++){ if(i+j+1 &gt;= nums.length) return true; reach[i+j+1] = 1; } } } return false; }}","link":"/2022/04/27/55-Jump-Game/"},{"title":"547. Number of Provinces","text":"There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise. Return the total number of provinces. DFS搜索，当map[i][i] = 1时加入搜索。搜索时将map[i][i]设为0。遍历并递归其数列。当map[i][i]等于0时，返回。 123456789101112131415161718192021222324252627class Solution { int[][] map; public int findCircleNum(int[][] isConnected) { map = isConnected; int count = 0; for(int i = 0; i &lt; isConnected.length; i++){ if(map[i][i] == 1){ count++; dfs(i); } } return count; } private void dfs(int i){ if(map[i][i] == 0){ return; } map[i][i] = 0; for(int j = 0; j &lt; map[0].length; j++){ if(map[i][j] == 1){ dfs(j); } } }}","link":"/2022/04/21/547-Number-of-Provinces/"},{"title":"567. Permutation in String","text":"问题Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1’s permutations is the substring of s2. 将要查找的组合加入数组，数值为字符出现的次数。滑动窗口，入窗口对应的元素数值-1，出窗口对应的元素数值+1。每次移动窗口都检验一次数组的数值是否全部为0，如果是真，则返回真。小技巧：直接用数组来记录字符出现的次数，用字符减去与’a’的差作为下标。 123456789101112131415161718192021222324252627282930313233343536class Solution { public boolean checkInclusion(String s1, String s2) { if (s1.length() &gt; s2.length()){ return false; } int[] dic = new int[26]; for (int i = 0; i &lt; s1.length(); i++){ dic[s1.charAt(i)-'a']++; dic[s2.charAt(i)-'a']--; } int i = 0; int j = s1.length(); while( j &lt; s2.length() ){ if ( allZero(dic) ){ return true; } dic[s2.charAt(i)-'a']++; dic[s2.charAt(j)-'a']--; i++; j++; } return allZero(dic); } private boolean allZero(int[] dic){ for (int num : dic){ if ( num != 0 ){ return false; } } return true; }}","link":"/2022/04/07/567-Permutation-in-String/"},{"title":"566. Reshape the Matrix","text":"问题概述In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. 根据数组的数学公式得出其位置，一次遍历将原数组中的数字填入。O(r*c) 1234567891011121314151617181920212223class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int[][] ans = new int[r][c]; int oldR = mat.length; int oldC = mat[0].length; if ( oldR * oldC != r * c ){ return mat; } for (int i = 0; i &lt; r*c ; i++ ){ int m = i/oldC; int n = i%oldC; int p = i/c; int q = i%c; ans[p][q] = mat[m][n]; } return ans; }}","link":"/2022/04/05/566-Reshape-the-Matrix/"},{"title":"572. Subtree of Another Tree","text":"Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself. 帮助方法isEqual，DFS搜索判断两个节点的子节点是否完全相同。DFS搜索，如果两个根节点的值相等则返回，且调用isEqual方法，如果子节点都相同则返回。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { return dfs(root, subRoot) != null; } private TreeNode dfs(TreeNode root, TreeNode subRoot){ if(root == null) return null; if(root.val == subRoot.val &amp;&amp; isEqual(root, subRoot)) return root; if(dfs(root.left, subRoot) != null ) return dfs(root.left, subRoot); else return dfs(root.right, subRoot); } private boolean isEqual(TreeNode root, TreeNode subRoot){ if(root == null || subRoot == null) return root == subRoot; if(root.val != subRoot.val) return false; return isEqual(root.left, subRoot.left) &amp;&amp; isEqual(root.right, subRoot.right); }}","link":"/2022/04/22/572-Subtree-of-Another-Tree/"},{"title":"576. Out of Boundary Paths","text":"Question There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball. Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7. SolutionDFS，记忆化搜索哦剪枝。 记忆化搜索三维数组memo[][][]用来记录起点为startRow, startColumn，剩余距离为maxMove时的总路径数。注意需要将memo[][][]所有数值初始化为-1。否则在进行BFS搜索时，无法对maxMove等于0的情况进行剪枝。 DFS当当前位置越界，则为一个有效路径，返回1。当剩余步数为0时，无法继续移动，返回0。 如果当前位置与剩余步数的状态已经被搜索并记录过，则直接返回memo[startRow][startColumn][maxMove]。如果未搜索，则将maxMove减一，并向四周移动一格，对当前位置的四个方向进行递归。记忆当前位置的四个方向的总路径数之和，模除后返回。 Code12345678910111213141516171819202122232425262728293031class Solution { final int MOD = (int) Math.pow(10, 9) + 7; long[][][] memo; public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) { memo = new long[m][n][maxMove]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ for(int k = 0; k &lt; maxMove; k++){ memo[i][j][k] = -1; } } } return (int) dfs(m, n, maxMove, startRow, startColumn); } private long dfs(int m, int n, int maxMove, int startRow, int startColumn){ if(startRow &lt; 0 || startRow &gt;= m || startColumn &lt; 0 || startColumn &gt;= n) return 1; if(maxMove == 0) return 0; maxMove--; if(memo[startRow][startColumn][maxMove] != -1) return memo[startRow][startColumn][maxMove]; long left = dfs(m, n, maxMove, startRow-1, startColumn); long right = dfs(m, n, maxMove, startRow+1, startColumn); long up = dfs(m, n, maxMove, startRow, startColumn+1); long down = dfs(m, n, maxMove, startRow, startColumn-1); memo[startRow][startColumn][maxMove] = (left + right + up + down) % MOD; return memo[startRow][startColumn][maxMove]; }}","link":"/2022/07/16/576-Out-of-Boundary-Paths/"},{"title":"581. Shortest Unsorted Continuous Subarray","text":"Question Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length. Solution未排序子数组的左侧和右侧均为单调递增的区间。我们的目标就是找到单调递增的边界。 中段由于是乱序的，因此其最大值与最小值必定不在中段的两端。因此我们可以从左至右的遍历数组，不断地维护一个当前的最大值max。由于只有中段是无序的，因此只有此时后面的数值才可能小于前面的最大值max。当这种情况发生时，则记录当前节点位置。同理，我们也可以从右至左遍历，维护一个当前的最小值min。只有在中段时，前面的数值才可能大于后面的最大值min。当这种情况发生时，则记录当前节点位置。 最后如果两个指针的位置相同，则返回0。（此时数组完全有序，指针未移动。）如果两个指针的位置不同，则返回两者的差+1。（即两者的宽度。） Code12345678910111213141516171819class Solution { public int findUnsortedSubarray(int[] nums) { int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; int start = 0; int end = 0; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &lt; max) end = i; else max = nums[i]; int j = nums.length - i - 1; if(nums[j] &gt; min) start = j; else min = nums[j]; } if(start == end) return 0; return end - start + 1; }}","link":"/2022/05/03/581-Shortest-Unsorted-Continuous-Subarray/"},{"title":"583. Delete Operation for Two Strings","text":"Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string. 动态规划，创建数组dp[][]，长宽分别为两个字符串的长度。在dp中填入子字符串修改成另一个子字符串时需要删除的数量。如果两个字符相同，则相对于上一个状态不需要增加数量。因此可以直接等于对角线方向上的值。如果两个字符串不同，则取上方向和左方向中的较小值，然后+1。（由于题目只允许删除操作，不允许修改操作，因此不能从字符串左上角取值。）最后返回dp中右下角的值。 12345678910111213141516171819202122232425262728class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m+1][n+1]; char[] bin1 = word1.toCharArray(); char[] bin2 = word2.toCharArray(); for(int i = 0; i &lt;= m; i++){ dp[i][0] = i; } for(int j = 0; j &lt;= n; j++){ dp[0][j] = j; } for(int i = 1; i &lt;= m; i++){ char k = bin1[i-1]; for(int j = 1; j &lt;= n; j++){ if(k == bin2[j-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + 1; } } } return dp[m][n]; }}","link":"/2022/05/02/583-Delete-Operation-for-Two-Strings/"},{"title":"560. Subarray Sum Equals K","text":"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k. 对于数组中每个数字，计算其前缀的和。前缀[i]减去前缀[j]的差，等于[j]-[i]之间数字的和。（类似一种DP，数组可以用一个变量代替。） 因此，原题目等于寻找找 前缀[i]-前缀[j] = k。用哈希表储存已经遍历过的前缀和出现的次数。每次遍历时先查看哈希表内是否有当前[前缀和-k]的键在。如果有则加入到count中。（哈希表中需要提前放入一个0键，值等于1，为了计算[前缀和-k]等于0的情况。） 1234567891011121314151617class Solution { public int subarraySum(int[] nums, int k) { int[] sum = new int[nums.length + 1]; HashMap&lt;Integer, Integer&gt; map = new HashMap(); int count = 0; map.put(0, 1); for(int i = 1; i &lt;= nums.length; i++){ sum[i] = sum[i-1] + nums[i-1]; count += map.getOrDefault(sum[i]-k, 0); map.put(sum[i], map.getOrDefault(sum[i], 0) + 1); } return count; }}","link":"/2022/04/20/560-Subarray-Sum-Equals-K/"},{"title":"59. Spiral Matrix II","text":"问题Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. 循环，创建一个上界和一个下界。当达到界限时，改变方向。更新上界和下界的数值。当上界小于下界时返回。 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int[][] generateMatrix(int n) { int[][] ans = new int[n][n]; int upperBound = n; int lowerBound = 0; int i = 0; int j = 0; int count = 1; ans[0][0] = 1; while ( lowerBound &lt; upperBound ){ while ( j &lt; upperBound-1 ){ j++; count++; ans[i][j] = count; } while ( i &lt; upperBound-1 ){ i++; count++; ans[i][j] = count; } while ( j &gt; lowerBound ){ j--; count++; ans[i][j] = count; } upperBound--; lowerBound++; while ( i &gt; lowerBound ){ i--; count++; ans[i][j] = count; } } return ans; }}","link":"/2022/04/13/59-Spiral-Matrix-II/"},{"title":"606. Construct String from Binary Tree","text":"Question Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. SolutionDFS搜索，先序遍历到每个节点将其加入StringBuffer。如果当前节点有左子节点或右子节点，则递归左子节点，并在前后添加一对括号。（如果有右子节点的情况即使左子节点为空也需要添加一对括号加以区别。）如果当前节点有右子节点，则递归右子节点，并在前后添加一对括号。 Code1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { StringBuffer sb; public String tree2str(TreeNode root) { sb = new StringBuffer(); dfs(root); return sb.toString(); } private void dfs(TreeNode root){ if(root == null) return; sb.append(root.val); boolean hasLeft = root.left != null, hasRight = root.right != null; if(hasLeft || hasRight) sb.append(&quot;(&quot;); dfs(root.left); if(hasLeft || hasRight) sb.append(&quot;)&quot;); if(hasRight) sb.append(&quot;(&quot;); dfs(root.right); if(hasRight) sb.append(&quot;)&quot;); }}","link":"/2022/09/06/606-Construct-String-from-Binary-Tree/"},{"title":"609. Find Duplicate File in System","text":"QuestionGiven a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order. A group of duplicate files consists of at least two files that have the same content. A single directory info string in the input list has the following format: &quot;root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot; It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory “root/d1/d2/.../dm&quot;. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory. The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format: &quot;directory_path/file_name.txt&quot; Solution使用StringBuffer对字符串进行处理。采用HashMap建立内容和对应列表的映射。 遍历处理字符串，并添加到map中。最后遍历map，如果对应的列表size大于1，则加入结果。 Code12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) { List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String path : paths){ StringBuffer folder = new StringBuffer(); int i = 0; while(path.charAt(i) != ' '){ folder.append(path.charAt(i)); i++; } while(i &lt; path.length()){ while(path.charAt(i) == ' ') i++; StringBuffer filename = new StringBuffer(); while(i &lt; path.length() &amp;&amp; path.charAt(i) != '('){ filename.append(path.charAt(i)); i++; } StringBuffer content = new StringBuffer(); while(i &lt; path.length() &amp;&amp; path.charAt(i) != ')'){ content.append(path.charAt(i)); i++; } i++; List&lt;String&gt; arr = map.getOrDefault(content.toString(), new ArrayList&lt;String&gt;()); arr.add(folder.toString() + '/' + filename); map.put(content.toString(), arr); } } for(String content : map.keySet()){ if(map.get(content).size() &gt; 1) res.add(map.get(content)); } return res; }}","link":"/2022/09/19/609-Find-Duplicate-File-in-System/"},{"title":"62. Unique Paths","text":"There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. 动态规划，每一个位置的线路都等于其左侧和上侧的两条线路的加和。将初始的两个边值设置为1，然后计算直至终点位置即可。 12345678910111213141516171819class Solution { int count; public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++){ dp[i][0] = 1; } for(int j = 0; j &lt; n; j++){ dp[0][j] = 1; } for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp[m-1][n-1]; }}","link":"/2022/04/29/62-Unique-Paths/"},{"title":"63. Unique Paths II","text":"Question You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m-1][n-1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 10&lt;sup&gt;9&lt;/sup&gt;. Solution机器人只朝向一个方向移动，不存在折返。因此可以采用动态规划，直接记录到某个点的总路线数。当遇到障碍时（即当前访问的格子为1）则不更新dp[]数组。 Code12345678910111213141516171819class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m+1][n+1]; dp[0][1] = 1; for(int x = 1; x &lt; m+1; x++){ for(int y = 1; y &lt; n+1; y++){ if(obstacleGrid[x-1][y-1] == 0){ dp[x][y] = dp[x][y-1] + dp[x-1][y]; } } } return dp[m][n]; }}","link":"/2022/05/20/63-Unique-Paths-II/"},{"title":"630. Course Schedule III","text":"Question There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [duration&lt;sub&gt;i&lt;/sub&gt;, lastDay&lt;sub&gt;i&lt;/sub&gt;] indicate that the i&lt;sup&gt;th&lt;/sup&gt; course should be taken continuously for duration&lt;sub&gt;i&lt;/sub&gt; days and must be finished before or on lastDay&lt;sub&gt;i&lt;/sub&gt;. You will start on the 1&lt;sup&gt;st&lt;/sup&gt; day and you cannot take two or more courses simultaneously. Return the maximum number of courses that you can take. Solution贪心算法，优先级队列实现。优先选择截止日期更短的课程。优先级队列pq记录当前已选课程，按持续时间从长到短排列。同时维护当前的日期curDay。 当当前选择的课程截止日期晚于curDay加上当前的持续时间duration时，查看大根堆里最长的课程longestDuration。如果最长的时间大于当前时间，则将其挤出，并将当前课程加入。 如果当前课程截止日期晚于curDay，则直接将其加入队列中，并更新curDay。 Code1234567891011121314151617181920212223242526class Solution { public int scheduleCourse(int[][] courses) { Arrays.sort(courses, (a, b) -&gt; a[1] - b[1]); PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b[0] - a[0]); int curDay = 0; for(int[] course : courses){ int duration = course[0]; int lastDay = course[1]; if(curDay + duration &gt; lastDay){ //大于截止日期 if(pq.isEmpty()) continue; int longestDuration = pq.peek()[0]; if(longestDuration &gt; duration){ //替换到当前队列中持续日期最长的课程 curDay -= pq.poll()[0]; curDay += duration; pq.offer(course); } } else{ //小于截止日期则加入选课 curDay += duration; pq.offer(course); } } return pq.size(); }}","link":"/2022/06/24/630-Course-Schedule-III/"},{"title":"637. Average of Levels in Binary Tree","text":"Question Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10&lt;sup&gt;-5&lt;/sup&gt; of the actual answer will be accepted. SolutionBFS搜索，记录单层的总和sum和单层的个数count。每次遍历一个层级的所有节点，并更新sum和count。遍历完毕后将当层级的平均数加入列表，同时将sum和count清零。 Code1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); double sum = 0, count = 0; int level = 1; q.add(root); while(!q.isEmpty()){ for(int i = 0; i &lt; level; i++){ TreeNode curr = q.poll(); if(curr.left != null) q.add(curr.left); if(curr.right != null) q.add(curr.right); count++; sum += curr.val; } res.add(sum/count); sum = 0; count = 0; level = q.size(); } return res; }}","link":"/2022/09/02/637-Average-of-Levels-in-Binary-Tree/"},{"title":"647. Palindromic Substrings","text":"Question Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string. SolutionManacher算法，与5. Longest Palindromic Substring的实现方法相同。 首先处理字符串。然后采用中心拓展计算各个位置的拓展长度，并维护c与r。每次遍历时计算结果，将当前可扩展长度加一然后除以二后加入结果。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { int n; int[] p; String newString; public int countSubstrings(String s) { n = s.length(); StringBuffer sb = new StringBuffer(); if(n == 0) { //对字符串进行处理 sb.append(&quot;^$&quot;); } else{ sb.append(&quot;^&quot;); for(int i = 0; i &lt; s.length(); i++){ sb.append('#'); sb.append(s.charAt(i)); } sb.append(&quot;#$&quot;); } p = new int[sb.length()]; newString = sb.toString(); return manacher(); } private int manacher(){ int res = 0, c = 0, r = 0; for(int i = 1; i &lt; newString.length()-1; i++){ int m = 2 * c - i; if(i &lt; r) p[i] = Math.min(r-i, p[m]); while(newString.charAt(i+p[i]+1) == newString.charAt(i-p[i]-1)){ //中心拓展 p[i]++; } if(i+p[i] &gt; r){ //更新c与r c = i; r = i + p[i]; } res += (p[i]+1)/2; //向上取整 } return res; }} Solution 2中心拓展，辅助方法count()用来计算每个字符可以组成的最大回文数。 注意每次需要计算奇数长度回文和偶数长度回文两种情况。遍历所有字符并加和，返回总数。 Code12345678910111213141516171819202122232425262728293031class Solution { String word; public int countSubstrings(String s) { word = s; int ret = 0; for(int i = 0; i &lt; s.length(); i++){ ret+=count(i); } return ret; } private int count(int i){ int count = 1, left = i-1, right = i+1; while(left &gt;= 0 &amp;&amp; right &lt; word.length() &amp;&amp; word.charAt(left) == word.charAt(right)){ count++; left--; right++; } left = i; right = i+1; while(left &gt;= 0 &amp;&amp; right &lt; word.length() &amp;&amp; word.charAt(left) == word.charAt(right)){ count++; left--; right++; } return count; }}","link":"/2022/05/22/647-Palindromic-Substrings/"},{"title":"653. Two Sum IV - Input is a BST","text":"问题Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. DFS搜索，每次递归时检查HashSet中是否有当前节点的值。如没有则将目标值减去当前节点的值加入HashSet。如有则返回true。递归左侧节点和右侧节点，并返回二者的或运算。 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { HashSet&lt;Integer&gt; set; public boolean findTarget(TreeNode root, int k) { set = new HashSet(); return dfs(root,k); } private boolean dfs(TreeNode root, int k){ if(root == null){ return false; } if(set.contains(root.val)){ return true; } set.add(k - root.val); return dfs(root.left,k) || dfs(root.right,k); }}","link":"/2022/04/16/653-Two-Sum-IV-Input-is-a-BST/"},{"title":"659. Split Array into Consecutive Subsequences","text":"Question You are given an integer array nums that is sorted in non-decreasing order. Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true: Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer). All subsequences have a length of 3** or more**. Return true* if you can split nums according to the above conditions, or false otherwise*. A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [&lt;u&gt;1&lt;/u&gt;,2,&lt;u&gt;3&lt;/u&gt;,4,&lt;u&gt;5&lt;/u&gt;] while [1,3,2] is not). Solution用优先级队列储存每个可组成的列表。优先级队列根据列表的长度排列。 用哈希表记录每个列表的尾数，和其对应的优先级队列。遍历所有数字，如果存在当前数字num-1为尾数的队列，则获取长度最小的列表，并添加当前数字num在列表中。然后将新的优先级队列放入哈希表中。 遍历整个哈希表中的数组，如果有数组的长度小于3，则返回false，否则返回true。 Code12345678910111213141516171819202122232425262728293031class Solution { public boolean isPossible(int[] nums) { HashMap&lt;Integer, PriorityQueue&lt;List&lt;Integer&gt;&gt;&gt; map = new HashMap&lt;&gt;(); for(int num : nums){ PriorityQueue&lt;List&lt;Integer&gt;&gt; last = map.getOrDefault(num - 1, null); PriorityQueue&lt;List&lt;Integer&gt;&gt; curr = map.getOrDefault(num, new PriorityQueue&lt;List&lt;Integer&gt;&gt;((a,b) -&gt; a.size() - b.size())); if(last == null || last.size() == 0){ List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); arr.add(num); curr.add(arr); map.put(num, curr); } else{ List&lt;Integer&gt; arr = last.poll(); arr.add(num); curr.add(arr); map.put(num, curr); } } for(int last : map.keySet()){ for(List&lt;Integer&gt; arr : map.get(last)){ if(arr.size() &lt; 3) return false; } } return true; }} Solution 2不需要保存整个列表，只需要保存对应末尾数字的列表长度即可。 Code12345678910111213141516171819202122232425262728class Solution { public boolean isPossible(int[] nums) { HashMap&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int num : nums){ PriorityQueue&lt;Integer&gt; last = map.getOrDefault(num - 1, null); PriorityQueue&lt;Integer&gt; curr = map.getOrDefault(num, new PriorityQueue&lt;Integer&gt;()); if(last == null || last.size() == 0){ curr.add(1); map.put(num, curr); } else{ int min = last.poll(); curr.add(min+1); map.put(num, curr); } } for(int last : map.keySet()){ for(int len : map.get(last)){ if(len &lt; 3) return false; } } return true; }}","link":"/2022/08/21/659-Split-Array-into-Consecutive-Subsequences/"},{"title":"665. Non-decreasing Array","text":"Question Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] &lt;= nums[i + 1] holds for every i (0-based) such that (0 &lt;= i &lt;= n - 2). Solution 1记录两个最大值last1和last2，初始化为整数最小值。真值flag初始化为true用来记录是否已经有非单调递增的值出现。遍历数组，如果当前数字num大于等于last2，则符合单调递增，更新last1和last2。 如果num小于last2，则不符合单调递增，此时将flag置为false。 如果num大于等于last1，则跳过现有的last2，将num保存在last2上。 如果num小于，则保留当前的last2 如果flag已经为false，则非单调递增的数字超过1个，返回false。遍历完毕则返回true。 Code12345678910111213141516171819202122class Solution { public boolean checkPossibility(int[] nums) { boolean flag = true; int last1 = Integer.MIN_VALUE, last2 = Integer.MIN_VALUE; for(int num : nums){ if(num &gt;= last2){ last1 = last2; last2 = num; } else if(flag){ flag = false; if(num &gt;= last1) last2 = num; else continue; } else{ return false; } } return true; }} Solution 2原理和Solution 1相同，只不过采用单调栈的形式保存单调递增数字。 Code1234567891011121314151617181920class Solution { public boolean checkPossibility(int[] nums) { Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); boolean flag = true; for(int num : nums){ if(s.isEmpty() || num &gt;= s.peek()) s.push(num); else if(flag){ flag = false; int temp = s.pop(); if(s.isEmpty() || num &gt;= s.peek()) s.push(num); else s.push(temp); } else{ return false; } } return true; }}","link":"/2022/06/25/665-Non-decreasing-Array/"},{"title":"669. Trim a Binary Search Tree","text":"问题Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer. Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds. DFS搜索，每次递归带上搜索的范围值。如果当前节点小于搜索范围，递归当前节点的右子节点。反之递归当前节点的左子节点。如果当前节点在搜索范围中，则其左子节点等于递归后的左子节点，右子节点等于递归后的右子节点。然后返回当前节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null){ return null; } if(root.val &lt; low){ return trimBST(root.right, low, high); } if(root.val &gt; high){ return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }}","link":"/2022/04/16/669-Trim-a-Binary-Search-Tree/"},{"title":"680. Valid Palindrome II","text":"问题Given a string s, return true if the s can be palindrome after deleting at most one character from it. 双指针，字符串两边对比。如果两边字符不相等，则更新两边指针，并分别传入辅助方法再次对比。两个结果有一个是true则返回true。 1234567891011121314151617181920212223242526272829class Solution { public boolean validPalindrome(String s) { int left = 0; int right = s.length() - 1; while (left &lt; right){ if (s.charAt(left) == s.charAt(right) ){ left++; right--; } else{ return ( checkPalindrome(s, left+1, right) || checkPalindrome(s, left, right-1)); } } return true; } private boolean checkPalindrome(String s, int left, int right){ while (left &lt; right){ if (s.charAt(left)==s.charAt(right)){ left++; right--; } else{ return false; } } return true; } }","link":"/2022/04/07/680-Valid-Palindrome-II/"},{"title":"673. Number of Longest Increasing Subsequence","text":"Question Given an integer array nums, return the number of longest increasing subsequences. Notice that the sequence has to be strictly increasing. Solution本题还有贪心算法+前缀和+二分查找的算法。 本题是300. Longest Increasing Subsequence的拓展。同样采用动态规划，数组dp[i]记录到i为止最长递增数列长度。可以用一个新的数组cnt[i]记录到i为止可以组成的最长递增数列的数量。 对于每个新位置i，cnt[i]的最小值为i。遍历i之前的所有位置j。如果nums[j] &lt; nums[i]，则i可以比dp[j]组成更长的递增数列，其长度为dp[j]+1。如果dp[i] &lt; dp[j]+1。则可以更新dp[i]。同时，cnt[i]可以从cnt[j]继承其计数。如果dp[i] == dp[j]+1。则之前已经更新过dp[i]。说明有新的组合同样可以组成更长的递增数列。此时将cnt[j]加入当前的cnt[i]。 遍历完成i以内的所有j后，如果dp[i]大于当前的最长递增数列长度，则更新max。同时更新长度的总数count为cnt[i]。如果dp[i]等于max，则将cnt[i]加入计数count。最后返回count。 Code123456789101112131415161718192021222324252627282930313233class Solution { public int findNumberOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; int[] cnt = new int[n]; int max = 0; int count = 0; for(int i = 0; i &lt; n; i++){ dp[i] = 1; cnt[i] = 1; for(int j = 0; j &lt; i; j++){ if(nums[i] &gt; nums[j]){ if(dp[j] + 1 &gt; dp[i]){ dp[i] = dp[j] + 1; cnt[i] = cnt[j]; //如果后面的数字大于前面的，且可以组成更长的数列，则继承之前的计数。 } else if(dp[j] + 1 == dp[i]){ //如果之前已经更新过dp[i]，则有新的组合长度一直，加和之前的计数。 cnt[i] += cnt[j]; } } } if(dp[i] &gt; max){ //如果当前的长度大于之前的最大值，则更新。 max = dp[i]; count = cnt[i]; //同时将之前计算的计数记录。 } else if(dp[i] == max){ //如果有同样达到最大值的情况，则加和计数。 count += cnt[i]; } } return count; }}","link":"/2022/05/06/673-Number-of-Longest-Increasing-Subsequence/"},{"title":"682. Baseball Game","text":"问题You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds’ scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following: An integer x - Record a new score of x. “+” - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. “D” - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. “C” - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score. Return the sum of all the scores on the record. 遍历选项，根据内容决定对ArrayList的操作。然后遍历将ArrayList加和，返回。 123456789101112131415161718192021222324252627class Solution { public int calPoints(String[] ops) { int ans = 0; List&lt;Integer&gt; records = new ArrayList(); for (String op : ops){ switch(op){ case &quot;+&quot;: records.add(records.get(records.size()-1)+records.get(records.size()-2)); break; case &quot;D&quot;: records.add(records.get(records.size()-1)*2); break; case &quot;C&quot;: records.remove(records.size()-1); break; default: records.add(Integer.parseInt(op)); } } for (int record : records){ ans += record; } return ans; }}","link":"/2022/04/11/682-Baseball-Game/"},{"title":"617. Merge Two Binary Trees","text":"问题You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. 递归。将root1和root2合并到root1。如果一个节点为null，则返回另一个节点。否则root1的值为root1 + root2的值。root1.left递归root1和root2的left。root2.right递归root1和root2的right。返回root1。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if( root1 == null ){ return root2; } if( root2 == null ){ return root1; } root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; }}","link":"/2022/04/10/617-Merge-Two-Binary-Trees/"},{"title":"695. Max Area of Island","text":"Question You are given an m x n binary matrix grid. An island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. SolutionDFS搜索, 维护一个变量count，为连续执行DFS搜索的次数。遍历地图上所有为1的位置。 运行BFS时每次将全局变量count增加1。执行完毕后BFS时将全局变量count清零。 遍历每个等于1的地图块。递归周围四个地图块，当超越数组范围，或者当前位置不为1时返回。进行搜索时将搜索过的地图块标记为0，不再重复搜索。 Code1234567891011121314151617181920212223242526272829class Solution { int[][] visited, directions; int count; public int maxAreaOfIsland(int[][] grid) { int res = 0; directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; for(int x = 0; x &lt; grid.length; x++){ for(int y = 0; y &lt; grid[0].length; y++){ if(grid[x][y] == 1){ count = 0; dfs(grid, x, y); res = Math.max(res, count); } } } return res; } private void dfs(int[][] grid, int x, int y){ if(x &lt; 0 || y &lt; 0 || x &gt;= grid.length || y &gt;= grid[0].length || grid[x][y] == 0) return; grid[x][y] = 0; count++; for(int[] direction : directions){ int i = x + direction[0]; int j = y + direction[1]; dfs(grid, i, j); } }}","link":"/2022/04/10/695-Max-Area-of-Island/"},{"title":"70. Climbing Stairs","text":"问题You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 递归，传入根节点，进行BFS搜索。如果当前节点小于搜索的最低点，则抛弃该节点，继续搜索其右子节点。（由于是BST，右子节点大于节点本身）如果当前节点大于搜索的最高点，则抛弃该节点，继续搜索其左子节点。如果当前节点在搜索范围内，则保留该节点，继续递归该节点的两个子节点。最后返回根节点。 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if(root == null){ return null; } if(root.val &lt; low){ return trimBST(root.right, low, high); } if(root.val &gt; high){ return trimBST(root.left, low, high); } root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; }}","link":"/2022/04/15/70-Climbing-Stairs/"},{"title":"700. Search in a Binary Search Tree","text":"问题You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. 搜索二叉树。递归，如果现有根节点为空则返回空。如果根节点的值大于搜索值则搜索其左子节点。如果根节点的值小于搜索值则搜索其左右节点。 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode searchBST(TreeNode root, int val) { if (root == null){ return null; } else if (root.val &lt; val){ return searchBST(root.right,val); } else if (root.val &gt; val){ return searchBST(root.left,val); } else{ return root; } }}","link":"/2022/04/14/700-Search-in-a-Binary-Search-Tree/"},{"title":"703. Kth Largest Element in a Stream","text":"问题Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. 优先级队列，插入所有元素，小元素在前。当队列长度大于k时，poll掉前面的元素。 12345678910111213141516171819202122232425class KthLargest { PriorityQueue&lt;Integer&gt; pq; int kth; public KthLargest(int k, int[] nums) { pq = new PriorityQueue&lt;Integer&gt;(); kth = k; for (int num : nums){ pq.add(num); } } public int add(int val) { pq.add(val); while (pq.size() &gt; kth){ pq.poll(); } return pq.peek(); }}/** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */","link":"/2022/04/09/703-Kth-Largest-Element-in-a-Stream/"},{"title":"705. Design HashSet","text":"Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. 计算哈希值，使用数组实现Hash Set。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyHashSet { int PRIME = 1009; List&lt;Integer&gt;[] data; public MyHashSet() { data = new List[PRIME]; for(int i = 0; i &lt; PRIME; i++){ data[i] = new LinkedList&lt;Integer&gt;(); } } public void add(int key) { if(!contains(key)){ int h = getHash(key); data[h].add(key); } } public void remove(int key) { int h = getHash(key); data[h].remove(new Integer(key)); } public boolean contains(int key) { int h = getHash(key); for( int num : data[h] ){ if( num == key ){ return true; } } return false; } private int getHash(int o){ return o % PRIME; }}/** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */","link":"/2022/04/21/705-Design-HashSet/"},{"title":"706. Design HashMap","text":"Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: MyHashMap() initializes the object with an empty map.void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. 哈希表，先设置一个素数Prime作为map的尺寸。（这里设置成素数是为了减少可能的碰撞。）创建一个Pair类记录key和value。 map初始化时需要生成一个LinkedList数组。 hash方法计算哈希值。用key % Prime并返回。 put方法，根据key计算其哈希值h。如果列表中有则重新设置当前Pair的value。 get方法，根据哈希值h搜索并查找链表中的Pair，如果找到则返回Pair，否则返回-1。 remove方法，根据哈希值h搜索并remove链表中的Pair。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class MyHashMap { final int PRIME = 1009; List&lt;Pair&gt;[] map; public MyHashMap() { map = new LinkedList[PRIME]; for(int i = 0; i &lt; PRIME; i++){ map[i] = new LinkedList&lt;Pair&gt;(); } } public void put(int key, int value) { int h = hash(key); for(Pair p : map[h]){ if(p.getKey() == key){ p.setValue(value); return; } } Pair p = new Pair(key, value); map[h].add(p); } public int get(int key) { int h = hash(key); for(Pair p : map[h]){ if(p.getKey() == key){ return p.value; } } return -1; } public void remove(int key) { int h = hash(key); for(Pair p : map[h]){ if(p.getKey() == key){ map[h].remove(p); return; } } } private int hash(int key){ return key % PRIME; }}class Pair { int key; int value; public Pair(int k, int v){ key = k; value = v; } public int getKey(){ return key; } public int getValue(){ return value; } public void setValue(int v){ value = v; }}/** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */","link":"/2022/04/18/706-Design-HashMap/"},{"title":"701. Insert into a Binary Search Tree","text":"问题You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. 如果root为空则将值直接添加到根节点。辅助方法比较当前节点的值。如当前值大于添加的值，则检测左子节点是否为空。如不为空则递归左子节点。如当前值小于添加的值，则检测右子节点是否为空。如不为空则递归右子节点。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null){ root = new TreeNode(val); } insert(root,val); return root; } private void insert(TreeNode root, int val){ if (root.val &lt; val){ if (root.right == null){ root.right = new TreeNode(val); } insert(root.right, val); } else if (root.val &gt; val){ if (root.left == null){ root.left = new TreeNode(val); } insert(root.left, val); } return; }}","link":"/2022/04/14/701-Insert-into-a-Binary-Search-Tree/"},{"title":"707. Design Linked List","text":"Design your implementation of the linked list. You can choose to use a singly or doubly linked list.A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid. 单链表，设置一个哨兵节点在头部。设置辅助方法，取得index的前一个节点。addAtHead和addAtTail都可以采用addAtIndex实现。 采用双链表速度可以更快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyLinkedList { ListNode head; int size; public MyLinkedList() { ListNode dummy = new ListNode(0); head = dummy; size = 0; } public ListNode getPrev(int index){ ListNode prev = head; for(int i = 0; i &lt; index; i++){ prev = prev.next; } return prev; } public int get(int index) { if(index &gt;= size) return -1; return getPrev(index).next.val; } public void addAtHead(int val) { addAtIndex(0, val); } public void addAtTail(int val) { addAtIndex(size, val); } public void addAtIndex(int index, int val) { if(index &gt; size) return; ListNode prev = getPrev(index); ListNode temp = prev.next; prev.next = new ListNode(val); prev.next.next = temp; size++; } public void deleteAtIndex(int index) { if(index &gt;= size) return; if(index == size-1){ ListNode prev = getPrev(index); prev.next = null; size--; return; } ListNode prev = getPrev(index); prev.next = prev.next.next; size--; } private void print(){ ListNode root = head.next; while(root != null){ System.out.print(root.val+&quot; -&gt; &quot;); root = root.next; } System.out.println(&quot;Size: &quot;+size); } class ListNode{ int val; ListNode next; public ListNode(int v){ val = v; } }}/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */","link":"/2022/04/27/707-Design-Linked-List/"},{"title":"713. Subarray Product Less Than K","text":"Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k. 滑动窗口，维护一个窗口内的乘积。当乘积小于目标值时，窗口右侧向右移动。每加入一个新数值，可以增加(j-i+1)个组合。当乘积大于目标时，窗口左侧向右移动。 123456789101112131415161718192021class Solution { public int numSubarrayProductLessThanK(int[] nums, int k) { int i = 0; int j = 0; int product = nums[0]; int count = 0; while(i &lt; nums.length &amp;&amp; j &lt; nums.length){ if(product &lt; k){ count += (j - i) + 1; j++; if(j &lt; nums.length ) product *= nums[j]; } else{ product /= nums[i]; i++; } } return count; }}","link":"/2022/04/20/713-Subarray-Product-Less-Than-K/"},{"title":"72. Edit Distance","text":"Question Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Solution本题和583. Delete Operation for Two Strings大同小异。 动态规划，两个字符串的分别以长宽组成一个矩阵，记录该位置得编辑距离。将初始的编辑距离dp[i][0]一行和dp[0][j]一列按照对应的位置i和j填写。 双重遍历矩阵的坐标。当两个字符相等时，编辑距离等于对角线方向的状态的编辑距离（即两个字符都没有取得上一个状态）。当两个字符不相等时，编辑距离等于左边，上边（少取一个字符的状态）以及对角线方向（两个字符都不取的状态）的编辑距离中得最小值再加上1。 Code123456789101112131415161718192021222324252627class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); char[] bin1 = word1.toCharArray(); char[] bin2 = word2.toCharArray(); int[][] dp = new int[m+1][n+1]; for(int i = 0; i &lt;= m; i++){ dp[i][0] = i; } for(int j = 0; j &lt;= n; j++){ dp[0][j] = j; } for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= n; j++){ if(bin1[i-1] == bin2[j-1]){ dp[i][j] = dp[i-1][j-1]; } else{ dp[i][j] = Math.min(dp[i-1][j-1] + 1, Math.min(dp[i-1][j], dp[i][j-1]) + 1); } } } return dp[m][n]; }}","link":"/2022/05/04/72-Edit-Distance/"},{"title":"729. My Calendar I","text":"Question You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking. A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. Implement the MyCalendar class: MyCalendar() Initializes the calendar object. boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. Solution有更快速的解法，需要用到TreeMap，有时间再研究。 使用一个队列记录已经预定的范围。添加无穷大到队列中，方便后期计算。 当预定新的时间段时，遍历队列，如果上一个数组的最大值小于start和end且当前遍历数组大于start和end，则可以预定，将当前的数组插入当前位置，并返回true。如果没有满足条件的，则返回false。 Code1234567891011121314151617181920212223242526272829303132class MyCalendar { List&lt;int[]&gt; arr; public MyCalendar() { arr = new ArrayList&lt;&gt;(); int[] inf = new int[2]; inf[0] = Integer.MAX_VALUE; inf[1] = Integer.MAX_VALUE; arr.add(inf); } public boolean book(int start, int end) { int[] last = new int[2]; for(int i = 0; i &lt; arr.size(); i++){ int[] curr = arr.get(i); if(last[1] &lt; end &amp;&amp; last[1] &lt;= start &amp;&amp; curr[0] &gt;= end &amp;&amp; curr[0] &gt; start){ int[] n = new int[2]; n[0] = start; n[1] = end; arr.add(i, n); return true; } last = curr; } return false; }}/** * Your MyCalendar object will be instantiated and called as such: * MyCalendar obj = new MyCalendar(); * boolean param_1 = obj.book(start,end); */","link":"/2022/08/03/729-My-Calendar-I/"},{"title":"733. Flood Fill","text":"答案An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. Return the modified image after performing the flood fill. 深度优先搜索。如果当前像素颜色等于最初的颜色，则变更为新颜色。然后继续递归四个周围的像素。 1234567891011121314151617181920212223242526272829class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int newColor) { int oldColor = image[sr][sc]; if (oldColor != newColor){ dfs(image,sr,sc,oldColor,newColor); } return image; } private void dfs(int[][] image, int r, int c, int oldColor, int newColor){ if (image[r][c] == oldColor){ image[r][c] = newColor; if (r&gt;=1){ dfs(image,r-1,c,oldColor,newColor); } if (c&gt;=1){ dfs(image,r,c-1,oldColor,newColor); } if (r&lt;image.length-1){ dfs(image,r+1,c,oldColor,newColor); } if (c&lt;image[0].length-1){ dfs(image,r,c+1,oldColor,newColor); } } }}","link":"/2022/04/09/733-Flood-Fill/"},{"title":"74. Search a 2D Matrix","text":"问题Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. 二分搜索，以整个数组尺寸作为搜索范围。每次搜索中间值，如等于target则返回。 123456789101112131415161718192021class Solution { public boolean searchMatrix(int[][] matrix, int target) { int left = 0; int right = (matrix.length * matrix[0].length) - 1; while(left &lt;= right){ int mid = left + (right - left)/2; int row = mid / matrix[0].length; int col = mid % matrix[0].length; if(matrix[row][col] == target){ return true; } else if(matrix[row][col] &gt; target){ right = mid - 1; } else{ left = mid + 1; } } return false; }} 双指针，先搜索到合适的行。再搜索到合适的列。 1234567891011121314151617181920212223242526272829class Solution { public boolean searchMatrix(int[][] matrix, int target) { int i = 0; int j = 0; while(i &lt; matrix.length){ if(matrix[i][0] == target){ return true; } else if(matrix[i][0] &lt; target){ i++; } else{ break; } } if( i == 0 ){ return false; } i--; while(j &lt; matrix[0].length){ if(matrix[i][j] == target){ return true; } j++; } return false; }}","link":"/2022/04/07/74-Search-a-2D-Matrix/"},{"title":"743. Network Delay Time","text":"Question You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (u&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;i&lt;/sub&gt;, w&lt;sub&gt;i&lt;/sub&gt;), where u&lt;sub&gt;i&lt;/sub&gt; is the source node, v&lt;sub&gt;i&lt;/sub&gt; is the target node, and w&lt;sub&gt;i&lt;/sub&gt; is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1. SolutionDijkstra算法此题可以转化为求起始节点到最远距离的节点的距离。单源最短路径问题，可以采用Dijkstra算法。 采用一个visited[]数组记录初始节点的访问状况。同时dist[]数组记录到达这一节点的最小距离，初始化为无限大。 进行BFS搜索，每次优先访问当前节点的子节点的最近子节点，并更新子节点与初始节点距离。最后遍历dist[]数组，如果有元素仍为无限大，则BFS搜索未遍历到，返回-1。否则返回数组内最大的距离即可。 建立映射首先通过哈希表，将起始节点与有向边建立起映射关系。列表中储存子节点和对应边上的权值。注意由于index是-1的，因此在组成列表时需要将当前数字减一。 优先级队列采用优先级队列组成小根堆，每次将当前的最小距离作为权值加入队列。初始化队列时需要将起始节点（k-1）放入，此时的总距离为0。 当当前的子节点的cost加上起始节点的距离小于子节点的最小距离时，更新子节点最小距离。同时将子节点当前最小距离作为比较对象传入优先级队列。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { public int networkDelayTime(int[][] times, int n, int k) { HashMap&lt;Integer, List&lt;int[]&gt;&gt; edges = new HashMap&lt;&gt;(); for(int[] time : times){ //建立有向边 int source = time[0] - 1, kid = time[1] - 1, cost = time[2]; //注意index需要-1 List&lt;int[]&gt; list = edges.getOrDefault(source, new ArrayList&lt;&gt;()); list.add(new int[]{kid, cost}); //建立起点——终点映射 edges.put(source, list); } int[] visited = new int[n]; int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b) -&gt; a[1] - b[1]); //优先级队列，最小堆每次访问距离最近的节点 int start = k-1; dist[start] = 0; pq.offer(new int[]{start, 0}); //start为初始节点，后面的距离为了实现优先级队列 while(!pq.isEmpty()){ int[] curr = pq.poll(); int source = curr[0]; if(visited[source] == 1) continue; visited[source] = 1; List&lt;int[]&gt; children = edges.getOrDefault(source, new ArrayList&lt;&gt;()); //获取当前起点的所有边 for(int[] child : children){ int kid = child[0], cost = child[1]; if(cost + dist[source] &lt; dist[kid]){ //如果新的距离小于之前的最小距离，则更新距离并将新的起点加入优先级队列 dist[kid] = cost + dist[source]; pq.offer(new int[]{kid, dist[kid]}); //更新的距离是从出发节点到当前节点的距离，每次优先访问最近的节点 } } } int res = 0; for(int d : dist){ //最后遍历，距离的最大值就是结果 res = Math.max(res, d); } return res == Integer.MAX_VALUE ? -1 : res; }}","link":"/2022/05/15/743-Network-Delay-Time/"},{"title":"745. Prefix and Suffix Search","text":"Question Design a special dictionary with some words that searchs the words in it by a prefix and a suffix. Implement the WordFilter class: WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns the index of the word in the dictionary, which has the prefix prefix and the suffix suffix. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. Solution改版的前缀树，用后缀+符号+前缀的形式记录字典树。 TrieNode用参数id记录TrieNode经历过的最大下标。 27位TrieNode数组children[]记录子TrieNode。 初始化将words[]中的每个字符串记录在TrieNode上，保存TrieNode的根节点root。在遍历每个字符串时，需要将每个“后缀+符号+前缀”组成的新字符串记录在字典树中，并更新当前节点的id值。 将后缀部分添加完毕后，加入特殊符号。检查并创建当前节点的curr[26]位置。然后继续将整个前缀字符串加入字典树，并更新当前节点的id值。 搜索搜索时，先遍历后缀，查找字典树的路径是否存在，并更新当前节点的位置，如不存在则返回-1。然后检查并跳过curr.children[26]的位置，如不存在则返回-1。最后遍历前缀，更新节点位置，如果路径不存在则返回-1。 最后返回当前节点的id即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class WordFilter { class TrieNode{ int id; TrieNode[] children; public TrieNode(){ children = new TrieNode[27]; id = 0; } } TrieNode root; public WordFilter(String[] words) { root = new TrieNode(); for(int k = 0; k &lt; words.length; k++){ String word = words[k]; for(int i = 0; i &lt; word.length(); i++){ TrieNode curr = root; int j = i; while(j &lt; word.length()){ int index = word.charAt(j) - 'a'; if(curr.children[index] == null) curr.children[index] = new TrieNode(); curr = curr.children[index]; curr.id = k; j++; } if(curr.children[26] == null) curr.children[26] = new TrieNode(); curr = curr.children[26]; curr.id = k; for(char c : word.toCharArray()){ int index = c - 'a'; if(curr.children[index] == null) curr.children[index] = new TrieNode(); curr = curr.children[index]; curr.id = k; } } } } public int f(String prefix, String suffix) { TrieNode curr = root; for(char c : suffix.toCharArray()){ int index = c - 'a'; if(curr.children[index] == null) return -1; curr = curr.children[index]; } if(curr.children[26] == null) return -1; curr = curr.children[26]; for(char c : prefix.toCharArray()){ int index = c - 'a'; if(curr.children[index] == null) return -1; curr = curr.children[index]; } return curr.id; }}/** * Your WordFilter object will be instantiated and called as such: * WordFilter obj = new WordFilter(words); * int param_1 = obj.f(prefix,suffix); */","link":"/2022/06/18/745-Prefix-and-Suffix-Search/"},{"title":"746. Min Cost Climbing Stairs","text":"Question You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Solution动态规划，每一个新位置的等于前一个位置加上其cost和前两个位置加上cost的较小值。 Code123456789class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length+1]; for(int i = 2; i &lt;= cost.length; i++){ dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]); } return dp[cost.length]; }}","link":"/2022/07/10/746-Min-Cost-Climbing-Stairs/"},{"title":"75. Sort Colors","text":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function. 快速排序是原地排序，因此此问题可以采用快速排序解决。 选择left上的元素pivot，设置一个指针index为left+1。遍历left+1至right的数组，如果遍历的值小于pivot则将nums[i]与nums[index]交换，然后将index向右移动。 因此index左侧的元素均小于pivot，index右侧的元素均大于pivot。最后将nums[index]与pivot交换，此时pivot左侧元素均小于它，右侧元素均大于它，因此index不需要再动。然后分别向下递归left至index-1，index+1至right。 12345678910111213141516171819202122232425262728class Solution { public void sortColors(int[] nums) { quickSort(nums, 0, nums.length-1); } private void quickSort(int[] nums, int left, int right){ if( right - left &lt; 1 ){ return; } int pivot = nums[left]; int index = left+1; for(int i = index; i &lt;= right; i++){ if(nums[i] &lt; pivot){ int temp = nums[index]; nums[index] = nums[i]; nums[i] = temp; index++; } } index--; nums[left] = nums[index]; nums[index] = pivot; quickSort(nums,left,index-1); quickSort(nums,index+1,right); }}","link":"/2022/04/17/75-Sort-Colors/"},{"title":"763. Partition Labels","text":"You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Note that the partition is done so that after concatenating all the parts in order, the resultant string should be s. Return a list of integers representing the size of these parts. 将英文字母出现的首尾作为intervals看待。根据字符创建数组并填入左右的index。根据左侧index排序数组。 从左至右，如果intervals有交集，则合并。否则在答案中添加当前interval的长度。 12345678910111213141516171819202122232425262728class Solution { public List&lt;Integer&gt; partitionLabels(String s) { int[][] alphabet = new int[26][2]; int head = s.charAt(0) - 'a'; for(int i = 0; i &lt; s.length(); i++){ int index = s.charAt(i) - 'a'; if(head != index &amp;&amp; alphabet[index][0] == 0) alphabet[index][0] = i; alphabet[index][1] = i; } Arrays.sort(alphabet, (a,b) -&gt; a[0] - b[0]); List&lt;Integer&gt; ans = new ArrayList(); int[] hold = alphabet[0]; for(int i = 1; i &lt; alphabet.length; i++){ if(alphabet[i][0] &lt;= hold[1]){ hold[1] = Math.max(hold[1], alphabet[i][1]); } else{ ans.add(hold[1]-hold[0]+1); hold = alphabet[i]; } } ans.add(hold[1]-hold[0]+1); return ans; }}","link":"/2022/04/21/763-Partition-Labels/"},{"title":"77. Combinations","text":"问题Given two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order. 回溯，构建搜索树。子节点取出的数值应大于父节点中取出的数值。直到树高度达到k后返回。 返回时，要new一个List，将原有list传入。否则添加到ans的值只是list的内存地址。ArrayList换成LinkedList可以优化一些速度，因为可以直接removeLast。（22ms -&gt; 16ms）i的范围限制在start到n-k+1，后面的限制容易被忽略，可以大幅度减枝，优化速度。（16ms -&gt; 1ms） 123456789101112131415161718192021class Solution { List&lt;List&lt;Integer&gt;&gt; ans; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { ans = new ArrayList&lt;&gt;(); backTrack(new LinkedList(),1,n,k); return ans; } private void backTrack(LinkedList&lt;Integer&gt; list, int start, int n, int k){ if (k == 0){ ans.add(new ArrayList(list)); return; } for (int i = start; i &lt;= n-k+1; i++){ list.add(i); backTrack(list, i+1, n, k-1); list.removeLast(); } }}","link":"/2022/04/13/77-Combinations/"},{"title":"771. Jewels and Stones","text":"Question You’re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Solution数组统计，先遍历宝石，记录宝石的位置。然后遍历石头，如果对应的位置已被记录则计数加一。 Code1234567891011121314class Solution { public int numJewelsInStones(String jewels, String stones) { int ret = 0; int[] bin = new int[58]; for(char c : jewels.toCharArray()){ bin[c-'A']++; } for(char c : stones.toCharArray()){ if(bin[c-'A'] != 0) ret++; } return ret; }}","link":"/2022/06/21/771-Jewels-and-Stones/"},{"title":"78. Subsets","text":"Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. 回溯，先添加一个空集，然后回溯各个单独节点。递归时传入数组内当前数字之后的节点。 1234567891011121314151617181920212223242526class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); ret.add(new ArrayList&lt;&gt;()); for(int i = 0; i &lt; nums.length ; i++){ backtrack(ret, new ArrayList&lt;&gt;(), nums, i); } return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] nums, int i){ if(i == nums.length-1){ arr.add(nums[i]); ret.add(new ArrayList&lt;&gt;(arr)); return; } arr.add(nums[i]); ret.add(new ArrayList&lt;&gt;(arr)); for(int j = i+1; j &lt; nums.length; j++){ backtrack(ret, arr, nums, j); arr.remove(arr.size()-1); } }}","link":"/2022/04/24/78-Subsets/"},{"title":"784. Letter Case Permutation","text":"答案Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. Return the output in any order. 当前字符如果为数字，则直接添加并递归。（将字符隐式转换为整数判断是否为数字，可提升速度。）当前字符如果为字母，则大小写分别添加到递归。（类似于回溯。）当字符串长度与搜寻字符串相等时，添加到列表。 1234567891011121314151617181920212223242526272829303132333435363738class Solution { List&lt;String&gt; ans; String _s; public List&lt;String&gt; letterCasePermutation(String s) { ans = new ArrayList(); _s = s; backTrack(new StringBuilder(),0); return ans; } private void backTrack(StringBuilder sb, int i){ if(i == _s.length()){ ans.add(sb.toString()); return; } char curr = _s.charAt(i); if ( isNums(curr) ){ sb.append(curr); backTrack(sb, i+1); } else{ StringBuilder sb2 = new StringBuilder(sb); sb.append(Character.toLowerCase(curr)); backTrack(sb, i+1); sb2.append(Character.toUpperCase(curr)); backTrack(sb2, i+1); } } private boolean isNums(char c){ if ( (int)c &gt;= (int)'0' &amp;&amp; (int)c &lt;= (int)'9' ){ return true; } return false; }}","link":"/2022/04/13/784-Letter-Case-Permutation/"},{"title":"785. Is Graph Bipartite?","text":"There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties: There are no self-edges (graph[u] does not contain u). There are no parallel edges (graph[u] does not contain duplicate values). If v is in graph[u], then u is in graph[v] (the graph is undirected). The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. Return true if and only if it is bipartite. 原题等于问：每个节点与其相连接的节点是否可以颜色不同？通过BFS搜索，将每一层通过开关flag分组。创建一个visited数组，记录分组和遍历情况。当节点被放入错误的分组时，返回false。 注意因为图里的各个节点可能不连接，因此需要遍历对所有节点进行BFS搜索，通过visited的情况进行剪枝。 123456789101112131415161718192021222324252627282930313233343536class Solution { public boolean isBipartite(int[][] graph) { Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); int[] visited = new int[graph.length]; for(int i = 0; i &lt; graph.length; i++){ boolean flag = false; if(graph[i].length == 0 || visited[i] != 0) continue; q.add(graph[i]); visited[i] = 1; int size = 1; while(!q.isEmpty()){ for(int j = 0; j &lt; size; j++){ int[] node = q.poll(); for(int next : node){ if(visited[next] == 0){ q.add(graph[next]); } if(flag){ if(visited[next] == 2) return false; visited[next] = 1; } else{ if(visited[next] == 1) return false; visited[next] = 2; } } } flag = !flag; size = q.size(); } } return true; }}","link":"/2022/04/29/785-Is-Graph-Bipartite/"},{"title":"797. All Paths From Source to Target","text":"Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]). 回溯。DFS搜索所有的路径。当搜索到最后一个位置时，保存动态数组并返回。（此处需要深拷贝数组。）回到上一层，取走动态数组的最后一个节点。 1234567891011121314151617181920class Solution { public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) { List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;(); dfs(ret, new ArrayList&lt;&gt;(), graph, 0); return ret; } private void dfs(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[][] graph, int i){ if( i == graph.length - 1){ arr.add(i); ret.add(new ArrayList(arr)); return; } arr.add(i); for( int j : graph[i] ){ dfs(ret, arr, graph, j); arr.remove(arr.size()-1); } }}","link":"/2022/04/23/797-All-Paths-From-Source-to-Target/"},{"title":"79. Word Search","text":"Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. 回溯，遍历所有初始元素。当寻找的字符与当前matrix里的字符相同时，将当前位置记录在visited里，并向下递归搜索四个方向，回溯visited。当越界或者字符已经visited时返回false。当寻找到单词的最后一位时，如果当前matrix里的字符与搜索的字符相等，则返回true。反之返回false。 1234567891011121314151617181920212223242526272829303132333435class Solution { char[][] bd; String wd; int[][] visited; public boolean exist(char[][] board, String word) { boolean ans = false; visited = new int[board.length][board[0].length]; bd = board; wd = word; for(int i = 0; i &lt; board.length; i++){ for(int j = 0; j &lt; board[0].length; j++){ ans = ans || backtracking(i, j, 0); } } return ans; } private boolean backtracking(int i, int j, int n){ if(i &lt; 0 || j &lt; 0 || i &gt;= bd.length || j &gt;= bd[0].length || n &gt;= wd.length()) return false; if(visited[i][j] == 1) return false; if(n == wd.length()-1) return bd[i][j] == wd.charAt(n); if( bd[i][j] == wd.charAt(n) ){ n++; visited[i][j] = 1; boolean a = backtracking(i+1, j, n); boolean b = backtracking(i-1, j, n); boolean c = backtracking(i, j+1, n); boolean d = backtracking(i, j-1, n); visited[i][j] = 0; return a || b || c || d; } return false; }}","link":"/2022/04/26/79-Word-Search/"},{"title":"804. Unique Morse Code Words","text":"Question International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: 'a' maps to &quot;.-&quot;, 'b' maps to &quot;-...&quot;, 'c' maps to &quot;-.-.&quot;, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, &quot;cab&quot; can be written as &quot;-.-..--...&quot;, which is the concatenation of &quot;-.-.&quot;, &quot;.-&quot;, and &quot;-...&quot;. We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. SolutionCode12345678910111213141516171819class Solution { public int uniqueMorseRepresentations(String[] words) { String[] alphabet = new String[]{&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;, &quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;, &quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;, &quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;}; HashSet&lt;String&gt; set = new HashSet&lt;&gt;(); for(String word : words){ StringBuffer sb = new StringBuffer(); for(char c : word.toCharArray()){ sb.append(alphabet[c - 'a']); } set.add(sb.toString()); } return set.size(); }}","link":"/2022/08/17/804-Unique-Morse-Code-Words/"},{"title":"814. Binary Tree Pruning","text":"Question Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed. A subtree of a node node is node plus every node that is a descendant of node. Solution 1DFS搜索，首先递归两个子节点。在搜索时如果节点为0且两个子节点均为null，则返回null。否则返回节点本身。 Code123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode pruneTree(TreeNode root) { if(root == null) return null; root.left = pruneTree(root.left); root.right = pruneTree(root.right); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0) return null; else return root; }} Solution 2DFS搜索，返回子节点和自己中是否包含1。如果节点为null，则返回false。如果自己为1，则返回true。否则返回两个子节点中是否有true。 BFS搜索，根据每个节点的子节点是否包含1来决定左右子节点是否保存。如果没有1，则将对应的子节点修改为null。 Code123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public TreeNode pruneTree(TreeNode root) { if(!hasOne(root)) return null; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty()){ TreeNode curr = q.poll(); if(hasOne(curr.left)) q.add(curr.left); else curr.left = null; if(hasOne(curr.right)) q.add(curr.right); else curr.right = null; } return root; } private boolean hasOne(TreeNode root){ if(root == null) return false; if(root.val == 1) return true; else return hasOne(root.left) || hasOne(root.right); }}","link":"/2022/09/06/814-Binary-Tree-Pruning/"},{"title":"82. Remove Duplicates from Sorted List II","text":"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. 使用队列暂存遍历的节点。初始化prev为一个dummy节点。如果当前节点不等于队列里节点的值，则倾倒出队列里的值。如果队列此时只有一个值，则将其添加到prev.next。遍历完毕后如果队列内只有一个值则将其设置到prev.next。最后返回dummy.next。 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { Queue&lt;ListNode&gt; q = new LinkedList(); ListNode dummy = new ListNode(0); ListNode prev = dummy; ListNode curr = head; while(curr != null){ if(q.isEmpty() || curr.val == q.peek().val){ q.offer(curr); curr = curr.next; } else{ if(q.size()==1){ prev.next = q.poll(); prev = prev.next; prev.next = null; } else{ q.clear(); } } } if(q.size()==1){ prev.next = q.poll(); } return dummy.next; }}","link":"/2022/04/18/82-Remove-Duplicates-from-Sorted-List-II/"},{"title":"820. Short Encoding of Words","text":"Question A valid encoding of an array of words is any reference string s and array of indices indices such that: words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words. Solution 1LeetCode这几天的每日一题时不让我学会字典树势不罢休啊…… 字典树，参数isLeaf记录每个TireNode节点是否为叶子节点。将单词倒序组建字典树，并维护isLeaf的属性。 计算从根节点到达每个叶子节点的长度再加一的和即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { class TrieNode{ TrieNode[] next = new TrieNode[26]; boolean isLeaf; } TrieNode root; int count; public int minimumLengthEncoding(String[] words) { count = 0; root = new TrieNode(); for(String word : words){ add(word); } countLeaves(root, 0); return count; } private void add(String word){ TrieNode curr = root; for(int i = word.length()-1; i &gt;= 0; i--){ int index = word.charAt(i) - 'a'; if(curr.next[index] == null){ curr.isLeaf = false; curr.next[index] = new TrieNode(); curr.next[index].isLeaf = true; } curr = curr.next[index]; } } private void countLeaves(TrieNode root, int length){ if(root.isLeaf){ count += length + 1; } else{ for(int i = 0; i &lt; 26; i++){ if(root.next[i] != null) countLeaves(root.next[i], length+1); } } }} Solution 2排序，将数组words根据单词倒序排序。倒序构成字典树，如果展开新的字典树分支（创建新的TrieNode节点）则将count加入根节点到新节点的距离。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution { class TrieNode{ TrieNode[] next = new TrieNode[26]; boolean end; } TrieNode root; int count; public int minimumLengthEncoding(String[] words) { Arrays.sort(words, new Comparator&lt;String&gt;(){ public int compare(String a, String b){ int i = a.length()-1, j = b.length()-1; while(i &gt;= 0 &amp;&amp; j &gt;= 0){ int index = a.charAt(i) - b.charAt(j); if(index == 0){ i--; j--; } else{ return index; } } return j - i; } }); count = 0; root = new TrieNode(); for(String word : words){ add(word); } return count; } private void add(String word){ TrieNode curr = root; int length = 1; boolean newTrieNode = false; for(int i = word.length()-1; i &gt;= 0; i--){ int index = word.charAt(i) - 'a'; if(curr.next[index] == null){ curr.next[index] = new TrieNode(); newTrieNode = true; } curr = curr.next[index]; length++; } curr.end = true; if(newTrieNode) count += length; }} Solution 3倒序重组字符串并记录到reversedWords[]数组，然后根据字典顺序排序。如果数组的上一个字符串不是下一个字符串的前缀，则加入上一个字符串的长度加一。 Code1234567891011121314151617class Solution { public int minimumLengthEncoding(String[] words) { String[] reversedWords = new String[words.length]; int count = 0, index = 0; for(String word : words){ reversedWords[index] = new StringBuffer(word).reverse().toString(); index++; } Arrays.sort(reversedWords); for(int i = 0; i &lt; words.length-1; i++){ if(!reversedWords[i+1].startsWith(reversedWords[i])) count += reversedWords[i].length()+1; } count += reversedWords[words.length-1].length()+1; return count; }}","link":"/2022/06/20/820-Short-Encoding-of-Words/"},{"title":"823. Binary Trees With Factors","text":"Question Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1. We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node’s value should be equal to the product of the values of its children. Return the number of binary trees we can make. The answer may be too large so return the answer modulo 10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7. Solution根据题意，二叉树的根是两个子节点的乘积，因此一个根节点可组成的二叉树总数，相当于其左子节点可组成的二叉树总数，乘以其右子节点可组成的二叉树总数。 因此我们可以先将数组arr排序，用dp[]数组记录以从小到大的数字作为根节点可组成的最大二叉树总数。 由于每个根节点至少可以和自身组成一个节点，因此将dp[]数组初始化为1。 动态规划从小到大遍历dp[]数组。在遍历时，从遍历数值i的左侧选取当前位置的子节点。（根据题意子节点一定小于根节点）当当前位置arr[i]可以整除arr[left]时，则有可能存在另一个子节点。此时根据哈希表中获得对应的另一个子节点right。如果right存在，则dp[i]更新为dp[i]+dp[left]*dp[right]的值。 最后将dp[]数组中记录的所有数字加和并返回。 Code1234567891011121314151617181920212223242526272829303132333435class Solution { public int numFactoredBinaryTrees(int[] arr) { final int MOD = (int) Math.pow(10, 9) + 7; Arrays.sort(arr); //from minium to maxium HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; arr.length; i++){ map.put(arr[i], i); } long[] dp = new long[arr.length]; Arrays.fill(dp, 1); for(int i = 0; i &lt; arr.length; i++){ for(int left = 0; left &lt; i; left++){ if(arr[i] % arr[left] == 0){ //make sure divisible int k = arr[i] / arr[left]; if(map.containsKey(k)){ int right = map.get(k); dp[i] = (dp[i] + dp[left] * dp[right]) % MOD; } } } } int res = 0; for(long num : dp){ res += num; res %= MOD; } return (int) res; }}","link":"/2022/08/08/823-Binary-Trees-With-Factors/"},{"title":"841. Keys and Rooms","text":"Question There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key. When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms. Given an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise. SolutionBFS，创建一个数组记录房间是否被访问。（用DFS搜素亦可。） 如果钥匙对应的房间已经访问过则跳过。如果未访问过则记录为已访问并加入队列。 最后遍历一次访问状态，如果有没访问过的房间则返回false。反之返回true。 Code12345678910111213141516171819202122class Solution { public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) { int[] visited = new int[rooms.size()]; visited[0] = 1; Queue&lt;List&lt;Integer&gt;&gt; q = new LinkedList&lt;&gt;(); q.add(rooms.get(0)); while(!q.isEmpty()){ List&lt;Integer&gt; keys = q.poll(); for(int key : keys){ if(visited[key] == 1) continue; visited[key] = 1; q.add(rooms.get(key)); } } for(int i=1; i&lt;rooms.size(); i++){ if(visited[i] == 0) return false; } return true; }}","link":"/2022/05/04/841-Keys-and-Rooms/"},{"title":"83. Remove Duplicates from Sorted List","text":"问题Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. 设置前一个节点和当前节点两个指针。由于是有数的链表，遍历时可以直接比较两个节点。如相等则前一个节点的next指向当前节点的next。 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { if ( head == null){ return head; } if ( head.next == null){ return head; } ListNode prev = head; ListNode curr = head.next; while(curr != null){ if(prev.val != curr.val){ curr = curr.next; prev = prev.next; } else{ prev.next = curr.next; curr = curr.next; } } return head; }}","link":"/2022/04/10/83-Remove-Duplicates-from-Sorted-List/"},{"title":"844. Backspace String Compare","text":"Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character. Note that after backspacing an empty text, the text will continue empty. 辅助方法getNextValid，返回下一个有效值。将两个指针分别设置在两个字符串的尾部。当两指针有一个大于0时，进行循环。每次都搜索两个指针的下一个有效值。如果两个指针上的字符不同则返回false。 最后返回两个指针的停留位置是否相同。 注意：如果有一个字符串指针先更新到0以下，另一个指针仍有可能更新到一个“#”字符位置。此时最后的结应该是两个空字符串。因此需要继续循环一次，得出其是否会归到零以下。如果此时归零则两者的指针位置仍然相等。 因此即使getNextValid返回的下一个值为负数也应该保留其数值。 1234567891011121314151617181920212223242526272829303132class Solution { public boolean backspaceCompare(String s, String t) { int i = s.length()-1; int j = t.length()-1; while(i &gt;= 0 || j &gt;= 0){ i = getNextValid(s, i); j = getNextValid(t, j); if( i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; s.charAt(i) != t.charAt(j)){ return false; } i--; j--; } return (i == j); } private int getNextValid(String s, int start){ int i = start; int count = 0; while(i &gt;= 0 &amp;&amp; (s.charAt(i) == '#' || count != 0)){ if(s.charAt(i) == '#'){ count++; } else{ count--; } i--; } return i; }}","link":"/2022/04/19/844-Backspace-String-Compare/"},{"title":"86. Partition List","text":"Question Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Solution 1生成前后两个部分的dummy链表头。遍历原链表，当当前值小于x时则将当前节点添加到第一个链表头后。当当前值大于x时则将当前节点添加到第二个链表头后。 遍历完成后将第二个链表头的下一个节点添加到第一个链表的下一个节点上。然后将第二个链表的尾部指向null。 返回第一个dummy链表节点的下一个节点即可。 Code12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode partition(ListNode head, int x) { ListNode dummy1 = new ListNode(), dummy2 = new ListNode(); ListNode hd1 = dummy1, hd2 = dummy2; while(head != null){ if(head.val &lt; x){ dummy1.next = head; dummy1 = dummy1.next; } else{ dummy2.next = head; dummy2 = dummy2.next; } head = head.next; } dummy1.next = hd2.next; dummy2.next = null; return hd1.next; }} Solution 2遍历整个链表，根据各个节点的值将其保存在两个队列中。 设置一个dummy节点头，将两个队列中的节点按顺序挤出并生成新链表。返回dummy节点头的下一个节点即可。 Code123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode partition(ListNode head, int x) { Queue&lt;ListNode&gt; q1 = new LinkedList&lt;&gt;(); Queue&lt;ListNode&gt; q2 = new LinkedList&lt;&gt;(); while(head != null){ if(head.val &lt; x) q1.add(head); else q2.add(head); head = head.next; } ListNode dummy = new ListNode(); ListNode res = dummy; while(!q1.isEmpty()){ res.next = q1.poll(); res = res.next; } while(!q2.isEmpty()){ res.next = q2.poll(); res = res.next; } res.next = null; return dummy.next; }}","link":"/2022/07/22/86-Partition-List/"},{"title":"867. Transpose Matrix","text":"Question Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix’s row and column indices. Solution记录一个新数组res[][]。 双重循环，交换下标将matrix[i][j]复制到res[j][i]，最后返回。 Code1234567891011class Solution { public int[][] transpose(int[][] matrix) { int[][] res = new int[matrix[0].length][matrix.length]; for(int i = 0; i &lt; matrix.length; i++){ for(int j = 0; j &lt; matrix[0].length; j++){ res[j][i] = matrix[i][j]; } } return res; }}","link":"/2022/06/02/867-Transpose-Matrix/"},{"title":"869. Reordered Power of 2","text":"Question You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this so that the resulting number is a power of two. Solution打表，将所有二的指数全部计算出来，并用数组统计各个数字出现的频率。然后同样统计n中各个数字出现的频率。 如果两者中有频率完全相同的情况，则返回true，反之返回false。 Code123456789101112131415161718192021222324252627282930313233class Solution { public boolean reorderedPowerOf2(int n) { int[] reorders = new int[10]; int m = 1, digits = 0; for(int i = n; i &gt; 0; i/=10){ reorders[i % 10]++; digits++; } int size = 0; List&lt;Integer[]&gt; powerOfTwo = new ArrayList&lt;&gt;(); while(m &gt; 0 &amp;&amp; size &lt;= digits){ size = 0; Integer[] bin = new Integer[10]; Arrays.fill(bin, 0); for(int i = m; i &gt; 0; i/=10){ size++; bin[i % 10]++; } if(size == digits) powerOfTwo.add(bin); m *= 2; } for(Integer[] bin : powerOfTwo) if(check(bin, reorders)) return true; return false; } private boolean check(Integer[] bin, int[] reorders){ for(int i = 0; i &lt; bin.length; i++) if(bin[i] != reorders[i]) return false; return true; }} Solution 2回溯，遍历计算可以组成的所有数字。打表记录所有二的指数并记录在哈希表内，如果所有组成数字中有哈希表内的数字则返回true，反之返回false。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { HashSet&lt;Integer&gt; visited, set, numbers; List&lt;Integer&gt; arr, res; public boolean reorderedPowerOf2(int n) { int m = 1; set = new HashSet&lt;&gt;(); visited = new HashSet&lt;&gt;(); numbers = new HashSet&lt;&gt;(); res = new ArrayList&lt;Integer&gt;(); while(m &gt; 0){ set.add(m); m *= 2; } arr = new ArrayList&lt;&gt;(); while(n &gt; 0){ arr.add(n % 10); n /= 10; } for(int i = 0; i&lt; arr.size(); i++){ if(arr.get(i) == 0) continue; visited.add(i); reorder(arr.get(i)); visited.remove(i); } for(int num : res) if(set.contains(num)) return true; return false; } private void reorder(int num){ if(visited.size() == arr.size()){ res.add(num); return; }; if(numbers.contains(num)) return; numbers.add(num); for(int i = 0; i &lt; arr.size(); i++){ if(visited.contains(i)) continue; int next = num * 10 + arr.get(i); visited.add(i); reorder(next); visited.remove(i); } }}","link":"/2022/08/26/869-Reordered-Power-of-2/"},{"title":"876. Middle of the Linked List","text":"问题Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. 快慢指针，两个指针不同速度遍历链表。当快指针达到链表尾部时候，慢指针正好在中间。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */class Solution { public ListNode middleNode(ListNode head) { ListNode slowNode = head; ListNode fastNode = head; while( fastNode != null ){ fastNode = fastNode.next; if (fastNode == null){ return slowNode; } slowNode = slowNode.next; fastNode = fastNode.next; } return slowNode; }}","link":"/2022/04/07/876-Middle-of-the-Linked-List/"},{"title":"858. Mirror Reflection","text":"Question There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2. The square room has walls of length p and a laser ray from the southwest corner first meets the east wall at a distance q from the 0&lt;sup&gt;th&lt;/sup&gt; receptor. Given the two integers p and q, return the number of the receptor that the ray meets first. The test cases are guaranteed so that the ray will meet a receptor eventually. Solution激光在箱子里折射，可以想象成在无限延展的空间内直线发射光线。因此三个接收器可以被视作组成了一个无限延展的矩阵。 只需要将q和p化简，然后确定坐标(q, p)所对应的接收器即可。由于接收器是间隔的，因此只需要先化简q，p后计算两者的奇偶性即可。 如果q与p皆为奇数，则返回1号接收器。如果q是奇数，p不是，则返回0号接收器。如果p是奇数，q不是，则返回2号接收器。 Code1234567891011121314151617class Solution { public int mirrorReflection(int p, int q) { int gcd = gcd(p, q); p/=gcd; q/=gcd; boolean xIsOdd = (p &amp; 1) == 1, yIsOdd = (q &amp; 1) == 1; if(xIsOdd &amp;&amp; yIsOdd) return 1; else if(xIsOdd) return 0; else return 2; } private int gcd(int a, int b){ if(a == b) return a; if(a &gt; b) return gcd(b, a-b); else return gcd(a, b-a); }}","link":"/2022/08/04/858-Mirror-Reflection/"},{"title":"88. Merge Sorted Array","text":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. 采用双指针，从结尾开始遍历两个数组。比较后按倒叙插入第一个数组。 1234567891011121314151617181920212223242526class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m - 1 , j = n - 1, k = m + n - 1; while ( i &gt;= 0 &amp;&amp; j &gt;= 0 ) { if ( nums1[i] &lt; nums2[j] ){ nums1[k] = nums2[j]; j--; k--; } else { nums1[k] = nums1[i]; i--; k--; } } if ( i &lt; 0 ){ while ( j &gt;= 0 ){ nums1[k] = nums2[j]; j--; k--; } } }}","link":"/2022/04/03/88-Merge-Sorted-Array/"},{"title":"897. Increasing Order Search Tree","text":"Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. DFS搜索，在递归时将in-order遍历节点，并将其加入队列。从队列中挤出节点，将上一个节点的右子节点设置为下一个节点。同时需要将下一个节点的左子节点设置为null。` 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { Queue&lt;TreeNode&gt; q; public TreeNode increasingBST(TreeNode root) { q = new LinkedList(); dfs(root); TreeNode head = q.poll(); TreeNode curr = head; while(!q.isEmpty()){ curr.left = null; curr.right = q.poll(); curr = curr.right; } curr.left = null; return head; } private void dfs(TreeNode root){ if(root == null){ return; } dfs(root.left); q.offer(root); dfs(root.right); }}","link":"/2022/04/17/897-Increasing-Order-Search-Tree/"},{"title":"890. Find and Replace Pattern","text":"Question Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter. Solution遍历words，对pattern和words中的字符建立映射。used[]数组记录访问状况。 如未建立映射关系，且word中的字符已建立映射，则不在结果中添加当前字符串。如未建立映射，则建立新的word与pattern的映射关系。如果当前已经建立映射，但是当前字符违反了映射关系，则不在结果中添加当前字符串。 Code123456789101112131415161718192021222324252627282930class Solution { public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) { List&lt;String&gt; ret = new ArrayList&lt;&gt;(); for(String word : words){ HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); //map characters from pattern and words boolean isSamePattern = true; int[] used = new int[26]; for(int i = 0; i &lt; word.length(); i++){ char pc = pattern.charAt(i), wc = word.charAt(i); if( !map.containsKey(pc) ){ if(used[wc-'a'] == 0){ //add new map if there is no map between characters and the character in word is not used map.put( pc, wc ); used[wc-'a']++; } else{ isSamePattern = false; break; } } else if( map.get(pc) != wc ){ //drop the word if not follow the pattern isSamePattern = false; break; } } if(isSamePattern) ret.add(word); } return ret; }}","link":"/2022/07/29/890-Find-and-Replace-Pattern/"},{"title":"90. Subsets II","text":"Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. 首先对数组进行排序，这样重复的元素将排列在一起。接下来对每一个层级进行回溯。进入每一个层级都根据上一级传递来的列表创建新列表。然后对层级下的所有元素进行回溯。剪枝，当遍历节点和上一个节点相等时，则跳过。回溯，从列表中去掉最后一个元素。 12345678910111213141516171819class Solution { public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); Arrays.sort(nums); backtrack(ret, new LinkedList&lt;Integer&gt;(), nums, 0); return ret; } private void backtrack(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; arr, int[] nums, int level){ ret.add(new LinkedList&lt;&gt;(arr)); for(int i = level; i &lt; nums.length; i++){ if(i != level &amp;&amp; nums[i] == nums[i-1]) continue; arr.add(nums[i]); backtrack(ret, arr, nums, i+1); arr.remove(arr.size()-1); } }}","link":"/2022/04/25/90-Subsets-II/"},{"title":"905. Sort Array By Parity","text":"Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. 双指针，右侧指针之后存放奇数项。当左侧指针的元素为奇数时，交换left和right上的元素。然后将右侧指针左移。当左侧指针的元素为偶数时，左侧指针左移。 12345678910111213141516171819202122232425class Solution { int[] arr; public int[] sortArrayByParity(int[] nums) { arr = nums; int left = 0; int right = nums.length-1; while(left &lt; right){ if(nums[left] % 2 == 1){ swap(left, right); right--; } else{ left++; } } return arr; } private void swap(int left, int right){ int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; }}","link":"/2022/05/02/905-Sort-Array-By-Parity/"},{"title":"91. Decode Ways","text":"A message containing letters from A-Z can be encoded into numbers using the following mapping: ‘A’ -&gt; “1”‘B’ -&gt; “2”…‘Z’ -&gt; “26”To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into: “AAJF” with the grouping (1 1 10 6) “KJF” with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”. Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. 动态规划。转移方程的考虑比较麻烦。当当前的字符不为0时，该为可以自己组成有效编码，因此dp[i] = dp[i-1]。然后考虑上一位可以和当前位组成有效编码的情况，如果上一位和当前位的数字小于26，且上一位不等于0，则可以联合编码。因此dp需要再加上前一位可以组成的编码数，即dp[i] += dp[i-2]。当i等于1时，由于会越界因此我们手动给dp[i]++。 12345678910111213141516171819class Solution { public int numDecodings(String s) { int n = s.length(); if(s.charAt(0) == '0') return 0; int[]dp = new int[n]; dp[0] = 1; for(int i = 1 ; i &lt; n; i++){ if(s.charAt(i) != '0'){ dp[i] = dp[i-1]; } if(s.charAt(i-1) != '0' &amp;&amp; (s.charAt(i-1) - '0') * 10 + (s.charAt(i) - '0') &lt;= 26 ){ if(i &gt; 1) dp[i] += dp[i-2]; else dp[i]++; } } return dp[n-1]; }}","link":"/2022/05/01/91-Decode-Ways/"},{"title":"923. 3Sum With Multiplicity","text":"Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7. 首先遍历元素，根据元素的值和出现次数建立哈希表。然后再哈希表中选择三个元素，如果和等于target，则计算三个元素出现次数的乘积。最后除以重复计算的次数。由于数值较大，因此中途计算应该采用长整型long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution { public int threeSumMulti(int[] arr, int target) { //enumberate every element and put them into the map HashMap&lt;Integer, Long&gt; map = new HashMap&lt;Integer, Long&gt;(); long count = 0; for ( int num : arr ){ if (!map.containsKey(num)){ map.put(num, (long)1); } else{ map.put(num, map.get(num)+1); } } //traverse whole elements and select three numbers for ( int a : map.keySet() ){ long totalA = map.get(a); for (int b : map.keySet()){ long totalB = map.get(b); if ( a == b ){ if (totalB &lt; 2){ continue; } totalB = totalB - 1; } int c = target - a - b; if ( map.containsKey(c) ){ long totalC = map.get(c); long total = 0; if ( a == b &amp;&amp; b == c ){ total = totalA * totalB * ( totalC - 2 ) ; } else if ( b == c || a == c ){ total = totalA * totalB * ( totalC - 1 ) ; } else{ total = totalA * totalB * totalC; } if ( total &gt; 0 ){ count += total; } } } } count/=6; int ans = (int) (count % 1000000007); return ans; }}","link":"/2022/04/07/923-3Sum-With-Multiplicity/"},{"title":"94. Binary Tree Inorder Traversal","text":"问题Given the root of a binary tree, return the inorder traversal of its nodes’ values. 中序遍历。先递归左子节点。然后将当前节点加入数组。最后递归右子节点。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { List&lt;Integer&gt; ans; public List&lt;Integer&gt; inorderTraversal(TreeNode root) { ans = new ArrayList(); traversal(root); return ans; } private void traversal(TreeNode root){ if (root == null){ return; } traversal(root.left); ans.add(root.val); traversal(root.right); return; }}","link":"/2022/04/12/94-Binary-Tree-Inorder-Traversal/"},{"title":"967. Numbers With Same Consecutive Differences","text":"Question Return all non-negative integers of length n such that the absolute difference between every two consecutive digits is k. Note that every number in the answer must not have leading zeros. For example, 01 has one leading zero and is invalid. You may return the answer in any order. Solution回溯，每次传入上一个数字和剩余的位数。全局变量sum记录加和。DFS搜索，每次计算下一位的可行数字并递归。用回溯维护sum的值。如果剩余位数为1，则将当前的sum加入结果，并清零sum。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { List&lt;Integer&gt; res; int sum; public int[] numsSameConsecDiff(int n, int k) { res = new ArrayList&lt;&gt;(); for(int i = 1; i &lt; 10; i++){ sum = 0; dfs(i, n, k); } int[] ret = new int[res.size()]; for(int i = 0; i &lt; res.size(); i++){ ret[i] = res.get(i); } return ret; } private void dfs(int prev, int n, int k){ sum += prev; if(n == 1){ res.add(sum); return; } if(k == 0){ sum *= 10; dfs(prev + k, n-1, k); sum /= 10; return; } if(prev + k &lt; 10){ sum *= 10; dfs(prev + k, n-1, k); sum /= 10; } if(prev &gt;= k){ sum *= 10; dfs(prev - k, n-1, k); sum /= 10; } }}","link":"/2022/09/02/967-Numbers-With-Same-Consecutive-Differences/"},{"title":"968. Binary Tree Cameras","text":"Question You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return the minimum number of cameras needed to monitor all nodes of the tree. Solution 1贪心算法，后序遍历。每次递归根据下面两个子节点的状态来决定当前节点的状态。 每个节点一共有三种状态： 未被监控，返回0。 摄像头，返回1。 已被监控，返回2。 递归，当当前节点为空，则返回2，表示已被监控。这样叶子节点则为未被监控的状态。 如果下面的子节点有一个未被监控，则当前节点需要设置相机，返回1，计数res+1。如果下面的子节点有一个为摄像头，则当前节点已被监控，返回2。否则下面的节点均为已被监控，此时返回未被监控0。 Code12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { int res = 0; //记录摄像头个数 public int minCameraCover(TreeNode root) { if(judge(root) == 0) res++; //如果根节点未被监控，则需要增加一个摄像机 return res; } public int judge(TreeNode root){ if(root == null) return 2; //根节点为空时返回2，这样叶子节点变为未被监控 int left = judge(root.left); int right = judge(root.right); if(left == 0 || right == 0){ //如果左右子节点有未被监控的节点，则当前节点设置为摄像机，结果加一，返回1 res++; return 1; } if(left == 1 || right == 1) return 2; //如果左右子节点中有摄像机，则当前节点已被监控，返回2 return 0; //如果左右子节点都被监控，则当前节点未被监控，返回0 }} Solution 2参考：从递归优化到树形DP 树形DP。递归，每次返回当前节点所有子节点的最小相机数。每一个节点有三种状态： 放置了相机。 没有相机，但是被父节点parent监控。 没有相机，但是被子节点son监控。 将三种状态分别传入minCam()方法。 递归方法 minCam()在递归时传入两个参数hasCamera和isWatched，来判断当前节点是否有相机，是否被监控。当当前节点为空节点时，如果设置应当有相机（做不到）则返回无限大，消除这个返回值。如果不应该有相机，则返回0。 向下递归子节点。 当当前节点应该有相机时：子节点一定被监控因此isWatched为true。子节点可以放置或不放置相机，因此hasCamera可以为true或false。注意当前位置放置相机，则子节点最多放置一个相机，因此一共有三种组合。由于相机至少有一个，因此返回其中的最小值+1。 当当前节点没有放置相机，但被父节点监控时：左右节点一共有四种组合，分别同时将子节点的监控状态向下递归。返回其中的最小值。 当当前节点没有放置相机，也没有被父节点监控，而是被子节点监控时：子节点至少有一个相机，向下递归状态，一共有三种组合。返回其中的最小值 然后分别调用minCam(root, true, true)和minCam(root, false, fasle)，取两者中的小值，即可得到答案。 树形dp优化剪枝上面的方法实际采用时会超时，因为我们重复了三次调用一个子树下的三种状态的minCam。因此我们可以将三种状态下的minCam分别保存在数组中返回。 withCam: 当前子树root有相机。 noCamWatchedByParent: 当前子树root没有相机，被父节点监控。 noCamWatchedBySon: 当前子树root没有相机，被子节点监控。 在每次递归时，获取数组minCam(root.left)和minCam(root.right)。然后根据左右子节点的三个参数来计算当前节点的新的三个参数，将其返回。 Code1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int minCameraCover(TreeNode root) { return Math.min(minCam(root, true, true), minCam(root, false, false)); } private int minCam(TreeNode root, boolean hasCamera, boolean isWatched){ if(root == null) return hasCamera ? Integer.MAX_VALUE / 2 : 0; if(hasCamera){ int min = Math.min(minCam(root.left, false, true) + minCam(root.right, false, true), minCam(root.left, true, true) + minCam(root.right, false, true)); min = Math.min(min, minCam(root.left, false, true) + minCam(root.right, true, true)); return 1 + min; } else if(isWatched){ int min = Math.min(minCam(root.left, true, true) + minCam(root.right, true, true), minCam(root.left, true, true) + minCam(root.right, false, false)); min = Math.min(min, minCam(root.left, false, false) + minCam(root.right, true, true)); min = Math.min(min, minCam(root.left, false, false) + minCam(root.right, false, false)); return min; } else{ int min = Math.min(minCam(root.left, true, true) + minCam(root.right, true, true), minCam(root.left, true, true) + minCam(root.right, false, false)); min = Math.min(min, minCam(root.left, false, false) + minCam(root.right, true, true)); return min; } }} Code12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { public int minCameraCover(TreeNode root) { int[] res = minCam(root); return Math.min(res[0], res[2]); } private int[] minCam(TreeNode root){ if(root == null){ return new int[] {Integer.MAX_VALUE/2, 0, 0}; } int[] left = minCam(root.left); int[] right = minCam(root.right); int withCam = 1 + Math.min(left[1] + right[1], Math.min(left[0] + right[1], left[1] + right[0]) ); int noCamWatchedByParent = Math.min( left[0] + right[0], Math.min( left[0] + right[2], Math.min( left[2] + right[0], left[2] + right[2] ))); int noCamWatchedBySon = Math.min( left[0] + right[0], Math.min( left[0] + right[2], left[2] + right[0])); return new int[] {withCam, noCamWatchedByParent, noCamWatchedBySon}; }}","link":"/2022/06/18/968-Binary-Tree-Cameras/"},{"title":"973. K Closest Points to Origin","text":"Question Given an array of points where points[i] = [x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x&lt;sub&gt;1&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;- x&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ (y&lt;sub&gt;1&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;- y&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in). Solution此题可以采用快速排序的思想。可以在O(n)时间复杂度里完成排序。 Solution 2优先级队列，根据每个点距离的平方排序。时间复杂度O(nlogk)。 Code123456789101112131415161718class Solution { public int[][] kClosest(int[][] points, int k) { int[][] ret = new int[k][2]; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; squaredDistance(a) - squaredDistance(b)); for(int[] point : points){ pq.add(point); } for(int i = 0; i &lt; k; i++){ ret[i] = pq.poll(); } return ret; } private int squaredDistance(int[] point){ int x = point[0], y = point[1]; return x * x + y * y; }} Solution 3直接排序。时间复杂度为O(nlogn)。 123456789101112131415class Solution { public int[][] kClosest(int[][] points, int k) { int[][] ret = new int[k][2]; Arrays.sort(points, (a, b) -&gt; squaredDistance(a) - squaredDistance(b)); for(int i = 0; i &lt; k; i++){ ret[i] = points[i]; } return ret; } private int squaredDistance(int[] point){ int x = point[0], y = point[1]; return x * x + y * y; }}","link":"/2022/05/05/973-K-Closest-Points-to-Origin/"},{"title":"977. Squares of a Sorted Array","text":"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. 采取双指针，同时比较两侧的正负及大小。 1234567891011121314151617181920212223242526272829303132333435class Solution { public int[] sortedSquares(int[] nums) { int left = 0; int right = nums.length - 1; int i = nums.length-1; int[] ans = new int[nums.length]; while (left &lt;= right) { if ( nums[left] &lt; 0 ){ if ( (-nums[left]) &lt; nums[right] ){ ans[i] = nums[right] * nums[right]; right--; } else { ans[i] = nums[left] * nums[left]; left++; } i--; } else{ if ( nums[left] &lt; nums[right] ){ ans[i] = nums[right] * nums[right]; right--; } else{ ans[i] = nums[left] * nums[left]; left++; } i--; } } return ans; }}","link":"/2022/04/03/977-Squares-of-a-Sorted-Array/"},{"title":"986. Interval List Intersections","text":"You are given two lists of closed intervals, firstList and secondList, where firstList[i] = [starti, endi] and secondList[j] = [startj, endj]. Each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. A closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b. The intersection of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3]. 设置两个指针，分别指向两个intervals的头部。循环，相交的left等于两者左端的较大值。right等于两者右端的较小值。只有在left小于right时，两个interval才相交，填入列表。然后更新两个interval中右端较小的指针。 12345678910111213141516171819202122class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { List&lt;int[]&gt; ans = new ArrayList(); int i = 0; int j = 0; while(i &lt; firstList.length &amp;&amp; j &lt; secondList.length){ int left = Math.max( firstList[i][0], secondList[j][0] ); int right = Math.min( firstList[i][1], secondList[j][1] ); if(left &lt;= right){ ans.add(new int[]{left, right}); } if(firstList[i][1] &lt; secondList[j][1]) i++; else j++; } int[][] ret = new int[ans.size()][2]; ans.toArray(ret); return ret; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { int i = 0; int j = 0; ArrayList&lt;int[]&gt; ans = new ArrayList(); int[] holdA; int[] holdB; while(i &lt; firstList.length &amp;&amp; j &lt; secondList.length){ holdA = firstList[i]; holdB = secondList[j]; int[] arr = new int[2]; if(holdA[0] &lt;= holdB[0] &amp;&amp; holdA[1] &gt;= holdB[1]){ ans.add(holdB); j++; } else if(holdA[0] &gt;= holdB[0] &amp;&amp; holdA[1] &lt;= holdB[1]){ ans.add(holdA); i++; } else if(holdA[0] &lt;= holdB[0] &amp;&amp; holdA[1] &gt;= holdB[0]){ arr[0] = holdB[0]; arr[1] = holdA[1]; ans.add(arr); i++; } else if(holdA[0] &gt;= holdB[0] &amp;&amp; holdB[1] &gt;= holdA[0]){ arr[0] = holdA[0]; arr[1] = holdB[1]; ans.add(arr); j++; } else if(holdA[1] &lt;= holdB[1]){ i++; } else{ j++; } } int[][] ret = new int[ans.size()][2]; ans.toArray(ret); return ret; }}","link":"/2022/04/19/986-Interval-List-Intersections/"},{"title":"99. Recover Binary Search Tree","text":"You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. DFS中序搜索，额外记录访问的前一个节点。如果当前节点与前一个节点的顺序不对，则暂且认为先后两个节点的位置均不正确。（前一个大于后一个的值，由于是第一个不满足递增条件的位置，因此前一个的位置一定是错误的。但此时当前值不一定是错误的。）继续递归，如果发现新的节点位置不正确，则后一个节点位置正确，更新当前节点为不正确的节点。（由于是第二个不满足递增条件的位置，因此当前值是错误的。）交换两个位置不正确的节点的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */class Solution { TreeNode prev; boolean flag; TreeNode[] wrong; public void recoverTree(TreeNode root) { wrong = new TreeNode[2]; prev = new TreeNode(Integer.MIN_VALUE); flag = true; dfs(root); int swap = wrong[0].val; wrong[0].val = wrong[1].val; wrong[1].val = swap; } private void dfs(TreeNode root){ if(root == null){ return; } dfs(root.left); if(prev.val &gt; root.val){ if(flag){ wrong[0] = prev; flag = false; } wrong[1] = root; } prev = root; dfs(root.right); }}","link":"/2022/04/19/99-Recover-Binary-Search-Tree/"},{"title":"994. Rotting Oranges","text":"问题You are given an m x n grid where each cell can have one of three values: 0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1. 由于腐烂的橘子每次都只能影响周围的橘子，因此采用BFS。将所有腐烂的橘子加入队列。如果没有新鲜的橘子，则返回0。每次出队列，如果周围有新鲜的橘子存在，则将新鲜的橘子替换为腐烂并加入队列。每个level结束后，time+1。 最后遍历一遍，如果还有新鲜的橘子，返回-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution { public int orangesRotting(int[][] grid) { Queue&lt;Integer&gt; q = new LinkedList(); int row = grid.length; int col = grid[0].length; int fresh = 0; for (int i = 0; i &lt; row; i++){ for(int j = 0; j &lt; col; j++){ if ( grid[i][j] == 2){ q.add(i * col + j); } else if (grid[i][j] == 1){ fresh++; } } } if(fresh == 0){return 0;} int count = q.size()-1; int temp = 0; int time = -1; while(!q.isEmpty()){ int i = q.peek() / col; int j = q.poll() % col; if(i-1&gt;=0 &amp;&amp; grid[i-1][j] == 1){ grid[i-1][j] = 2; q.add((i-1)*col+j); temp++; } if(j-1&gt;=0 &amp;&amp; grid[i][j-1] == 1){ grid[i][j-1] = 2; q.add(i*col+(j-1)); temp++; } if(i+1&lt;row &amp;&amp; grid[i+1][j] == 1){ grid[i+1][j] = 2; q.add((i+1)*col+j); temp++; } if(j+1&lt;col &amp;&amp; grid[i][j+1] == 1){ grid[i][j+1] = 2; q.add(i*col+(j+1)); temp++; } if(count == 0){ count = temp; temp = 0; time++; } count--; } for (int i = 0; i &lt; row; i++){ for(int j = 0; j &lt; col; j++){ if ( grid[i][j] == 1){ return -1; } } } return time; }}","link":"/2022/04/10/994-Rotting-Oranges/"},{"title":"997. Find the Town Judge","text":"Question In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. Solution题目可以转换为计算各个顶点的入度和出度。 遍历每条边，并计算边上两个顶点的出度和入度。如果某个节点的入度为n-1，出度为0，则符合有法官的条件。否则没有法官，返回-1。 Code123456789101112131415class Solution { public int findJudge(int n, int[][] trust) { int[] inDegrees = new int[n]; int[] outDegrees = new int[n]; for(int[] edge : trust){ outDegrees[edge[0]-1]++; inDegrees[edge[1]-1]++; } for(int i = 0; i &lt; n; i++){ if(outDegrees[i] == 0 &amp;&amp; inDegrees[i] == n-1) return i+1; } return -1; }}","link":"/2022/05/04/997-Find-the-Town-Judge/"},{"title":"About Me","text":"Hi, I am Xuanhe (Xander) Zhang, a graduate architecture student at UCLA, and hope to become a computational designer!My objective is to provide helpful tools for architects to design through Coding and AI.And demonstrate them via various technical ways through VR or AR.I hope to explore more possibilities of architectural and computational design in my work.","link":"/about.html"},{"title":"Artifical Intelligence in Mapping","text":"Artifical IntelligenceArtificial Intelligence has revolutionized many industries, and architecture is no exception. In fact, some parts of this passage was generated by chatGPT, a trained model for conversation. With the help of AI, architects and designers can now generate and visualize building designs in a fraction of the time it would have taken with traditional methods. One of the most promising applications of AI in architecture is the generation of images to guide design and building generation. By training AI algorithms on large datasets of architectural images and designs, researchers have been able to teach these algorithms to generate new images that capture the key features of different architectural styles, such as Gothic or Art Deco. These generated images can then be used to guide the design process, providing architects and designers with a source of inspiration and a starting point for their own creative ideas. In this way, AI is not replacing architects or designers, but rather empowering them to work more efficiently and effectively, pushing the boundaries of what is possible in architectural design and building generation.","link":"/2023/03/30/Artifical-Intelligence-in-Mapping/"},{"title":"Augment Reality","text":"Augment RealityAugmented reality (AR) technology can be a valuable tool for architects during the design process, and my work demonstrates how AR can be used to enhance the design process. By combining models in Blender and using AI and prompts to generate images, we were able to select appropriate images and model them in Rhino, creating physical models using 3D printing. To showcase these models, I developed an AR application in Unity and C# that uses QR code recognition to locate the model and display a virtual version in the app. With this AR technology, clients can swipe left and right or up and down in the app to replace different parts of the model with different materials, providing a visual representation of various material combinations. Additionally, clicking on the screen generates random agents that navigate through the model, providing an interactive experience between the architect and the building. This AR technology allows architects to visualize and manipulate digital models in real-world environments, providing a more intuitive and immersive experience compared to traditional 2D or 3D modeling. By superimposing digital models onto physical spaces, architects can see how the design fits into the surrounding environment, allowing them to make more informed design decisions and identify potential issues before construction begins. Furthermore, AR technology can facilitate collaboration among architects, clients, and other stakeholders. By allowing stakeholders to see and interact with the design in real-time, AR technology provides valuable feedback and allows for more efficient communication and decision-making. In summary, my work using AR technology shows the potential for this technology to transform the way architects design and communicate their ideas, leading to more efficient and effective design processes and ultimately better-built environments.","link":"/2023/04/02/Augment-Reality/"},{"title":"Blender Modeling &amp; Rendering","text":"3D Model ScanningBy using smartphones to scan objects and generate 3D models, users can quickly and easily create detailed digital models of physical objects. These 3D models can be combined and manipulated to generate creative and innovative new designs that were previously difficult or time-consuming to create. With the ability to freely combine and adjust these 3D models, users can explore new design ideas and iterate quickly, saving time and resources in the process. This approach enables designers, architects, and other creatives to experiment and explore different design possibilities, leading to more innovative and unique final products. The use of smartphones and 3D modeling provides a powerful toolset for creative professionals looking to push the boundaries of design and create truly unique and innovative new products. Blender RenderingBlender offer a powerful combination for 3D modeling and rendering of everyday plastic objects. With Blender’s powerful modeling and rendering capabilities, users can create highly detailed and precise adjustments to the object’s shape, texture, and lighting. Additionally, The “Plastic Joy” provides a fresh perspective on everyday objects, allowing users to create innovative and unique designs. AI in BlenderBlender’s Dream Textures plug-in offers further benefits for architects and designers, allowing them to quickly and easily create colorful materials and transform rooms into different styles of scenes. By using this plug-in, architects can dramatically improve the efficiency of their designs for interiors, exploring different design options in a fraction of the time it would take with traditional design methods. The combination of Blender and AI provides a powerful toolset for designers, architects, and creatives looking to explore new possibilities in 3D modeling and rendering. From highly detailed plastic objects to colorful interiors, this powerful combination offers a wide range of applications and benefits for creative professionals.”","link":"/2023/03/27/Blender-Modeling-&-Rendering/"},{"title":"Digital Fabrication","text":"Parametric DesignGrasshopper is a powerful tool for creating parametric Digital Fabrication models that can be customized by adjusting various parameters to achieve the desired outcome. This flexibility allows designers and architects to iterate quickly and efficiently, exploring multiple design options and variations until they arrive at the optimal solution. Developable Surface Mathematically speaking, a Developable Surface is a smooth surface that has zero Gaussian curvature, which means it can be flattened onto a plane without any distortion. This characteristic makes it a highly desirable surface for generating forms for architecture and can significantly reduce building costs due to their unique property. The digital fabrication model utilizes card stock to produce 80% of the Developable Surfaces. The remaining 20% of non-developable surfaces are created using 3D printing. Rhino’s Gaussian analysis tool is used to verify if a model meets the requirements for developable surfaces. In addition, the Zebra pattern analysis tool is employed to ensure that the model satisfies the 3D printing criteria of having no seams.","link":"/2023/03/30/Digital-Fabrication/"},{"title":"Distance - 几种距离","text":"欧几里得距离曼哈顿距离（方格距离）切比雪夫距离（棋盘距离）汉明距离（信号距离）","link":"/2022/05/05/Distance-%E5%87%A0%E7%A7%8D%E8%B7%9D%E7%A6%BB/"},{"title":"Emacs Commands","text":"Command English 中文 C-x C-f New/Open file 新建/打开 C-x C-w Save as 另存为 C-x C-c Exit 退出 C-x C-s Save 保存 C-s Search next 向下搜索 C-r Search last 向上搜索 C-a Start of the line 行首 C-e End of the line 行末 C-p Last line 上一行 C-n Next line 下一行 C-d Delete cursor 删除光标下字符 C-k Delete line 删除整行 M-d Delete word 删除单词 M-g g Move to x line 移动到某行 C-/ Undo 撤销 C-v Next screen 下一屏 M-v Last screen 上一屏 C-M-s Search regex 正则表达式搜索 C-@ Mark 选中 C-w Cut 剪切 M-w Copy 复制 C-y Paste 粘贴 M-! Shell Mode Shell模式 M-x shell Shell Mode Shell模式（交互式）","link":"/2023/01/17/Emacs-Commands/"},{"title":"Icarus主题增加夜间模式","text":"实现了新主题的夜间模式效果！ 小插曲： 直接复制代码的恶果😅 开了控制台才发现有两个莫名其妙的“+”…… 参考资料：Hexo主题Icarus的自定义Sukka’s Blogzthxxx.me","link":"/2022/05/03/Icarus%E4%B8%BB%E9%A2%98%E5%A2%9E%E5%8A%A0%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F/"},{"title":"MATH61 Review","text":"Review for Math 61 - Discreted Structures at UCLA 基础知识1.1 集合 Sets Power set: P(x): the set of all subset Collection: Partition: 3.1 函数 Function 单射 injective, one-to-one if f(x1) = f(x2) then x1 = x2 满射 surjective, onto for each y ∈ Y, there exist some x ∈ X where f(x) = y 双射 bijective, one-to-one &amp; onto if f is bijective, f is invertible 2.2 证明 Proof 直接证明 Direct Proof: p true -&gt; q true 反证法 Proof by Contradiction: opposite false Proof by contrapositive: opposite q -&gt; opposite p 分类讨论 Proof by Cases: different situations 数学归纳法 Mathematical Induction Basis step: S(n0) is true. Inductive step: 假设S(n)成立，将公式带入S(n+1)，推出S(n+1)成立。 For each n &gt;= n0, if S(n) is true, S(n+1) is true 序列与字符串 Sequence and Strings Properties： 单调递增 increasing 单调递减 decreasing 非增 nonincreasing 非减 nondecreasing Closed formula for S: I = [i, j], {Sk}jk=i(j -&gt; max) subsequence operation: 连加 ∑，连乘 Π string: finite sequence of char, length |a|, concatnation, substring (consective) 关系 Relations subset of X×Y, xRy reflective: if xRx symmetric: if xRy, then yRx antisymmetric: if for all x, y ∈ X, if xRy and yRx, then x=y 证明: if x!=y, then either (x, y) !∈ to R or (y, x) !∈ R transitive: for all x, y, z ∈ X, if(x, y), (y, z) ∈ R, then (x, z) ∈ R partial order: 同时满足 Refelective, Antisymmetric, Transitive total order: if each (x, y) ∈ X are comparable Inverse(R-1) = {(y|x) | xRy } ⊆ Y×X 等价关系 Equivalence Relations 同时满足 Reflective, Symmetric, Transitive equivalence classes: Partition of X: [a] = {x∈X | xRa} S = {[a] | a∈X} |{equivalence}| = |{partitions}| Relation Matrix: if has relationship = 1. otherwise = 0 Chapter 6. Counting method and Pigeonhole Principle6.1 计数原理 Counting Principles Mutiplication Principle Prove if |x| = n, then |P(x) = 2n| Addition Principle: Inclusion-Exclusion Principle: 6.2 排列组合 Permutations &amp; Combinations P(n, r) = n!/(n-r)! C(n, r) = P(n, r)/r! = n!/(n-r)!r! Cn = [1/(n+1)]*C(2n, n) -&gt; catalan numbers k-elements selection from x (with t elements) allow repetition C(k+t-1, t-1) = C(k+t-1, k) 6.7 二项式定理 Binomical Coefficient proof equations directly (a + b)n = ∑C(n, k)an-kbk Proof by cancelling C(n+1, k) = C(n, k-1) + C(n, k) Compute coefficient: C(n, k) 6.8 鸽子洞定理 Pigeonhole Principle if f: X-&gt;Y where X, Y finite and |X| &gt; |Y|, then f(x1) = f(x2) for some x1, x2 ∈ X where x1 != x2 |X| = n and |Y| = m, let k = ⌈n/m⌉, then there are at least k distinct values a let f(a) are equal Chapter 7 Recurence Relations7.1 递推关系 Recurrence Relations String doesn’t contain the pattern “111” Tower of Honoi Find closed formula for an 常系数线性递推公式 Linear Homogeneous Recurrence Relations of Order with Constant Coefficients (LHRC) an = c1an-1 + c2an-2 + … + ckan-k where ck != 0 ex Fibonacci numbers fn = fn-1 + fn-2 is a LHRC of order 2 Sn = 2Sn - 1 is a LHRC of order 1 How to solve LHRC? t2-c1t - c2解出两个根r1和r2 an = br1n+dr2n， n &gt;= 0 带入b+d = c0 and br1 + dr2 = c1 如果是repeated root -&gt; an = brn+dnrn, n &gt;= 0 Chapter 8 图论 Graph Theory8.1 图 Examples of Graphs 完全图 Complete grpah: Kn 二分图 Bipartite graph 完全二分图 Complete bipartite graph: Kn,m 8.2 路径与环 Path &amp; Circle Connected: 所有的边在一起组成一个graph Component: 连接在一起的顶点和边的集合 G is connected if G has only 1 component 欧拉环 Eulerian Cycle A cycle in G that includes each edge + vertex in G is called an Eulerian Cycle 一笔画问题 欧拉环的总度数是边的二倍 G has a path with no repeated edges from v to w containing all vertices + edges &lt;==&gt; G is connected + v, w are the only vertices in G with odd degree If G contains a cycle from v to v, G contains a simple cycle from v to v 哈密顿环 Hamiltonian Cycles A cycle in G that contains each v exactly once is a Hamiltonian cycle Proof no Hamiltonian Cycles compute |V(G)| = n, |E(G)| = m find largest S ⊆ V(G) such that v1, v2 ∈ S =&gt; (v1, v2) !∈ E(G) + d(v) &gt; 2 for v ∈ S if m - ∑(d(v)-2)&lt; n (# edges needed for H.cycle), then no H.cycle Degree Sequence nonincreasing order 证明degree sequence无法构成G Shortest-Path Algorithm Dijkstra算法: 123456789101112dijkstra (w, a, z, L){ L(a) = 0; for all vertices x != a: L(x) = max T: set of all vertices while(z ∈ T){ choose v ∈ T with min L(v) T = T - {v} for each x ∈ T adjacent to v L(x) = min {L(x), L(v) + w(v, x)} }} 图的表示方法 Representations of Graphs 邻接矩阵 adjacency matrices: if two vertices have edge = 1. otherwise = 0 矩阵的n次方等于以i, j为起点的长度为n的路径的数量 图的同构 Isomorphisms of Graphs 如果我们可以找到一组对应关系，使得两个图G与G’上的每个顶点与每条边一一对应，则G与G’是同构关系。 同构是等价关系 两个图同构 &lt;==&gt; 调换顶点顺序，两个图的邻接矩阵相同 如何证明两个图不同构？ use invariants to detect when graphs are not isomorphic 平面图 Planar Graphs 可以画成边不交叉的图叫做平面图 面 Faces: 由平面图切割的区域叫做面 f = e - v + 2: 面数 = 边数 - 顶点数 + 2 因此，如果G不满足此条件，则G不是平面图 Series Reduction 减去顶点v并减去其两条边，然后将连接的两个顶点相连接 图的同胚 Homeomorphic 通过series reduction进行减去顶点，如果能将两个图变为同构的，则二者同胚。 同胚是等价关系 平面图判断 Kuratowski Planar Graph &lt;==&gt; G does not contain a subgraph homeomorhpic to K5 or K3, 3 树 Tree simple graph, 且两点之间只有一个simple path rooted tree 树高 height 从0开始算 Every tree with 2 or more movertices has a vertex of degree 1 Tree is a bipartite graph More trees 树的属性: parent ancestors child descendant siblings terminal vertex/leaft internal vertex subtree of T rooted at x graph with no cycles is called acyclic if T is a tree, T is acyclic + connected 下面四个关系是等价的： T is a tree T is connected &amp; acyclic T is connected &amp; |E(T)| = n -1 T is acyclic &amp; |E(T)| = n - 1 生成树 Spanning Trees subgraph T of G such that T is a tree where V(T) = V(G) is called a spanning tree of G G存在生成树 &lt;==&gt; G是连通图 如何找到生成树？ BFS DFS 计算完全图的subgraph数量 用组合C求出总量 注意需要除以重复的环 如果对称，需要除以2 最小生成树 Minimal Spanning Trees MST: 在weighted graph G中，最小生成树的边加权最小 123456789101112131415prim (w, n, s): initialize all v(i) = 0, E = Ø update v(s) = 1 for i = 1 to n - 1: min = max for j = 1 to n: if ( v(j) = 1 ): for k = 1 to n: if v(k) = 0 and w(j, k) &lt; min: set k to be addable vertex e = (j, k) min = w(j, k) update v(addable vertex) = 1 update E = E∪e return E 二叉树 Binary Trees 满二叉树 full binary tree each vertex has 0 or 2 children if a full binary tree T has i internal vertices, then T has i + 1 terminal vertices &amp; 2i+1 total vertices 证明：V(T) = 2i + 1 比赛场数可以用满二叉树计算： 比赛场数（internal vertices）= 队伍总数（terminal vertices）- 1 可组合的可能性：2# internal vertices 二叉树的树高为h，且有t个terminal vertices，则log2t &lt;= h 树的同构 Isomorphisms of Trees 普通树的同构： 5个顶点的树有3种不同构的组合 Proof by cases，从可能的最高度数到最低度数，通过度数证明 Rooted Tree的同构： rooted trees如果同构，则两者的root必须相同 4个顶点的rooted trees有4种不同构的组合 二叉树的同构： 二叉树如果同构，则两者的左子节点与右子节点必须对应 3个顶点的二叉树有5种不同的同构方式 由n个节点组成的二叉树不同构的数量Cn Cn = [1/(n+1)]*C(2n, n) -&gt; catalan numbers 123456789101112bin_tree_isom(r1, r2){ if(r1 == null &amp;&amp; r2 == null) return true if (r1 == null &amp;&amp; r2 != null || r1 != null &amp;&amp; r2 == null) return false lc_r1 = left child of r1 lc_r2 = right child of r2 rc_r1 = right child of r1 rc_r2 = right child of r2 if(bin_tree_isom(lc_r1, lc_r2) == True &amp;&amp; bin_tree_isom(rc_r1, rc_r2) == True) return true else return false }","link":"/2022/12/04/MATH61-Review/"},{"title":"Math 33 Review","text":"Review for Math 33 - Linear Algebra at UCLA Homework 1: 增广矩阵 Augmented matrix： sovling system equations 简化行阶梯形 Reduced Row Echelon Form Homework 2: 秩 Rank： 自由元 Free variable： finding all possible numbers for variables 线性变换 Linear transformation： determining weather a function is linear 线性变换判断方法： if (v, w) in R =&gt; T(v + w) = T(v) + T(w) =&gt; T(av) = aT(v) Homework 3: 变换矩阵 Transformation matrix： finding the matrix of linear transformation (M) 矩阵乘法 Matrix multiplication： 子空间 Subspace: 子空间判断方法与判断矩阵是否是linear相近： if (v, w) in S =&gt; (v + w) in S =&gt; av in S 线性生成空间 Span: 判定w是否在span中： could we find a*v1 + b*v2 + … +n*vn = w in span{v1…vn} using augemented matrix to solve the problem Homework 4: 线形独立 linearly independent： determining weather a matrix M is linearly independent RREF 核 Kernal： kernal(M) -&gt; sending all vectors to 0 象 Image： image(M) -&gt; equivalent to the span of the columns of M 逆 Inverse： 逆矩阵与矩阵操作后原矩阵不变：A = M-1MA 判断一个矩阵是否可逆： determining whether a matrix M is invertible: 方形矩阵 Square matrix 满秩 Full rank 行列式不为零 det(M) != 0 Calculating the invert matrix: 高斯消元法 finding basis Homework 5: 寻找T的象的线性组合空间 finding image(T) = span(v1, v2, ….vn): image(T) = span{col(T)} -&gt; col(T) = {v1, v2, …vn} 基 Basis : standard basis： finding w that perpendicular to vectors span{v1 … vn}: (v1 · w) = 0, (v2 · w) = 0, … (vn · w) = 0 在以B = {b1, b2, …bn}为基的坐标系中表示向量w： 将w分解为基向量之和 (a * b1) + (b * b2) + … + (n * bn) 将factors组成一个新的col向量[a, b, … n] 相似变换矩阵 Similar matrix: 同一个线性变换，不同基下的矩阵，称为相似矩阵 求以B为基的坐标系的相似变换矩阵 B-matrix： B = S-1TS（以B为基的坐标系的变换矩阵） find the matrix of the linear transformation defined by T(v) = w with respect to the basis {b1, b2, … bn} 将bn带入T()，得到变化后的wn 分解wn为aw1 + bw2 + … + nwn 将factors的解组成一个新的col向量 B-matrix = [col1, col2, … coln] let T: R3 -&gt; R3 be the orthogonal projection onto the line spanned by [1 1 1]. Find a basis for which this projection matrix is diagonal Homework 6: 正交 orthogonal： 矩阵A是否正交判断：AT = A-1 正交矩阵的行列式永远等于+-1 标准正交基 Orthonormal： 所有基向量两两正交 所有基向量模长为1 正交投影 Orthogonal Projection： 正交投影公式： 注意：投影的两个基向量必须是标准正交基 projspan{u, v}w = projuw + projvw projvw = [(u · v)/(v · v)]v QR分解 QR factorization (Gram–Schmidt process)： 首先将第一个向量w1单位化 v = w1 / ||w1|| (第一个向量v等于第一个原有向量w1除以其模长) 然后将第二个向量w2标准正交化： u = (w2 - projvw2) / ||(w2 - projvw2)|| （第二个向量u等于第二个原有向量w2减去w2在向量v上的投影除以其模长） 最后将第三个向量w3标准正交化： t = (w3 - projspan{v, u}w3) / ||(w3 - projspan{v, u}w3)|| （第三个向量u等于第三个原有向量w3减去w3在平面span{v, u}上的投影除以其模长） Homework 7: 正交补空间 V⊥: find a basis for the subspace V⊥： 首先找到矩阵M，令V是M的象。因此我们需要解关于V的增广矩阵以得到V = span{col(M)}： let M = [v1, v2, … vn] for vi in V V = image(M) : (V = image(M) = span{col(M)}) 正交补空间中的向量与原空间中所有的向量垂直： 因此(w in V⊥), (v in V) -&gt; v · w = 0 V⊥ = ker(MT): w · v = MTV⊥ = 0 (MT = span{row(M)}) 解关于ker(MT)的增广矩阵，得到所有可以组成V⊥的向量 取一组自由元作为V⊥的标准基，得到basis(V⊥) 最小平方法 Least squares method： find least-squares solution x*（最小平方解） of the system: ATAx* = ATb 行列式 Determinant： 如果M将原有空间volume放大n倍，则det(M) = n 如果det(M) = 0，则原有空间被降维，因此此时不可逆 Homework 8: 初等变换 Elementary transformation： 当某一行row加到另一行row2时，行列式不变：det(M’) = det(M) 当某一行row被放大n倍时，行列式放大n倍: det(M’) = n * det(M) 当交换两个row时，行列式取负值：det(M’) = -det(M) 行列式计算技巧： det(M) = RREF后的对角线的值相乘 det(M) = 0, if M linearly depandent det(M) = det(MT) 特征值 Eigenvalues λ 与特征向量 Eigenvector： 在M对原有空间进行线性变换时，存在一些向量（特征向量）只发生了倍数变换（Mv = λv）。 求解特征值：det(M-λI) = 0 特征值可以为0，但特征向量不能为0 不可逆方程必有特征值0 平行六面体 Parallelepiped的volume计算: 将基向量变换到对应的顶点坐标，得到变换矩阵T 计算|det(T)| Homework 9: 特征基 eigenbasis: 由矩阵的特征向量组成的一组基 解出特征值，得到特征向量，带入值，组成基 特征空间 eigenspace 特征空间的维度决定了是否能找到矩阵的特征基，只有特征空间的维度等于矩阵的维度，才能找到特征基。 对角化 对角化的本质是将当前矩阵M的基变更为其特征基 以特征基作为矩阵新的基，新的基可以组成变换矩阵S 将特征基向量v与矩阵M进行乘法，得到变换后的向量位置 将向量分解为特征基的加和w 将factors的解组成一个新的col向量 B-matrix = [col1, col2, … coln] 对角化矩阵M = SM’S-1,（该操作是相似变换矩阵的逆运算） 对角化矩阵的对角线是特征值 矩阵乘方 先将矩阵M对角化为M’ 计算M’的乘方，直接将对角线上的数值乘方 M = SM’S","link":"/2022/11/20/Math-33-Review/"},{"title":"Portfolio","text":"Click image to demonstrate in Fullscreen Mode.","link":"/portfolio.html"},{"title":"Recursive Relation, LHRC, Honoi Tower","text":"Find closed formula for an. Iteration (Proof by Induction) Linear homogeneous recursive relation with constant coefficiens (LHRC)find the roots of equation t2+c1t+C2then where exist constants b, d such that an = br1n+dr2n, for n &gt;= 0 Recursive Relation, Honoi Tower, LHRC","link":"/2022/11/06/Recursive-Relation-LHRC-Honoi-Tower/"},{"title":"UCLA Fall: Augmented Reality Behavior","text":"Course DescriptionThis past fall, Anyone Corporation (most notable for their journal Log) presented an exhibit titled Model Behavior. The director of Anyone Corporation, Cynthia Davidson said that “Models, whether physical or digital, are intrinsic to architecture. Just as other fields, such as science, mathematics, politics, and economics use models to visualize, reflect, and predict behaviors, so do architectural models…Model Behavior interrogates how architectural models elicit and project social behaviors. Objects on view represent a multitude of disciplines ranging from toys and scientific models to traditional physical architectural models.”1 Among model types investigated is augmented reality (AR), which is represented by wa.k studio’s 4 Square House model. The AR portion of the model allows users to change light and season, use a camera clipping plane to cut an angled section, as well as view the house’s inhabitants: a tree and animated agent. Course ObjectivesTo experiment and investigate modeling potentials offered by augmented reality. To think independently and critically. To gain insight into the interplay between digital and physical. Develop competency in Unity3d using C#. Understand game development concepts. Utilize Augmented Reality packages to deploy apps to mobile devices. Critically and creatively engage with new technology. Theorize AR models through written and visual means.","link":"/2023/03/31/UCLA-Fall-Augmented-Reality-Behavior/"},{"title":"Unity: Move, Camera Tracking, Animator","text":"最近跟着网络上的课程班学习了一些Unity的使用，记录一下自己的学习心得。 移动：Move实现角色的移动需要在Update方法里对物体的位置进行更新。 Unity支持数学公式，角色控制器以及刚体等移动方式。而每种方式又有不同的子方法。 旋转：Rotation我们先要根据input获取键盘上对应的操作命令。如果水平和垂直数值均为0，则直接返回，不进行下面的更新命令。 将输入的方向新建为一个向量。然后将其转换为一个四元数，通过rotation方法对角色进行旋转。 12345678910float h = Input.GetAxis(&quot;Horizontal&quot;); float v = Input.GetAxis(&quot;Vertical&quot;); m_anim.SetBool(&quot;bMove&quot;, h != 0 || v != 0); if (h == 0 &amp;&amp; v == 0) return; Vector3 dir = new Vector3(-h, 0, -v); Quaternion targetQ = Quaternion.LookRotation(dir, Vector3.up); //transform.rotation = targetQ; transform.rotation = Quaternion.Lerp(transform.rotation, targetQ, Time.deltaTime * mfRoateSpeed); //对四元数进行插值，控制旋转速度 数学公式：Math Function我们可以直接以数学公式的方法更新当前位置，将其加入向量乘以帧时间乘以速度的方式更新当前位置：transform.position += transform.forward * Time.deltaTime * mfMoveSpeed; 也可以使用Translate()方法，注意这里需要传入world空间模式transform.Translate(transform.forward * Time.deltaTime * mfMoveSpeed, Space.World); MoveTowards方法，不太常用。transform.position = Vector3.MoveTowards(transform.position, transform.position + transform.forward * Time.deltaTime * mfMoveSpeed, Time.deltaTime * mfMoveSpeed); 角色控制器：Character Controller这种模式需要在全局变量中创建并获取角色控制器对象。使用角色控制器需要设定其盒子范围。 1234567m_characterController = transform.gameObject.GetComponent&lt;CharacterController&gt;(); if(m_characterController == null) { m_characterController = transform.gameObject.AddComponent&lt;CharacterController&gt;(); } m_characterController.center = new Vector3(0f, 0.6f, 0f); m_characterController.height = 1.3f; 我们也可以使用角色控制器移动角色。 Simple Move模式可以直接模拟重力：m_characterController.SimpleMove(transform.forward * mfMoveSpeed); 注意Simple Move模式下按秒进行移动，不需要乘以帧时间。 Move模式则需要手动添加向下的重力，否则物体Y轴移动后不会下降。m_characterController.Move(-transform.up * Time.deltaTime * mfMoveSpeed);m_characterController.Move(transform.forward * Time.deltaTime * mfMoveSpeed); 刚体：Rigidbody首先需要在全局变量中创建并获取刚体对象。 刚体模式需要创建碰撞盒，并且将Y轴freeze，否则物体会直接向下落下。 1234567891011m_rigidbody = transform.gameObject.GetComponent&lt;Rigidbody&gt;(); if(m_rigidbody == null) { m_rigidbody = transform.gameObject.AddComponent&lt;Rigidbody&gt;(); } m_rigidbody.constraints = RigidbodyConstraints.FreezePositionY | RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationY | RigidbodyConstraints.FreezeRotationZ; CapsuleCollider collider = transform.gameObject.AddComponent&lt;CapsuleCollider&gt;(); collider.center = new Vector3(0f, 0.6f, 0f); collider.height = 1.3f; 可以采用恒速的velocity方法m_rigidbody.velocity = transform.forward * mfMoveSpeed; 或者采用AddForce方法，这样会不断加速。m_rigidbody.AddForce(transform.forward * mfMoveSpeed * mAddForceFactor); MovePosition方法，同样是直接计算移动后的位置。m_rigidbody.MovePosition(transform.position + transform.forward * Time.deltaTime * mfMoveSpeed); 镜头跟随：Camera Tracking脚本需要挂在到相机下。 两个向量相减的几何意义是减数方向指向被减数方向。 用相机位置减去玩家的位置，则可以得到玩家指向相机的向量。然后在Update中实时更新相机的位置，就可以实现镜头跟随的效果。 12345678910111213141516171819202122using System.Collections;using System.Collections.Generic;using UnityEngine;public class MainCamera : MonoBehaviour{ private Transform m_player; //需要聚焦的角色的位置 private Vector3 m_v3RelativePos; //相机和角色的相对向量 // Start is called before the first frame update void Start() { m_player = GameObject.FindGameObjectWithTag(&quot;Player&quot;).transform; //获取玩家角色 m_v3RelativePos = transform.position - m_player.position; //计算相对位置 } // Update is called once per frame void Update() { transform.position = m_player.position + m_v3RelativePos; //实时更新相机的位置 }} 动画状态机：Animator 模型下需要有Anim模块才能实现动画。原有的资源里已经制作了动画，在这里额外实现的是根据动作来切换动画。 在Start()里初始化成员变量Animator m_anim。m_anim = transform.Find(&quot;Anim&quot;).GetComponent&lt;Animator&gt;();然后在Update()里使用SetBool方法对Animator的开关真值进行更新。m_anim.SetBool(&quot;bMove&quot;, h != 0 || v != 0); Animator支持几种类型的trigger如Bool，Int，","link":"/2022/05/13/Unity-Move-Camera-Tracking-Animator/"},{"title":"Unity: Trigger, Collider, UI &amp; NPC Interaction","text":"触发器与碰撞器 Trigger &amp; Collider: Unity中的物体可以根据双方的触发器与碰撞器产生交互。触发器与碰撞器有三种不同的状态，Enter，Stay与Exit。 12345678//触发器事件, Tiggerprivate void OnTriggerEnter(Collider other)private void OnTriggerStay(Collider other)private void OnTriggerExit(Collider other)//碰撞器事件, Collisionprivate void OnCollisionEnter(Collision collision)private void OnCollisionStay(Collision collision)private void OnCollisionExit(Collision collision) 不同的移动方法与触发器和碰撞器产生的交互也不相同： Math Function: 遇到目标即使是碰撞器，依然穿透 不管自身是否是碰撞器或者触发器，当它接触到目标的时候（碰撞器/触发器），此时交互没有反应 Character Controller: 碰撞器：有阻挡效果，没有办法接收碰撞器Collision事件 触发器：可穿透，可以接收Tigger事件 Rigidbody: 刚体自身的Collider如果是碰撞器，则只响应碰撞器事件。 刚体自身的Collider如果是触发器，则同时响应碰撞器和触发器事件。 角色交互 NPC Interaction:实现角色之间的交互，当玩家接近NPC时，NPC会面向玩家。当玩家远离NPC时，NPC会回归自己的朝向。 当NPC的触发器与玩家接触时（Enter），调用OnTriggerEnter()，修改枚举状态。计算NPC到玩家的方向向量，将NPC旋转指向玩家。 当NPC的触发器与玩家分离时（Exit）， 调用OnTriggerExit()，修改枚举状态。将NPC的方向恢复到原有的方向向量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081using System.Collections;using System.Collections.Generic;using UnityEngine;public class NPC : MonoBehaviour{ public enum emTriggerType { None, Enter, Exit, } private Transform m_tfPlayer; private emTriggerType m_emTriggerType; private float m_fRotateSpeed; private float m_fTimer; private Quaternion m_srcRotation; // Start is called before the first frame update void Start() { m_tfPlayer = GameObject.FindObjectOfType&lt;Player&gt;().transform; m_emTriggerType = emTriggerType.None; m_fRotateSpeed = 3f; m_fTimer = 0f; m_srcRotation = transform.rotation; SphereCollider trigger = transform.gameObject.AddComponent&lt;SphereCollider&gt;(); trigger.isTrigger = true; trigger.radius = 10f; } // Update is called once per frame void Update() { if(m_emTriggerType == emTriggerType.Enter) { //玩家位置减去NPC位置，得到非单位化的向量dir，几何意义是NPC指向玩家位置的方向向量 Vector3 dir = m_tfPlayer.transform.position - transform.position; Quaternion targetQ = Quaternion.LookRotation(dir, Vector3.up); transform.rotation = Quaternion.Lerp(transform.rotation, targetQ, Time.deltaTime * m_fRotateSpeed); m_fTimer += Time.deltaTime; //计时器 if (m_fTimer &gt;= 1f) { m_emTriggerType = emTriggerType.None; //置空占位 m_fTimer = 0; } } else if(m_emTriggerType == emTriggerType.Exit) { transform.rotation = Quaternion.Lerp(transform.rotation, m_srcRotation, Time.deltaTime * m_fRotateSpeed); m_fTimer += Time.deltaTime; if (m_fTimer &gt;= 1f) { m_emTriggerType = emTriggerType.None; m_fTimer = 0; } } } private void OnTriggerEnter(Collider other) { if (other.transform != m_tfPlayer) return; m_emTriggerType = emTriggerType.Enter; //Debug.Log(&quot;Trigger enter&quot;); //弹出对话 } private void OnTriggerExit(Collider other) { if (other.transform != m_tfPlayer) return; m_emTriggerType = emTriggerType.Exit; //Debug.Log(&quot;Trigger exit&quot;); //关闭对话 }} UI元素添加 UI Component:添加UI组件：调用Resource下的相对路径文件。导入UnityEngine.UI包。 将UI对象实例化，并挂载到附节点上。从Resource中获得Text，Image等UI对象。 根据场景决定显示NPC名字还是HP血条。 在进行显示时，需要将NPC和玩家的世界坐标系位置转化到屏幕坐标系，将名字显示在屏幕。 12345678910111213141516171819202122232425262728293031323334353637383940using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; //UI的命名空间public class Unity_Entity : MonoBehaviour{ private GameObject m_objModel; private Text m_txtCharacterName; private GameObject m_objHPBar; private Image m_imgHP; public Vector3 mv3Offset; // Start is called before the first frame update void Start() { GameObject uiUnit = Resources.Load&lt;GameObject&gt;(&quot;Prefabs/UI/Unit_Entity&quot;); //获取UI单元 uiUnit.SetActive(false); mv3Offset = new Vector3(0f, 2f, 0f); m_objModel = Instantiate&lt;GameObject&gt;(uiUnit); //实例化对象 m_objModel.transform.parent = GameObject.Find(&quot;UnitEntityRoot&quot;).transform; //将对象添加到附节点 m_txtCharacterName = m_objModel.transform.Find(&quot;Context/txtCharacterName&quot;).GetComponent&lt;Text&gt;(); //获取名称 m_objHPBar = m_objModel.transform.Find(&quot;Context/HPBar&quot;).gameObject; m_imgHP = m_objModel.transform.Find(&quot;Context/HPBar/hp&quot;).GetComponent&lt;Image&gt;(); //获取血条图片资源 m_txtCharacterName.text = this.gameObject.name; m_objHPBar.SetActive(!SceneManager.Instance.isMainScene); //不在主场景时才激活血条 } // Update is called once per frame void Update() { m_objModel.transform.position = Camera.main.WorldToScreenPoint(this.transform.position + mv3Offset); //从世界坐标系转换为屏幕坐标系，将血条显示在屏幕上 }} 为了判断我们的场景，我们需要创建一个SceneManager并挂载到Manager上。当当前场景是主场景时返回true。 场景判断：12345678910111213141516171819202122232425262728using System.Collections;using System.Collections.Generic;using UnityEngine;public class SceneManager : MonoBehaviour{ public static SceneManager Instance; public bool isMainScene { get //get和set可以封装public的field(Member Variable) { UnityEngine.SceneManagement.Scene curScene = UnityEngine.SceneManagement.SceneManager.GetActiveScene(); //由于Unity已经有ScenceManager类，因此需要额外注明命名空间 return curScene.name == &quot;MainScene&quot;; } } // Start is called before the first frame update void Awake() //Awake的执行顺序优先于Start() { Instance = this; } // Update is called once per frame void Update() { }}","link":"/2022/05/14/Unity-Trigger-Collider-UI-NPC-Interaction/"},{"title":"Unreal World Building","text":"Unreal Engine 5.0Using the Unreal Engine 5.0, we can create highly immersive and detailed virtual worlds with stunning graphics and realistic physics. With the ability to render and generate animations, we can bring virtual worlds to life, creating engaging and interactive experiences for a wide range of applications, from video games to architectural visualizations. AI Style MigrationAI video style migration offers exciting new possibilities for world building and animation. By using AI algorithms to migrate the style of one video to another, architects can quickly and easily create unique and visually striking animations with a fraction of the time and effort it would take with traditional animation methods. The combination of the Unreal engine and AI video style migration provides a powerful toolset for creatives looking to push the boundaries of world building and animation. From immersive video games to stunning architectural visualizations, this powerful combination offers endless possibilities for creatives looking to create innovative and engaging virtual experiences.","link":"/2023/04/02/Unreal-World-Building/"},{"title":"Yunggh Project","text":"GithubBIMFAM/yunggh1. WaveFunctionCollapse2. Marching Cubes3. Quadrilateral Grids4. Polar Convexity5. Straight Skeleton6. Medial Axis7. Erosion8. Minimum Bounding Rectangle C# on GrasshopperGrasshopper is a visual programming language extension for Rhino, a 3D modeling software widely used in architecture. Architects and designers can use Grasshopper to create parametric models and design workflows using a graphical interface, which simplifies the manipulation and experimentation with complex geometries.C# is a programming language that can be used to create custom components in Grasshopper. With C#, architects can extend Grasshopper’s functionality and create their own tools for modeling, analysis, and optimization. For example, architects can write C# scripts to automate repetitive tasks, create complex geometric forms, and analyze design performance.Together, Grasshopper and C# provide architects with a powerful and flexible design toolset that can improve their design process, increase efficiency, and enable them to create more innovative and optimized designs. Wave Function Collapse The Wavefunction Collapse Algorithm explained very clearly | Robert Heaton I contributed Yungh by writing Grasshopper scripts in C#. The Wave Function Collapse algorithm generates rhythmic patterns based on a set of rules. This algorithm has various applications, such as creating game maps, architectural designs, and images. Marching Cubes Polygonising a scalar field (Marching Cubes) Additionally, I used the Marching Cubes algorithm to resample the model based on specific parameters and reduce its vertex count, which could be helpful for rebuilding models or generating stylized architectures. Quadrilateral Grids Quadrilateral Grids can generate segmented quadrilateral meshes based on point clouds, which are useful for urban planning and street generation in games. Polar Convexity Polar Convexity can create divergent rays from one point, which can be used to analyze the lighting effects and spatial layout of buildings. Medial Skeleton, Straight Skeleton &amp; Erosion Lastly, Medial Axis, Skeleton, and Erosion are plugins that create suitable building ridges based on different curves. All of these tools are part of the Yungh open-source project and are designed to increase efficiency and reduce repetitive tasks for architects. The code is available on GitHub.","link":"/2023/02/28/Yunggh-Project/"},{"title":"post title","text":"Heading level 1 Heading level 1Heading level 1 Heading level 2 Heading level 2Heading level 2 Heading level 3 Heading level 3Heading level 3 Heading level 4 Heading level 4Heading level 4 Heading level 5 Heading level 5Heading level 5 Heading level 6 Heading level 6Heading level 6","link":"/2022/03/30/post-title/"},{"title":"测试一下","text":"我想测试一下这篇文章能否正常的发送标题结尾斜体","link":"/2022/03/30/%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B/"},{"title":"使用Blender生成Avatar并添加动作","text":"拍摄并处理照片拍摄正面照片，手脚需要分开，背景可以用PS修改为白色，方便软件后期处理。 使用PIFuHD生成模型文件PIFuHD Demo - Colaboratory (google.com) 通过这个库来处理照片文件。处理完毕后得到OBJ文件和PNG文件。 使用Blender为模型添加材质打开Blender，将OBJ文件导入。选择UV Editing，在UV界面加载之前处理过的PNG文件， 首先将OBJ文件的正面向前。然后选择UV-Project from View。此时会将模型上的控制点映射到UV窗口中。然后通过Scale，Move等工具将正面贴图与控制点相匹配。如果出现双面人脸，可以通过调整部分控制点使材质隐藏。 再Material Properties一栏中的base color选择Image Texture。载入人物正面图片即可。 导出为FBX文件。 使用Mixamo为模型添加动作将文件上传到Mixamo，选择不同动作，即可为自己的模型添加各种动作。","link":"/2022/08/04/%E4%BD%BF%E7%94%A8Blender%E7%94%9F%E6%88%90Avatar%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%8A%A8%E4%BD%9C/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"每日一题","slug":"每日一题","link":"/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Sort","slug":"Sort","link":"/tags/Sort/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"Eureka!","slug":"Eureka","link":"/tags/Eureka/"},{"name":"Hash Map","slug":"Hash-Map","link":"/tags/Hash-Map/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/tags/Binary-Tree/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"Deque","slug":"Deque","link":"/tags/Deque/"},{"name":"Priority Queue","slug":"Priority-Queue","link":"/tags/Priority-Queue/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Binary Search","slug":"Binary-Search","link":"/tags/Binary-Search/"},{"name":"Matrix","slug":"Matrix","link":"/tags/Matrix/"},{"name":"其他解法？","slug":"其他解法？","link":"/tags/%E5%85%B6%E4%BB%96%E8%A7%A3%E6%B3%95%EF%BC%9F/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"Backtracking","slug":"Backtracking","link":"/tags/Backtracking/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"Disjoint Set","slug":"Disjoint-Set","link":"/tags/Disjoint-Set/"},{"name":"Union Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Memoization","slug":"Memoization","link":"/tags/Memoization/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"回文","slug":"回文","link":"/tags/%E5%9B%9E%E6%96%87/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","link":"/tags/Bit-Manipulation/"},{"name":"双向遍历","slug":"双向遍历","link":"/tags/%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86/"},{"name":"Renamed","slug":"Renamed","link":"/tags/Renamed/"},{"name":"双参数","slug":"双参数","link":"/tags/%E5%8F%8C%E5%8F%82%E6%95%B0/"},{"name":"快慢指针","slug":"快慢指针","link":"/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"Sliding Window","slug":"Sliding-Window","link":"/tags/Sliding-Window/"},{"name":"Linked List","slug":"Linked-List","link":"/tags/Linked-List/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"掩码","slug":"掩码","link":"/tags/%E6%8E%A9%E7%A0%81/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Directed Acyclic Graph","slug":"Directed-Acyclic-Graph","link":"/tags/Directed-Acyclic-Graph/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"MST","slug":"MST","link":"/tags/MST/"},{"name":"Kruskal","slug":"Kruskal","link":"/tags/Kruskal/"},{"name":"Dijkstra","slug":"Dijkstra","link":"/tags/Dijkstra/"},{"name":"A*","slug":"A","link":"/tags/A/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"投票算法","slug":"投票算法","link":"/tags/%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"},{"name":"Combination","slug":"Combination","link":"/tags/Combination/"},{"name":"GCD","slug":"GCD","link":"/tags/GCD/"},{"name":"双参量","slug":"双参量","link":"/tags/%E5%8F%8C%E5%8F%82%E9%87%8F/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"Queue","slug":"Queue","link":"/tags/Queue/"},{"name":"LeetCode Contest","slug":"LeetCode-Contest","link":"/tags/LeetCode-Contest/"},{"name":"Mask","slug":"Mask","link":"/tags/Mask/"},{"name":"前缀和","slug":"前缀和","link":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"Biweekly Contest","slug":"Biweekly-Contest","link":"/tags/Biweekly-Contest/"},{"name":"原地算法","slug":"原地算法","link":"/tags/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/"},{"name":"LIS","slug":"LIS","link":"/tags/LIS/"},{"name":"Epic Hard","slug":"Epic-Hard","link":"/tags/Epic-Hard/"},{"name":"Permutation","slug":"Permutation","link":"/tags/Permutation/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"Shuffle","slug":"Shuffle","link":"/tags/Shuffle/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"intervals","slug":"intervals","link":"/tags/intervals/"},{"name":"BST","slug":"BST","link":"/tags/BST/"},{"name":"Knapsack","slug":"Knapsack","link":"/tags/Knapsack/"},{"name":"Manacher","slug":"Manacher","link":"/tags/Manacher/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"树形DP","slug":"树形DP","link":"/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"works","slug":"works","link":"/tags/works/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Blender","slug":"Blender","link":"/tags/Blender/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"Linear Algebra","slug":"Linear-Algebra","link":"/tags/Linear-Algebra/"},{"name":"Grasshopper","slug":"Grasshopper","link":"/tags/Grasshopper/"},{"name":"Works","slug":"Works","link":"/tags/Works/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Easy","slug":"LeetCode/Easy","link":"/categories/LeetCode/Easy/"},{"name":"Medium","slug":"LeetCode/Medium","link":"/categories/LeetCode/Medium/"},{"name":"复习","slug":"LeetCode/Medium/复习","link":"/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"复习","slug":"LeetCode/Easy/复习","link":"/categories/LeetCode/Easy/%E5%A4%8D%E4%B9%A0/"},{"name":"Hard","slug":"LeetCode/Hard","link":"/categories/LeetCode/Hard/"},{"name":"复习","slug":"LeetCode/Hard/复习","link":"/categories/LeetCode/Hard/%E5%A4%8D%E4%B9%A0/"},{"name":"Medium","slug":"Medium","link":"/categories/Medium/"},{"name":"复习","slug":"Medium/复习","link":"/categories/Medium/%E5%A4%8D%E4%B9%A0/"},{"name":"Esay","slug":"LeetCode/Esay","link":"/categories/LeetCode/Esay/"},{"name":"Hard","slug":"Hard","link":"/categories/Hard/"},{"name":"复习","slug":"Hard/复习","link":"/categories/Hard/%E5%A4%8D%E4%B9%A0/"},{"name":"Course","slug":"Course","link":"/categories/Course/"},{"name":"Blender","slug":"Course/Blender","link":"/categories/Course/Blender/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"Math","slug":"Course/Math","link":"/categories/Course/Math/"},{"name":"Theme","slug":"Hexo/Theme","link":"/categories/Hexo/Theme/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"Grasshopper","slug":"Grasshopper","link":"/categories/Grasshopper/"},{"name":"Drawing&#x2F;Modelling","slug":"Drawing-Modelling","link":"/categories/Drawing-Modelling/"},{"name":"Blender","slug":"Drawing-Modelling/Blender","link":"/categories/Drawing-Modelling/Blender/"}]}