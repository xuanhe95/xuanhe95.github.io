<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: 复习 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/x.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Stay Foolish, Stay Hungery..."><meta property="og:type" content="website"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://xuanhe95.github.io/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Stay Foolish, Stay Hungery..."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://xuanhe95.github.io/img/og_image.png"><meta property="article:author" content="Xander"><meta property="article:tag" content="studio, blog"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xuanhe95.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xuanhe95.github.io"},"headline":"Hexo","image":["https://xuanhe95.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xander"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/icons/x.png"}},"description":"Stay Foolish, Stay Hungery..."}</script><link rel="icon" href="/img/x.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai-sublime.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/icons/x.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/portfolio.html">Portfolio</a><a class="navbar-item" href="/tags/Works/">Works</a><a class="navbar-item" href="/about.html">About Me</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-sun" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/xuanhe95"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li><a href="/categories/LeetCode/">LeetCode</a></li><li><a href="/categories/LeetCode/Medium/">Medium</a></li><li class="is-active"><a href="#" aria-current="page">复习</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/06/11/1658-Minimum-Operations-to-Reduce-X-to-Zero/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="1658. Minimum Operations to Reduce X to Zero"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-11T19:07:04.000Z" title="6/11/2022, 12:07:04 PM">2022-06-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-11T04:07:52.000Z" title="6/10/2022, 9:07:52 PM">2022-06-10</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">2 minutes read (About 367 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/11/1658-Minimum-Operations-to-Reduce-X-to-Zero/">1658. Minimum Operations to Reduce X to Zero</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>You are given an integer array <code>nums</code> and an integer <code>x</code>. In one operation, you can either remove the leftmost or the rightmost element from the array <code>nums</code> and subtract its value from <code>x</code>. Note that this <strong>modifies</strong> the array for future operations.</p>
<p>Return *the <strong>minimum number</strong> of operations to reduce <em><code>x</code> <em>to <strong>exactly</strong></em> <code>0</code> <em>if it is possible</em></em>, otherwise, return *<code>-1</code>.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>将原有问题的从两边减去一定的值，寻找加和为x的问题转换为寻找滑动窗口中的总和为total - x的新问题。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>初始化当前窗口内的sum，左侧指针left与右侧指针right。<br>每次将一个新的元素nums[right]加入窗口范围。</p>
<p>当当前的sum大于寻找的target，则将nums[left]滑出窗口，更新left与sum的值。</p>
<p>如果当前窗口内的sum等于寻找的target，则更新记录最小操作次数的min。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            total += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> total - x; <span class="comment">//将减去两侧元素并寻找和为x的结果的问题转换为用滑动窗口寻找total - x的结果。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">            sum += nums[right]; <span class="comment">//调整右侧范围，加入新元素到窗口</span></span><br><span class="line">            right++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; sum &gt; target)&#123; <span class="comment">//如果窗口内的和大于目标，则调整左侧范围</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;   <span class="comment">//如果窗口内的和等于目标，则更新最小操作次数</span></span><br><span class="line">                min = Math.min(min, nums.length - (right - left));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/31/29-Divide-Two-Integers/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="29. Divide Two Integers"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-01T00:03:26.000Z" title="5/31/2022, 5:03:26 PM">2022-05-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-31T09:11:16.000Z" title="5/31/2022, 2:11:16 AM">2022-05-31</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">4 minutes read (About 619 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/31/29-Divide-Two-Integers/">29. Divide Two Integers</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers <strong>without</strong> using multiplication, division, and mod operator.</p>
<p>The integer division should truncate toward zero, which means losing its fractional part. For example, <code>8.345</code> would be truncated to <code>8</code>, and <code>-2.7335</code> would be truncated to <code>-2</code>.</p>
<p>Return *the <strong>quotient</strong> after dividing <em><code>dividend</code></em> by *<code>divisor</code>.</p>
<p>**Note: **Assume we are dealing with an environment that could only store integers within the <strong>32-bit</strong> signed integer range: <code>[−2&lt;sup&gt;31&lt;/sup&gt;, 2&lt;sup&gt;31&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;− 1]</code>. For this problem, if the quotient is <strong>strictly greater than</strong> <code>2&lt;sup&gt;31&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;- 1</code>, then return <code>2&lt;sup&gt;31&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;- 1</code>, and if the quotient is <strong>strictly less than</strong> <code>-2&lt;sup&gt;31&lt;/sup&gt;</code>, then return <code>-2&lt;sup&gt;31&lt;/sup&gt;</code>.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>解题思路类似于<a target="_blank" rel="noopener" href="https://https//leetcode.com/problems/powx-n/">快速幂</a>。</p>
<p>使用快速乘法来快速的获得商。</p>
<blockquote>
<p>计算过程相当于：<br>60&#x2F;8 &#x3D; (60-32)&#x2F;8 + 4 &#x3D; (60-32-16)&#x2F;8 + 2 + 4 &#x3D; 1 + 2 + 4 &#x3D; 7</p>
</blockquote>
<p>需要注意的是由于只使用了整数（int）而不是长整数（long）储存数据，因此计算时需要处理各种溢出问题。</p>
<h4 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h4><p>由于采用32位整数记录数字，负数要比正数的值范围大1。<br>因此当divisor为负数时，如果负数为整数最小值，则需要返回对应的整数最大值。</p>
<p>同时，为了在计算时防止整数溢出，因此将被除数与除数统一转为负数计算。（负数的数值比整数范围大）<br>当向下递归时，要保持dividend和divisor的正负性不变。</p>
<h4 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h4><p>只要被除数大于除数，则商至少为1。<br>循环，当被除数大于两倍的除数时，则商的结果可以直接翻倍。</p>
<p>否则将被除数减去当前的除数，然后向下递归新的被除数和除数。<br>最后返回快速乘中计算出的商加上向下递归返回的结果。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span>(divisor == -<span class="number">1</span>) <span class="keyword">return</span> dividend == Integer.MIN_VALUE ? Integer.MAX_VALUE : -dividend; <span class="comment">//当dividend为最小整数时，其负数溢出，此时返回Integer.MAX_VALUE</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> dividend, b = divisor;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> || a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;   <span class="comment">//记录除数与被除数是否同号</span></span><br><span class="line">        <span class="keyword">if</span>(dividend &gt; <span class="number">0</span>) a = -a;    <span class="comment">//将除数与被除数转换为负数，因为负数能记录的数值比正数大1，防止溢出</span></span><br><span class="line">        <span class="keyword">if</span>(divisor &gt; <span class="number">0</span>) b = -b;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//被除数小于除数时返回0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &lt;= b+b &amp;&amp; b+b &lt; <span class="number">0</span>)&#123; <span class="comment">//算法核心，快速乘法</span></span><br><span class="line">            b += b; <span class="comment">//除数每次翻倍，直到大于被除数</span></span><br><span class="line">            res += res; <span class="comment">//商的结果翻倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = sign == <span class="number">1</span> ? res : -res;   <span class="comment">//根据是否同号记录商</span></span><br><span class="line">        </span><br><span class="line">        divisor = dividend &gt; <span class="number">0</span> ? -divisor : divisor;  <span class="comment">//当原有被除数是正数时，要将除数取反</span></span><br><span class="line">        <span class="keyword">return</span> res + divide(a-b, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/29/318-Maximum-Product-of-Word-Lengths/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="318. Maximum Product of Word Lengths"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-29T22:17:36.000Z" title="5/29/2022, 3:17:36 PM">2022-05-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-29T07:18:00.000Z" title="5/29/2022, 12:18:00 AM">2022-05-29</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">2 minutes read (About 373 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/29/318-Maximum-Product-of-Word-Lengths/">318. Maximum Product of Word Lengths</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given a string array <code>words</code>, return <em>the maximum value of</em> <code>length(word[i]) * length(word[j])</code> <em>where the two words do not share common letters</em>. If no such two words exist, return <code>0</code>.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>正常的思路可能是用哈希表保存字符串中出现过的字符。此时表的大小是26也是一个常数。</p>
<p>我们可以采用位运算进行状态压缩，通过一个整数的二进制位保存二十六个字符的存在状态。</p>
<h4 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h4><p>我们采用一个整数数组bin[]储存状态压缩后的整数。</p>
<p>遍历每个字符串，在字符串中遍历每一个字符。<br>初始化整数bit为0。在遍历字符时计算当前字符与字符’a’距离的差n，然后将1左移n位，填入（或运算）整数bit中。</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>遍历words[]中的两个字符串，当bin[i]与bin[j]进行与运算结果为0时，则两个字符串没有共同字符。<br>此时更新二者长度乘积的最大值max。</p>
<p>最后返回max即可。</p>
<p>时间复杂度：O(L + n2)。L为所有字符的总长度。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> bin[] = <span class="keyword">new</span> <span class="title class_">int</span>[words.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; words[i].length(); j++)&#123;</span><br><span class="line">                bit |= (<span class="number">1</span> &lt;&lt; (words[i].charAt(j) - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            bin[i] = bit;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; words.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((bin[i] &amp; bin[j]) == <span class="number">0</span>) max = Math.max(max, words[i].length() * words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/23/474-Ones-and-Zeroes/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="474. Ones and Zeroes"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-24T01:24:36.000Z" title="5/23/2022, 6:24:36 PM">2022-05-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-23T10:44:48.000Z" title="5/23/2022, 3:44:48 AM">2022-05-23</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">7 minutes read (About 1000 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/23/474-Ones-and-Zeroes/">474. Ones and Zeroes</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p>
<p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong> <em><code>m</code></em> <em><code>0</code></em>‘s and <em><code>n</code></em> <em><code>1</code></em>‘s in the subset</em>.</p>
<p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p>
</blockquote>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>0-1背包问题的升级版。经典的背包问题只有一种容量，而这个问题实际等于有两种容量。</p>
<p>经典背包问题需要用二维数组动态规划，分别为物品和容量。<br>而这道题需要用三维数组动态规划，分别为字符串，0的容量和1的容量。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>我们采用一个三维数组dp[i][j][k]保存<strong>可取最多物品的数量</strong>。<br>对于每个物品i，我们都可以取（数量+1）或不取（保持上一个物品的状态）。<br>j和k相当于分别记录了取“0”的总数和“1”的总数</p>
<p>遍历三个维度，并计算字符串中0和1的个数。</p>
<ul>
<li><p>如果当总容量大于当前物品中zeros和ones的数量，则<strong>可以取当前的物品</strong>。</p>
<ul>
<li>如果<strong>取当前的物品</strong>，则dp[]数组的总数等于<strong>上一个物品的状态加一</strong>，即dp[i-1][j-zeros][k-ones]。</li>
<li>也可以<strong>不取当前的物品</strong>，则dp[]数组的总数直接保持<strong>上一个物品的状态</strong>。</li>
</ul>
</li>
<li><p>如果当前背包总容量<strong>小于</strong>zeros和ones的数量，则不能取当前物品。</p>
<ul>
<li>数组dp[]<strong>保持上一个物品的状态</strong>。</li>
</ul>
</li>
</ul>
<p>时间复杂度：O(lmn + L)，L是数组中所有字符串长度之和。<br>空间复杂度：O(lmn)。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[strs.length+<span class="number">1</span>][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= strs.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">zeros</span> <span class="operator">=</span> <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : strs[i-<span class="number">1</span>].toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) zeros++;</span><br><span class="line">                <span class="keyword">else</span> ones++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - zeros &gt;= <span class="number">0</span> &amp;&amp; k - ones &gt;=<span class="number">0</span>) dp[i][j][k] = Math.max(dp[i-<span class="number">1</span>][j][k], dp[i-<span class="number">1</span>][j-zeros][k-ones] + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j][k] = dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.length][m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>由于dp[i][][]的上一个状态只涉及到dp[i-1][][]，因此我们可以采用滚动数组，去掉数组的一个维度，压缩空间。<br>此时需要从m到zeros，从n到ones倒序遍历，保证dp[i][][]转移过来的是dp[i-1][][]的元素。</p>
<p>此时的空间复杂度降低为O(mn)。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;   <span class="comment">//记录每个位置对应的0和1数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">zeros</span> <span class="operator">=</span> <span class="number">0</span>, ones = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) zeros++;</span><br><span class="line">                <span class="keyword">else</span> ones++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= zeros; i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= ones; j--)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-zeros][j-ones] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h3><p>递归+记忆化搜索，保存并返回每个位置的最大长度。<br>如果位置越界则返回0。<br>如果memo[i][zero][one]不为0，则返回memo[i][zero][one]。</p>
<p>如果当前字符串的“0”和“1”的个数大于剩余的“0”和“1”的个数，则可以取当前字符串，递归下一个位置并加一。<br>也可以不取当前的字符串，递归下一个位置。当前位置memo[i][zero][one]等于两者中的最大值。</p>
<p>否则无法取当前字符串，直接递归下一个位置。当前位置等于0。</p>
<h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String[] s;</span><br><span class="line">    <span class="type">int</span>[] zeros, ones;</span><br><span class="line">    <span class="type">int</span>[][][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        s = strs;</span><br><span class="line">        zeros = <span class="keyword">new</span> <span class="title class_">int</span>[strs.length];</span><br><span class="line">        ones = <span class="keyword">new</span> <span class="title class_">int</span>[strs.length];</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[strs.length][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)&#123;   <span class="comment">//记录每个位置对应的0和1数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; strs[i].length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i].charAt(j) == <span class="string">&#x27;0&#x27;</span>) zeros[i]++;</span><br><span class="line">                <span class="keyword">else</span> ones[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> zero, <span class="type">int</span> one)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= s.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][zero][one] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][zero][one];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPossibleSubset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(zero-zeros[i] &gt;= <span class="number">0</span> &amp;&amp; one-ones[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            maxPossibleSubset = <span class="number">1</span> + dfs(i+<span class="number">1</span>, zero-zeros[i], one-ones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][zero][one] = Math.max(maxPossibleSubset, dfs(i+<span class="number">1</span>, zero, one));</span><br><span class="line">        <span class="keyword">return</span> memo[i][zero][one];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/15/743-Network-Delay-Time/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="743. Network Delay Time"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-15T11:59:48.000Z" title="5/15/2022, 4:59:48 AM">2022-05-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-14T21:00:20.000Z" title="5/14/2022, 2:00:20 PM">2022-05-14</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">5 minutes read (About 773 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/15/743-Network-Delay-Time/">743. Network Delay Time</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u&lt;sub&gt;i&lt;/sub&gt;, v&lt;sub&gt;i&lt;/sub&gt;, w&lt;sub&gt;i&lt;/sub&gt;)</code>, where <code>u&lt;sub&gt;i&lt;/sub&gt;</code> is the source node, <code>v&lt;sub&gt;i&lt;/sub&gt;</code> is the target node, and <code>w&lt;sub&gt;i&lt;/sub&gt;</code> is the time it takes for a signal to travel from source to target.</p>
<p>We will send a signal from a given node <code>k</code>. Return the time it takes for all the <code>n</code> nodes to receive the signal. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>此题可以转化为求起始节点到最远距离的节点的距离。单源最短路径问题，可以采用Dijkstra算法。</p>
<p>采用一个visited[]数组记录初始节点的访问状况。<br>同时dist[]数组记录到达这一节点的最小距离，初始化为无限大。</p>
<p>进行BFS搜索，每次优先访问<strong>当前节点的子节点的最近子节点</strong>，并更新子节点与初始节点距离。<br>最后遍历dist[]数组，如果有元素仍为无限大，则BFS搜索未遍历到，返回-1。<br>否则返回数组内最大的距离即可。</p>
<h4 id="建立映射"><a href="#建立映射" class="headerlink" title="建立映射"></a>建立映射</h4><p>首先通过哈希表，将起始节点与有向边建立起映射关系。列表中储存子节点和对应边上的权值。<br>注意由于index是-1的，因此在组成列表时需要将当前数字减一。</p>
<h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>采用优先级队列组成小根堆，每次将当前的最小距离作为权值加入队列。<br>初始化队列时需要将起始节点（k-1）放入，此时的总距离为0。</p>
<p>当当前的子节点的cost加上起始节点的距离小于子节点的最小距离时，更新子节点最小距离。<br>同时将子节点当前最小距离作为比较对象传入优先级队列。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, List&lt;<span class="type">int</span>[]&gt;&gt; edges = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] time : times)&#123;    <span class="comment">//建立有向边</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">source</span> <span class="operator">=</span> time[<span class="number">0</span>] - <span class="number">1</span>, kid = time[<span class="number">1</span>] - <span class="number">1</span>, cost = time[<span class="number">2</span>];    <span class="comment">//注意index需要-1</span></span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list = edges.getOrDefault(source, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;kid, cost&#125;);    <span class="comment">//建立起点——终点映射</span></span><br><span class="line">            edges.put(source, list);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, Integer.MAX_VALUE);</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);    <span class="comment">//优先级队列，最小堆每次访问距离最近的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> k-<span class="number">1</span>;</span><br><span class="line">        dist[start] = <span class="number">0</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, <span class="number">0</span>&#125;);  <span class="comment">//start为初始节点，后面的距离为了实现优先级队列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">source</span> <span class="operator">=</span> curr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(visited[source] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            visited[source] = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; children = edges.getOrDefault(source, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());   <span class="comment">//获取当前起点的所有边</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] child : children)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">kid</span> <span class="operator">=</span> child[<span class="number">0</span>], cost = child[<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cost + dist[source] &lt; dist[kid])&#123;    <span class="comment">//如果新的距离小于之前的最小距离，则更新距离并将新的起点加入优先级队列</span></span><br><span class="line">                    dist[kid] = cost + dist[source];</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;kid, dist[kid]&#125;);    <span class="comment">//更新的距离是从出发节点到当前节点的距离，每次优先访问最近的节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d : dist)&#123;  <span class="comment">//最后遍历，距离的最大值就是结果</span></span><br><span class="line">            res = Math.max(res, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/11/1641-Count-Sorted-Vowel-Strings/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="1641. Count Sorted Vowel Strings"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-11T21:32:41.000Z" title="5/11/2022, 2:32:41 PM">2022-05-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-13T03:10:48.000Z" title="5/12/2022, 8:10:48 PM">2022-05-12</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">2 minutes read (About 262 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/11/1641-Count-Sorted-Vowel-Strings/">1641. Count Sorted Vowel Strings</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given an integer <code>n</code>, return <em>the number of strings of length <em><code>n</code></em> that consist only of vowels (</em><code>a</code><em>, <em><code>e</code></em>, <em><code>i</code></em>, <em><code>o</code></em>, <em><code>u</code></em>) and are <strong>lexicographically sorted</strong>.</em></p>
<p>A string <code>s</code> is <strong>lexicographically sorted</strong> if for all valid <code>i</code>, <code>s[i]</code> is the same as or comes before <code>s[i+1]</code> in the alphabet.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>动态规划，创建数组dp[]记录以每个字符开头能组成的字符串数量。<br>由于当长度为1时，每个字符串都能组成一次，因此初始化所有值为1。</p>
<p>n增长时，每一个层级都等于该字符后的所有值相加。<br>最后得出的结果在下一个层级的第一位。（因为第一位是所有上一个层级加和）</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countVowelStrings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j+<span class="number">1</span>; k &lt; <span class="number">5</span>; k++)&#123;</span><br><span class="line">                    dp[j] += dp[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>递归，使用成员变量计算有效递归次数。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countVowelStrings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        count(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            count(n-<span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/08/456-132-Pattern/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="456. 132 Pattern"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-08T08:59:15.000Z" title="5/8/2022, 1:59:15 AM">2022-05-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-07T18:34:16.000Z" title="5/7/2022, 11:34:16 AM">2022-05-07</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">3 minutes read (About 404 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/08/456-132-Pattern/">456. 132 Pattern</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>
<p>Return <em><code>true</code> if there is a <strong>132 pattern</strong> in <code>nums</code>, otherwise, return <code>false</code>.</em></p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>单调栈，专门用于找某一个元素的左边&#x2F;右边<strong>第一个</strong>比自己大&#x2F;小的位置。<br>递增单调栈会提出波峰，留下波谷。递减单调栈会剔除波谷，留下波峰。</p>
<p>我们需要找到同时满足j &lt; k和nums[k] &lt;[j]情况的位置。因此采用单调栈正合适。<br>我们枚举132模式中的“3”，由于我们要找到波谷，因此可以采用递增栈。</p>
<p>递增单调栈的实现：</p>
<p>当遍历的当前值小于栈顶元素时，不满足递增规律，因此挤出栈顶。<br>循环此操作直至当前栈顶于当前值满足递增规律或栈空。<br>此时的当前值是nums[j]，而最后一个被挤出的值就是nums[k]。<br>由于递增单调栈的性质，此时的nums[k] &lt; nums[j]且nums[k]大于被挤出的所有元素。</p>
<p>对于nums[i]，我们可以通过遍历nums[]数组，计算出其在i位置的最小值，并存在放minOfLeft[]中。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find132pattern</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] minOfLeft = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        minOfLeft[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            minOfLeft[i] = Math.min(minOfLeft[i-<span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[j] &gt; stack.peek())&#123;</span><br><span class="line">                k = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minOfLeft[j] &lt; k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/07/450-Delete-Node-in-a-BST/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="450. Delete Node in a BST"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-07T12:05:49.000Z" title="5/7/2022, 5:05:49 AM">2022-05-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-08T12:36:42.000Z" title="5/8/2022, 5:36:42 AM">2022-05-08</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">5 minutes read (About 715 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/07/450-Delete-Node-in-a-BST/">450. Delete Node in a BST</a></p><div class="content"><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li><p>Search for a node to remove.</p>
</li>
<li><p>If the node is found, delete the node.</p>
</li>
</ol>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>二叉搜索树（BST）的递增排序的访问顺序是中序遍历。（Left -&gt; Root -&gt; Right）</p>
<p>因此二叉搜索树的前驱者（小于当前节点的最大值）和继任者（大于当前节点的最小值）对于修改二叉树至关重要。</p>
<p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/images/pictures/202205070501572.jfif"></p>
<p>辅助方法getPredecessor() 和getSuccessor() 可以获得前驱者和继任者的值。<br>分别为当前根节点的左子节点的最右子节点（二叉搜索树下的最大值）和当前根节点右子节点的最左子节点。（二叉搜索树下的最小值）</p>
<p>deleteNode() 方法搜索key。如果当前值大于搜索值则搜索<strong>并修改</strong>其左子节点，反之搜索<strong>并修改</strong>右子节点。（由于要修改，因此向下递归子节点时需要将返回的结果传入该子节点。）</p>
<p>当搜索值等于当前值时，存在三种情况：<br>1.该子节点存在右子节点。此时我们将当前值设置为继任者的值，然后递归搜索右子节点中继任者的值进行删除。<br>2.该子节点存在左子节点。此时我们将当前值设置为前驱者的值，然后递归搜索左子节点中前驱者的值进行删除。<br>3.该子节点是叶子节点。直接删除当前节点。</p>
<p>最后返回修改后的根节点即可。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;     </span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key) root.left = deleteNode(root.left, key);  <span class="comment">//如果当前值大于搜索值则搜索左子节点，否则搜索右子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">        <span class="keyword">else</span>&#123;   <span class="comment">//如果当前值等于搜索值，根据子节点情况删除节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123; <span class="comment">//右子节点不为空则将当前root的值设置为继任者的值，然后向下递归删除继任者</span></span><br><span class="line">                root.val = getSuccessor(root);</span><br><span class="line">                root.right = deleteNode(root.right, root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123; <span class="comment">//左子节点不为空则将当前root的值设置为前驱者的值，然后向下递归删除继任者</span></span><br><span class="line">                root.val = getPredecessor(root);</span><br><span class="line">                root.left = deleteNode(root.left, root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getSuccessor</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">while</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPredecessor</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        <span class="keyword">while</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/06/673-Number-of-Longest-Increasing-Subsequence/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="673. Number of Longest Increasing Subsequence"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-06T10:46:29.000Z" title="5/6/2022, 3:46:29 AM">2022-05-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-05T19:47:00.000Z" title="5/5/2022, 12:47:00 PM">2022-05-05</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">4 minutes read (About 538 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/06/673-Number-of-Longest-Increasing-Subsequence/">673. Number of Longest Increasing Subsequence</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given an integer array <code>nums</code>, return <em>the number of longest increasing subsequences.</em></p>
<p><strong>Notice</strong> that the sequence has to be <strong>strictly</strong> increasing.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>本题还有贪心算法+前缀和+二分查找的算法。</p>
<p>本题是<code>300. Longest Increasing Subsequence</code>的拓展。<br>同样采用动态规划，数组dp[i]记录到i为止最长递增数列长度。<br>可以用一个新的数组cnt[i]记录到i为止可以组成的最长递增数列的数量。</p>
<p>对于每个新位置i，cnt[i]的最小值为i。<br>遍历i之前的所有位置j。如果nums[j] &lt; nums[i]，则i可以比dp[j]组成更长的递增数列，其长度为dp[j]+1。<br>如果dp[i] &lt; dp[j]+1。则可以更新dp[i]。同时，cnt[i]可以从cnt[j]继承其计数。<br>如果dp[i] &#x3D;&#x3D; dp[j]+1。则之前已经更新过dp[i]。说明有新的组合同样可以组成更长的递增数列。此时将cnt[j]加入当前的cnt[i]。</p>
<p>遍历完成i以内的所有j后，如果dp[i]大于当前的最长递增数列长度，则更新max。<br>同时更新长度的总数count为cnt[i]。<br>如果dp[i]等于max，则将cnt[i]加入计数count。<br>最后返回count。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNumberOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        cnt[i] = cnt[j];    <span class="comment">//如果后面的数字大于前面的，且可以组成更长的数列，则继承之前的计数。</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])&#123;    <span class="comment">//如果之前已经更新过dp[i]，则有新的组合长度一直，加和之前的计数。</span></span><br><span class="line">                        cnt[i] += cnt[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; max)&#123;    <span class="comment">//如果当前的长度大于之前的最大值，则更新。</span></span><br><span class="line">                max = dp[i];</span><br><span class="line">                count = cnt[i];  <span class="comment">//同时将之前计算的计数记录。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == max)&#123;  <span class="comment">//如果有同样达到最大值的情况，则加和计数。</span></span><br><span class="line">                count += cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/05/973-K-Closest-Points-to-Origin/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="973. K Closest Points to Origin"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-05T13:55:27.000Z" title="5/5/2022, 6:55:27 AM">2022-05-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-05T09:24:56.000Z" title="5/5/2022, 2:24:56 AM">2022-05-05</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">2 minutes read (About 260 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/05/973-K-Closest-Points-to-Origin/">973. K Closest Points to Origin</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given an array of <code>points</code> where <code>points[i] = [x&lt;sub&gt;i&lt;/sub&gt;, y&lt;sub&gt;i&lt;/sub&gt;]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.</p>
<p>The distance between two points on the <strong>X-Y</strong> plane is the Euclidean distance (i.e., <code>√(x&lt;sub&gt;1&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;- x&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ (y&lt;sub&gt;1&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;- y&lt;sub&gt;2&lt;/sub&gt;)&lt;sup&gt;2&lt;/sup&gt;</code>).</p>
</blockquote>
<p>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>此题可以采用快速排序的思想。可以在O(n)时间复杂度里完成排序。</p>
<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>优先级队列，根据每个点距离的平方排序。时间复杂度O(nlogk)。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; squaredDistance(a) - squaredDistance(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] point : points)&#123;</span><br><span class="line">            pq.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            ret[i] = pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">squaredDistance</span><span class="params">(<span class="type">int</span>[] point)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h3><p>直接排序。时间复杂度为O(nlogn)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[][] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; squaredDistance(a) - squaredDistance(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            ret[i] = points[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">squaredDistance</span><span class="params">(<span class="type">int</span>[] point)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x * x + y * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/05/130-Surrounded-Regions/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="130. Surrounded Regions"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-05T11:47:34.000Z" title="5/5/2022, 4:47:34 AM">2022-05-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-04T20:48:00.000Z" title="5/4/2022, 1:48:00 PM">2022-05-04</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">a minute read (About 202 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/05/130-Surrounded-Regions/">130. Surrounded Regions</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally surrounded by</em> <code>&#39;X&#39;</code>.</p>
<p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>首先对所有在边缘上的“O”进行BFS或DFS搜索，将和边缘连续的“O”改为“#”或任意其他字符。</p>
<p>然后遍历整个board，如果是“O”则改为“X”，如果是“#”则恢复为“O”。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isEdge</span> <span class="operator">=</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || i == board.length-<span class="number">1</span> || j == board[<span class="number">0</span>].length-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isEdge &amp;&amp; board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    bfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;#&#x27;</span>) board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                <span class="type">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> curr[<span class="number">0</span>], j = curr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;m-<span class="number">1</span> || j&gt;n-<span class="number">1</span> || board[i][j] == <span class="string">&#x27;X&#x27;</span> || board[i][j] == <span class="string">&#x27;#&#x27;</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                board[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i+<span class="number">1</span>,j&#125;);</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i-<span class="number">1</span>,j&#125;);</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j+<span class="number">1</span>&#125;);</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            size = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/05/201-Bitwise-AND-of-Numbers-Range/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="201. Bitwise AND of Numbers Range"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-05T07:31:19.000Z" title="5/5/2022, 12:31:19 AM">2022-05-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-04T20:48:44.000Z" title="5/4/2022, 1:48:44 PM">2022-05-04</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">3 minutes read (About 384 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/05/201-Bitwise-AND-of-Numbers-Range/">201. Bitwise AND of Numbers Range</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given two integers <code>left</code> and <code>right</code> that represent the range <code>[left, right]</code>, return <em>the bitwise AND of all numbers in this range, inclusive</em>.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>进行按位和运算时，只要两个位不都是1就会为0。从left到right之间，如果left和right的前x位是一样的，那么两者之间必定有一个数字<br>在x位上为1，后面的位上为0。因此和这个数字进行按位和运算必定为0。<br>因此，我们只要保留前面两者相同的位的信息即可，后面均为0。</p>
<p>当left与right不相等时，将两者同时右移，并计算移动的总数。<br>当两者相等时，向左移动计算的总数的位数。就保留了其相同的前缀。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt;&lt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>利用一串只有一个1的32位数字作为掩码，获得两个数字单独的位信息。<br>32位整数的第一位是符号位。因此我们的掩码从第1位开始直到第31位。<br>当对left和right进行该位的掩码操作后，如果两者相同，则掩码右移一位。<br>并将答案和当前位进行位或运算。（相当于保存当前位的位信息。）</p>
<p>如果不同，或者掩码变为0，则返回结果。</p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(mask &gt; <span class="number">0</span> &amp;&amp; (mask &amp; left) == (mask &amp; right))&#123;</span><br><span class="line">            ans |= (mask &amp; left);</span><br><span class="line">            mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/04/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="1557. Minimum Number of Vertices to Reach All Nodes"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-04T09:31:18.000Z" title="5/4/2022, 2:31:18 AM">2022-05-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-04T09:35:28.000Z" title="5/4/2022, 2:35:28 AM">2022-05-04</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">a minute read (About 158 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/04/1557-Minimum-Number-of-Vertices-to-Reach-All-Nodes/">1557. Minimum Number of Vertices to Reach All Nodes</a></p><div class="content"><h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><blockquote>
<p>Given a <strong>directed acyclic graph</strong>, with <code>n</code> vertices numbered from <code>0</code> to <code>n-1</code>, and an array <code>edges</code> where <code>edges[i] = [from i, to]</code> represents a directed edge from node <code>from i</code> to node <code>to i </code>.</p>
<p>Find <em>the smallest set of vertices from which all nodes in the graph are reachable</em>. It’s guaranteed that a unique solution exists.</p>
<p>Notice that you can return the vertices in any order.</p>
</blockquote>
<h4 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h4><p>由于是有向无环图（Directed acyclic graph），因此直接计算图内的入度为0的节点即可。<br>每条路径都需要从入度为0的点开始。</p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findSmallestSetOfVertices</span><span class="params">(<span class="type">int</span> n, List&lt;List&lt;Integer&gt;&gt; edges)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] inDegrees = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; edge : edges)&#123;</span><br><span class="line">            inDegrees[edge.get(<span class="number">1</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegrees[i] == <span class="number">0</span>) ret.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/03/581-Shortest-Unsorted-Continuous-Subarray/"><img class="fill" src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="581. Shortest Unsorted Continuous Subarray"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-04T04:01:18.000Z" title="5/3/2022, 9:01:18 PM">2022-05-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-04T20:50:48.000Z" title="5/4/2022, 1:50:48 PM">2022-05-04</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">3 minutes read (About 404 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/03/581-Shortest-Unsorted-Continuous-Subarray/">581. Shortest Unsorted Continuous Subarray</a></p><div class="content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p>Given an integer array <code>nums</code>, you need to find one <strong>continuous subarray</strong> that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.</p>
<p>Return <em>the shortest such subarray and output its length</em>.</p>
</blockquote>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>未排序子数组的左侧和右侧均为单调递增的区间。<br>我们的目标就是找到单调递增的边界。</p>
<p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/images/pictures/202205032049885.png"></p>
<p>中段由于是乱序的，因此其最大值与最小值必定不在中段的两端。<br>因此我们可以从左至右的遍历数组，不断地维护一个当前的最大值max。<br>由于只有中段是无序的，因此<strong>只有此时后面的数值才可能小于前面的最大值max</strong>。<br>当这种情况发生时，则记录当前节点位置。<br>同理，我们也可以从右至左遍历，维护一个当前的最小值min。<br><strong>只有在中段时，前面的数值才可能大于后面的最大值min。</strong><br>当这种情况发生时，则记录当前节点位置。</p>
<p>最后如果两个指针的位置相同，则返回0。（此时数组完全有序，指针未移动。）<br>如果两个指针的位置不同，则返回两者的差+1。（即两者的宽度。）</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max) end = i;</span><br><span class="line">            <span class="keyword">else</span> max = nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt; min) start = j;</span><br><span class="line">            <span class="keyword">else</span> min = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-03T08:34:39.000Z" title="5/3/2022, 1:34:39 AM">2022-05-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-02T17:35:30.000Z" title="5/2/2022, 10:35:30 AM">2022-05-02</time></span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/">Medium</a><span> / </span><a class="link-muted" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">复习</a></span><span class="level-item">5 minutes read (About 767 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/03/105-Binary-Tree-from-Preorder/">105. Construct Binary Tree from Preorder and Inorder Traversal</a></p><div class="content"><blockquote>
<p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
</blockquote>
<p>先序遍历时，访问的顺序是[根节点 - 左子节点 - 右子节点]。<br>中序遍历时，访问的顺序是[左子节点 - 根节点 - 右子节点]。<br>可以注意到根节点与左子节点的顺序是相反的，因此我们可以利用栈将节点储存起来，当挤出时顺序自然是调转的。</p>
<p>按照先序遍历来创建树，遍历先序数组。同时将指针指向中序遍历的数组的头部。<br>先创建根节点，并将其放入栈中。分为两种情况讨论。</p>
<p><strong>情况一，处理当前根节点的左子节点，并将其入栈：</strong></p>
<p>当栈顶的节点值与中序遍历当前的节点值不同时，说明当前的根节点仍有左子节点。</p>
<blockquote>
<p>先序：[<strong>根节点</strong> - 左子节点 - 右子节点]<br>中序：[<strong>左子节点</strong> - 根节点 - 右子节点]</p>
</blockquote>
<p>此时将栈顶的节点的左子节点设置为先序数组对应的节点，继续遍历下一个先序数组。</p>
<blockquote>
<p>栈内：[根节点 - <strong>左子节点</strong>]<br>先序：[根节点 - <strong>左子节点</strong> - 右子节点]<br>中序：[<strong>左子节点</strong> - 根节点 - 右子节点]</p>
</blockquote>
<p><strong>情况二，寻找栈内节点们的右子节点：</strong></p>
<p>当栈顶的节点与中序遍历当前的节点值相同时，说明我们经过了当前根节点的先序遍历中的最后一个左子节点。<br>当前先序数组指针指向了当前栈内节点一个右子节点。</p>
<blockquote>
<p>栈内：[根节点 - <strong>左子节点</strong>]<br>先序：[根节点 - 左子节点 - <strong>右子节点</strong>]<br>中序：[左子节点 - <strong>根节点</strong> - 右子节点]</p>
</blockquote>
<p>此时我们开始向右移动中序遍历的指针，寻找先序遍历指针中的节点应该是当前栈内哪一个节点的右子节点。<br>此时栈内节点的顺序，与中序遍历的左子节点顺序正好相反。当栈顶与中序遍历的指针相等时，挤出栈顶并将中序指针右移，直到两者不相等或栈空。<br>此时将最后挤出的根节点的右子节点设置为当前先序数组对应的节点，继续遍历下一个先序数组。</p>
<p>当遍历完成后，返回根节点即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        stack.add(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; preorder.length; i++)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[i]);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(inorder[j] != prev.val)&#123;</span><br><span class="line">                prev.left = curr;</span><br><span class="line">                stack.add(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; inorder[j] == stack.peek().val)&#123;</span><br><span class="line">                    prev = stack.pop();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                prev.right = curr;</span><br><span class="line">                stack.add(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">Previous</a></div><div class="pagination-next"><a href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/">1</a></li><li><a class="pagination-link is-current" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/page/2/">2</a></li><li><a class="pagination-link" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/1df9d9603ec9aabe96b8544e70466213?s=128" alt="XANDER"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">XANDER</p><p class="is-size-6 is-block">Architecture / Computer Science</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>UCLA, Los Angeles, CA.</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">296</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">80</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://twitter.com/xuanhe95" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/xuanhe95"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/xuanhe95"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Linkedin" href="https://www.linkedin.com/in/xuanhe-zhang/"><i class="fab fa-linkedin-in"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Zhihu" href="https://www.zhihu.com/people/fired"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2023/04/30/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="1579. Remove Max Number of Edges to Keep Graph Fully Traversable"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-04-30T09:17:56.000Z">2023-04-30</time></p><p class="title"><a href="/2023/04/30/1579-Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/">1579. Remove Max Number of Edges to Keep Graph Fully Traversable</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/LeetCode/Hard/">Hard</a> / <a href="/categories/LeetCode/Hard/Review/">Review</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/04/28/1697-Checking-Existence-of-Edge-Length-Limited-Paths/"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="1697. Checking Existence of Edge Length Limited Paths"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-04-29T02:33:44.000Z">2023-04-28</time></p><p class="title"><a href="/2023/04/28/1697-Checking-Existence-of-Edge-Length-Limited-Paths/">1697. Checking Existence of Edge Length Limited Paths</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/LeetCode/Hard/">Hard</a> / <a href="/categories/LeetCode/Hard/Review/">Review</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/04/27/319-Bulb-Switcher/"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/banner/LeetCode.png" alt="319. Bulb Switcher"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-04-27T17:14:58.000Z">2023-04-27</time></p><p class="title"><a href="/2023/04/27/319-Bulb-Switcher/">319. Bulb Switcher</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a> / <a href="/categories/LeetCode/Medium/">Medium</a> / <a href="/categories/LeetCode/Medium/Review/">Review</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-03T04:21:17.000Z">2023-04-02</time></p><p class="title"><a href="/2023/04/02/Augment-Reality/">Augment Reality</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-02T23:28:43.000Z">2023-04-02</time></p><p class="title"><a href="/2023/04/02/Unreal-World-Building/">Unreal World Building</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">284</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://pm2k.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Pm2k</span></span><span class="level-right"><span class="level-item tag">pm2k.com</span></span></a></li><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/gh-pages/images/icons/x.png" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2023 Xander</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "opt-out",
        theme: "block",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>