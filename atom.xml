<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XANDER&#39;s Studio</title>
  
  <subtitle>Xander Studio</subtitle>
  <link href="https://xuanhe95.github.io/atom.xml" rel="self"/>
  
  <link href="https://xuanhe95.github.io/"/>
  <updated>2023-03-31T21:16:26.955Z</updated>
  <id>https://xuanhe95.github.io/</id>
  
  <author>
    <name>Xuanhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>About me</title>
    <link href="https://xuanhe95.github.io/2023/03/31/About-me/"/>
    <id>https://xuanhe95.github.io/2023/03/31/About-me/</id>
    <published>2023-03-31T21:16:26.000Z</published>
    <updated>2023-03-31T21:16:26.955Z</updated>
    
    <content type="html"><![CDATA[<p>Hi, I am Xuanhe (Xander) Zhang, a graduate architecture student at UCLA, and hope to become a computational designer!<br>My objective is to provide helpful tools for architects to design through Coding and AI.<br>And demonstrate them via various technical ways through VR or AR.<br>I hope to explore more possibilities of architectural and computational design in my work.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hi, I am Xuanhe (Xander) Zhang, a graduate architecture student at UCLA, and hope to become a computational designer!&lt;br&gt;My objective is </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Digital Fabrication</title>
    <link href="https://xuanhe95.github.io/2023/03/30/Digital-Fabrication/"/>
    <id>https://xuanhe95.github.io/2023/03/30/Digital-Fabrication/</id>
    <published>2023-03-30T22:46:23.000Z</published>
    <updated>2023-03-31T04:51:55.029Z</updated>
    
    <content type="html"><![CDATA[<div id="portfolio" class="justified-gallery"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_1.jpg" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_2.jpg" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_3.jpg" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_4.jpg" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_5.jpg" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_6.jpg" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_7.jpg" height="480" width="480"  /></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;portfolio&quot; class=&quot;justified-gallery&quot;&gt;

&lt;img src=&quot;https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/M_1.jpg&quot;</summary>
      
    
    
    
    
    <category term="Works" scheme="https://xuanhe95.github.io/tags/Works/"/>
    
  </entry>
  
  <entry>
    <title>UCLA Summer Tech Seminar</title>
    <link href="https://xuanhe95.github.io/2023/03/30/UCLA-Summer-Tech-Seminar/"/>
    <id>https://xuanhe95.github.io/2023/03/30/UCLA-Summer-Tech-Seminar/</id>
    <published>2023-03-30T09:04:24.000Z</published>
    <updated>2023-03-31T09:09:20.900Z</updated>
    
    <content type="html"><![CDATA[<div id="portfolio" class="justified-gallery"><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_1.gif"></p><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_2.gif"><br><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_3.gif"><br><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_4.gif"><br><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Room_Demo.gif"></p><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_VR_Demo.gif"></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;portfolio&quot; class=&quot;justified-gallery&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summe</summary>
      
    
    
    
    
    <category term="Works" scheme="https://xuanhe95.github.io/tags/Works/"/>
    
  </entry>
  
  <entry>
    <title>UCLA Winter Tech Seminar</title>
    <link href="https://xuanhe95.github.io/2023/03/27/UCLA-Winter-Tech-Seminar/"/>
    <id>https://xuanhe95.github.io/2023/03/27/UCLA-Winter-Tech-Seminar/</id>
    <published>2023-03-28T02:25:11.000Z</published>
    <updated>2023-03-31T08:13:10.903Z</updated>
    
    <content type="html"><![CDATA[<div id="portfolio" class="justified-gallery"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Winter_Zoom_2.gif" height="480" width="480" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Winter_Zoom_4.gif" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Winter_Zoom_3.gif" height="480" width="480"  /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Winter_Zoom_1.gif" height="480" width="480"  /></div><div id="portfolio" class="justified-gallery"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_5.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_6.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_7.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_8.gif" height="240" width="240" /></div><div id="portfolio" class="justified-gallery"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_1.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_2.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_3.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Found_4.gif" height="240" width="240" /></div><div id="portfolio" class="justified-gallery"><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Hybrid_1.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Hybrid_2.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Hybrid_3.gif" height="240" width="240" /><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Summer_Tech_Hybrid_4.gif" height="240" width="240" /></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;portfolio&quot; class=&quot;justified-gallery&quot;&gt;

&lt;img src=&quot;https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Winter_Z</summary>
      
    
    
    
    <category term="Course" scheme="https://xuanhe95.github.io/categories/Course/"/>
    
    <category term="Blender" scheme="https://xuanhe95.github.io/categories/Course/Blender/"/>
    
    
    <category term="Unity" scheme="https://xuanhe95.github.io/tags/Unity/"/>
    
    <category term="Blender" scheme="https://xuanhe95.github.io/tags/Blender/"/>
    
    <category term="Works" scheme="https://xuanhe95.github.io/tags/Works/"/>
    
  </entry>
  
  <entry>
    <title>Yunggh Project</title>
    <link href="https://xuanhe95.github.io/2023/02/28/Yunggh-Project/"/>
    <id>https://xuanhe95.github.io/2023/02/28/Yunggh-Project/</id>
    <published>2023-03-01T00:33:00.000Z</published>
    <updated>2023-03-31T05:57:39.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><a href="https://github.com/BIMFAM/yunggh/tree/PolarConvexity">BIMFAM&#x2F;yunggh</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/WaveFunctionCollapse.cs">1. WaveFunctionCollapse</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/MarchingCubes.cs">2. Marching Cubes</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/QuadrilateralGrids.cs">3. Quadrilateral Grids</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/PolarConvexity.cs">4. Polar Convexity</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/StraightSkeleton.cs">5. Straight Skeleton</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/MedialAxis.cs">6. Medial Axis</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/Erosion.cs">7. Erosion</a><br><a href="https://github.com/BIMFAM/yunggh/blob/PolarConvexity/yunggh/Components/Shape/MinimumBoundingRectangle.cs">8. Minimum Bounding Rectangle</a></p><h1 id="Wave-Function-Collapse"><a href="#Wave-Function-Collapse" class="headerlink" title="Wave Function Collapse"></a>Wave Function Collapse</h1><center><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/WaveFunctionCollapse1.gif" alt="Wave Function Collapse"><br><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/WaveFunctionCollapse2.gif" alt="Wave Function Collapse"><br><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/WaveFunctionCollapse3.gif" alt="Wave Function Collapse"></p><p><a href="https://robertheaton.com/2018/12/17/wavefunction-collapse-algorithm/">The Wavefunction Collapse Algorithm explained very clearly | Robert Heaton</a></p></center><h1 id="Marching-Cubes"><a href="#Marching-Cubes" class="headerlink" title="Marching Cubes"></a>Marching Cubes</h1><center><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/MarchingCubes.gif" alt="Marching Cubes"><br><a href="http://paulbourke.net/geometry/polygonise/">Polygonising a scalar field (Marching Cubes)</a></p><h1 id="Quadrilateral-Grids"><a href="#Quadrilateral-Grids" class="headerlink" title="Quadrilateral Grids"></a>Quadrilateral Grids</h1><center><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/QuadrilateralGrids.gif" alt="Quadrilateral Grids Generation"></p></center><h1 id="Polar-Convexity"><a href="#Polar-Convexity" class="headerlink" title="Polar Convexity"></a>Polar Convexity</h1><center><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/PolarConvexity.gif" alt="Polar Convexity Generation"></p></center><h1 id="Medial-Skeleton-Straight-Skeleton-amp-Erosion"><a href="#Medial-Skeleton-Straight-Skeleton-amp-Erosion" class="headerlink" title="Medial Skeleton, Straight Skeleton &amp;  Erosion"></a>Medial Skeleton, Straight Skeleton &amp;  Erosion</h1><center><p><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Skeleton.gif" alt="Straight Sekeleton Generation"><br><img src="https://raw.githubusercontent.com/xuanhe95/xuanhe95.github.io/main/images/Erosion.png" alt="Erosion Generation"></p></center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Github&quot;&gt;&lt;/a&gt;Github&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/BIMFAM/yunggh/tree/PolarCo</summary>
      
    
    
    
    <category term="Grasshopper" scheme="https://xuanhe95.github.io/categories/Grasshopper/"/>
    
    
    <category term="Works" scheme="https://xuanhe95.github.io/tags/Works/"/>
    
    <category term="Grasshopper" scheme="https://xuanhe95.github.io/tags/Grasshopper/"/>
    
  </entry>
  
  <entry>
    <title>Emacs Commands</title>
    <link href="https://xuanhe95.github.io/2023/01/17/Emacs-Commands/"/>
    <id>https://xuanhe95.github.io/2023/01/17/Emacs-Commands/</id>
    <published>2023-01-17T22:45:36.000Z</published>
    <updated>2023-01-17T23:23:56.502Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>Command</th><th>English</th><th>中文</th></tr></thead><tbody><tr><td>C-x C-f</td><td>New&#x2F;Open file</td><td>新建&#x2F;打开</td></tr><tr><td>C-x C-w</td><td>Save as</td><td>另存为</td></tr><tr><td>C-x C-c</td><td>Exit</td><td>退出</td></tr><tr><td>C-x C-s</td><td>Save</td><td>保存</td></tr><tr><td>C-s</td><td>Search next</td><td>向下搜索</td></tr><tr><td>C-r</td><td>Search last</td><td>向上搜索</td></tr><tr><td>C-a</td><td>Start of the line</td><td>行首</td></tr><tr><td>C-e</td><td>End of the line</td><td>行末</td></tr><tr><td>C-p</td><td>Last line</td><td>上一行</td></tr><tr><td>C-n</td><td>Next line</td><td>下一行</td></tr><tr><td>C-d</td><td>Delete cursor</td><td>删除光标下字符</td></tr><tr><td>C-k</td><td>Delete line</td><td>删除整行</td></tr><tr><td>M-d</td><td>Delete word</td><td>删除单词</td></tr><tr><td>M-g g</td><td>Move to x line</td><td>移动到某行</td></tr><tr><td>C-&#x2F;</td><td>Undo</td><td>撤销</td></tr><tr><td>C-v</td><td>Next screen</td><td>下一屏</td></tr><tr><td>M-v</td><td>Last screen</td><td>上一屏</td></tr><tr><td>C-M-s</td><td>Search regex</td><td>正则表达式搜索</td></tr><tr><td>C-@</td><td>Mark</td><td>选中</td></tr><tr><td>C-w</td><td>Cut</td><td>剪切</td></tr><tr><td>M-w</td><td>Copy</td><td>复制</td></tr><tr><td>C-y</td><td>Paste</td><td>粘贴</td></tr><tr><td>M-!</td><td>Shell Mode</td><td>Shell模式</td></tr><tr><td>M-x shell</td><td>Shell Mode</td><td>Shell模式（交互式）</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;English&lt;/th&gt;
&lt;th&gt;中文&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;C-x C-f&lt;/td&gt;
&lt;td&gt;New&amp;#x2F;Open file&lt;/td&gt;
&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://xuanhe95.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://xuanhe95.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MATH61 Review</title>
    <link href="https://xuanhe95.github.io/2022/12/04/MATH61-Review/"/>
    <id>https://xuanhe95.github.io/2022/12/04/MATH61-Review/</id>
    <published>2022-12-04T23:45:13.000Z</published>
    <updated>2023-03-28T04:41:41.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Review-for-Math-61-Discreted-Structures-at-UCLA"><a href="#Review-for-Math-61-Discreted-Structures-at-UCLA" class="headerlink" title="Review for Math 61 - Discreted Structures at UCLA"></a>Review for Math 61 - Discreted Structures at UCLA</h2><span id="more"></span><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="1-1-集合-Sets"><a href="#1-1-集合-Sets" class="headerlink" title="1.1 集合 Sets"></a>1.1 集合 Sets</h4><ul><li>Power set: P(x): the set of all subset</li><li>Collection:</li><li>Partition:</li></ul><h4 id="3-1-函数-Function"><a href="#3-1-函数-Function" class="headerlink" title="3.1 函数 Function"></a>3.1 函数 Function</h4><ul><li><strong>单射 injective</strong>, one-to-one<ul><li>if f(x<sub>1</sub>) &#x3D; f(x<sub>2</sub>) then x<sub>1</sub> &#x3D; x<sub>2</sub></li></ul></li><li><strong>满射 surjective</strong>, onto<ul><li>for each y  ∈ Y, there exist some x  ∈ X where f(x) &#x3D; y</li></ul></li><li><strong>双射 bijective</strong>, one-to-one &amp; onto<ul><li>if f is bijective, f is invertible</li></ul></li></ul><h4 id="2-2-证明-Proof"><a href="#2-2-证明-Proof" class="headerlink" title="2.2 证明 Proof"></a>2.2 证明 Proof</h4><ul><li>直接证明 Direct Proof: p true -&gt; q true</li><li>反证法 Proof by Contradiction: opposite false</li><li>Proof by contrapositive: opposite q -&gt; opposite p</li><li>分类讨论 Proof by Cases: different situations</li></ul><h4 id="数学归纳法-Mathematical-Induction"><a href="#数学归纳法-Mathematical-Induction" class="headerlink" title="数学归纳法 Mathematical Induction"></a>数学归纳法 Mathematical Induction</h4><ul><li>Basis step:<ul><li>S(n0) is true.</li></ul></li><li>Inductive step:<ul><li>假设S(n)成立，将公式带入S(n+1)，推出S(n+1)成立。</li><li>For each n &gt;&#x3D; n0, if S(n) is true, S(n+1) is true</li></ul></li></ul><h4 id="序列与字符串-Sequence-and-Strings"><a href="#序列与字符串-Sequence-and-Strings" class="headerlink" title="序列与字符串 Sequence and Strings"></a>序列与字符串 Sequence and Strings</h4><ul><li>Properties：<ul><li>单调递增 increasing</li><li>单调递减 decreasing</li><li>非增 nonincreasing</li><li>非减 nondecreasing</li></ul></li><li>Closed formula for S:<ul><li>I &#x3D; [i, j], {S<sub>k</sub>}<sup>j</sup><sub>k&#x3D;i</sub>(j -&gt; max)</li></ul></li><li>subsequence</li><li>operation: 连加 <strong>∑</strong>，连乘 <strong>Π</strong></li><li>string: finite sequence of char, length |a|, concatnation, substring (consective)</li></ul><h3 id="关系-Relations"><a href="#关系-Relations" class="headerlink" title="关系 Relations"></a>关系 Relations</h3><ul><li><p>subset of X×Y, xRy</p></li><li><p><strong>reflective</strong>: if xRx</p></li><li><p><strong>symmetric</strong>: if xRy, then yRx</p></li><li><p><strong>antisymmetric</strong>:</p><ul><li>if for all x, y ∈ X, if xRy and yRx, then x&#x3D;y</li><li>证明: if x!&#x3D;y, then either (x, y)  !∈ to R or (y, x)  !∈ R</li></ul></li><li><p><strong>transitive</strong>:</p><ul><li>for all x, y, z ∈ X, if(x, y), (y, z)  ∈ R, then (x, z)  ∈ R</li></ul></li><li><p><strong>partial order</strong>: 同时满足 Refelective, Antisymmetric, Transitive</p></li><li><p><strong>total order</strong>: if each (x, y)  ∈ X are comparable</p><ul><li>Inverse(R<sup>-1</sup>) &#x3D; {(y|x) | xRy } ⊆ Y×X</li><li></li></ul></li></ul><h4 id="等价关系-Equivalence-Relations"><a href="#等价关系-Equivalence-Relations" class="headerlink" title="等价关系 Equivalence Relations"></a>等价关系 Equivalence Relations</h4><ul><li>同时满足 Reflective, Symmetric, Transitive</li><li><strong>equivalence classes</strong>:<ul><li>Partition of X: [a] &#x3D; {x∈X | xRa} S &#x3D; {[a] | a∈X}</li><li>|{equivalence}| &#x3D; |{partitions}|</li></ul></li><li>Relation Matrix:<ul><li>if has relationship &#x3D; 1. otherwise &#x3D; 0</li></ul></li></ul><h2 id="Chapter-6-Counting-method-and-Pigeonhole-Principle"><a href="#Chapter-6-Counting-method-and-Pigeonhole-Principle" class="headerlink" title="Chapter 6. Counting method and Pigeonhole Principle"></a>Chapter 6. Counting method and Pigeonhole Principle</h2><h3 id="6-1-计数原理-Counting-Principles"><a href="#6-1-计数原理-Counting-Principles" class="headerlink" title="6.1 计数原理 Counting Principles"></a>6.1 计数原理 Counting Principles</h3><ul><li><strong>Mutiplication Principle</strong></li><li>Prove if |x| &#x3D; n, then |P(x) &#x3D; 2<sup>n</sup>|</li><li><strong>Addition Principle</strong>:</li><li>Inclusion-Exclusion Principle:</li></ul><h4 id="6-2-排列组合-Permutations-amp-Combinations"><a href="#6-2-排列组合-Permutations-amp-Combinations" class="headerlink" title="6.2 排列组合 Permutations &amp; Combinations"></a>6.2 排列组合 Permutations &amp; Combinations</h4><ul><li>P(n, r) &#x3D; n!&#x2F;(n-r)!</li><li>C(n, r) &#x3D; P(n, r)&#x2F;r! &#x3D; n!&#x2F;(n-r)!r!</li><li>C<sub>n</sub> &#x3D; [1&#x2F;(n+1)]*C(2n, n) -&gt; catalan numbers</li><li><strong>k-elements selection from x (with t elements) allow repetition</strong><ul><li>C(k+t-1, t-1) &#x3D; C(k+t-1, k)</li></ul></li></ul><h4 id="6-7-二项式定理-Binomical-Coefficient"><a href="#6-7-二项式定理-Binomical-Coefficient" class="headerlink" title="6.7 二项式定理 Binomical Coefficient"></a>6.7 二项式定理 Binomical Coefficient</h4><ul><li><strong>proof equations directly</strong><ul><li>(a + b)<sup>n</sup> &#x3D; ∑C(n, k)a<sup>n-k</sup>b<sup>k</sup></li></ul></li><li><strong>Proof by cancelling</strong><ul><li>C(n+1, k) &#x3D; C(n, k-1) + C(n, k)</li></ul></li><li>Compute coefficient: C(n, k)</li></ul><h4 id="6-8-鸽子洞定理-Pigeonhole-Principle"><a href="#6-8-鸽子洞定理-Pigeonhole-Principle" class="headerlink" title="6.8 鸽子洞定理 Pigeonhole Principle"></a>6.8 鸽子洞定理 Pigeonhole Principle</h4><ul><li>if <em>f: X-&gt;Y</em> where X, Y finite and |X| &gt; |Y|, then f(x1) &#x3D; f(x2) for some x1, x2 ∈ X where x1 !&#x3D; x2</li><li>|X| &#x3D; n and |Y| &#x3D; m, let k &#x3D; ⌈n&#x2F;m⌉, then there are at least k distinct values a let f(a) are equal</li></ul><h2 id="Chapter-7-Recurence-Relations"><a href="#Chapter-7-Recurence-Relations" class="headerlink" title="Chapter 7 Recurence Relations"></a>Chapter 7 Recurence Relations</h2><h3 id="7-1-递推关系-Recurrence-Relations"><a href="#7-1-递推关系-Recurrence-Relations" class="headerlink" title="7.1 递推关系 Recurrence Relations"></a>7.1 递推关系 Recurrence Relations</h3><ul><li>String doesn’t contain the pattern “111”</li><li>Tower of Honoi</li><li>Find closed formula for a<sub>n</sub></li></ul><h4 id="常系数线性递推公式-Linear-Homogeneous-Recurrence-Relations-of-Order-with-Constant-Coefficients-LHRC"><a href="#常系数线性递推公式-Linear-Homogeneous-Recurrence-Relations-of-Order-with-Constant-Coefficients-LHRC" class="headerlink" title="常系数线性递推公式 Linear Homogeneous Recurrence Relations of Order with Constant Coefficients (LHRC)"></a>常系数线性递推公式 Linear Homogeneous Recurrence Relations of Order with Constant Coefficients (LHRC)</h4><ul><li><p>a<sub>n</sub> &#x3D; c<sub>1</sub>a<sub>n-1</sub> + c<sub>2</sub>a<sub>n-2</sub> + … + c<sub>k</sub>a<sub>n-k</sub> where c<sub>k</sub> !&#x3D; 0</p><ul><li>ex Fibonacci numbers fn &#x3D; fn-1 + fn-2 is a LHRC of order 2</li><li>Sn &#x3D; 2Sn - 1 is a LHRC of order 1</li></ul></li><li><p>How to solve LHRC?</p><ul><li>t<sup>2</sup>-c<sub>1</sub>t - c<sub>2</sub>解出两个根r1和r2</li><li>a<sub>n</sub> &#x3D; br<sub>1</sub><sup>n</sup>+dr<sub>2</sub><sup>n</sup>， n &gt;&#x3D; 0</li><li>带入b+d &#x3D; c<sub>0</sub> and br<sub>1</sub> + dr<sub>2</sub> &#x3D; c<sub>1</sub></li></ul></li><li><p>如果是repeated root -&gt; a<sub>n</sub> &#x3D; br<sup>n</sup>+dnr<sup>n</sup>, n &gt;&#x3D; 0</p></li></ul><h2 id="Chapter-8-图论-Graph-Theory"><a href="#Chapter-8-图论-Graph-Theory" class="headerlink" title="Chapter 8 图论 Graph Theory"></a>Chapter 8 图论 Graph Theory</h2><h3 id="8-1-图-Examples-of-Graphs"><a href="#8-1-图-Examples-of-Graphs" class="headerlink" title="8.1 图 Examples of Graphs"></a>8.1 图 Examples of Graphs</h3><ul><li><strong>完全图 Complete grpah</strong>:<ul><li>K<sub>n</sub></li></ul></li><li>二分图 Bipartite graph</li><li><strong>完全二分图 Complete bipartite graph</strong>:<ul><li>K<sub>n,m</sub></li></ul></li></ul><h3 id="8-2-路径与环-Path-amp-Circle"><a href="#8-2-路径与环-Path-amp-Circle" class="headerlink" title="8.2 路径与环 Path &amp; Circle"></a>8.2 路径与环 Path &amp; Circle</h3><ul><li>Connected: 所有的边在一起组成一个graph</li><li>Component: 连接在一起的顶点和边的集合</li><li>G is connected if G has only 1 component</li></ul><h4 id="欧拉环-Eulerian-Cycle"><a href="#欧拉环-Eulerian-Cycle" class="headerlink" title="欧拉环 Eulerian Cycle"></a><strong>欧拉环 Eulerian Cycle</strong></h4><ul><li>A cycle in G that includes each edge + vertex in G is called an Eulerian Cycle</li><li>一笔画问题</li><li>欧拉环的总度数是边的二倍</li><li>G has a path with no repeated edges from v to w containing all vertices + edges &lt;&#x3D;&#x3D;&gt; G is connected + v, w are the only vertices in G with odd degree</li><li>If G contains a cycle from v to v, G contains a simple cycle from v to v</li></ul><h4 id="哈密顿环-Hamiltonian-Cycles"><a href="#哈密顿环-Hamiltonian-Cycles" class="headerlink" title="哈密顿环 Hamiltonian Cycles"></a><strong>哈密顿环 Hamiltonian Cycles</strong></h4><ul><li>A cycle in G that contains each v exactly once is a Hamiltonian cycle</li><li><strong>Proof no Hamiltonian Cycles</strong><ul><li>compute |V(G)| &#x3D; n, |E(G)| &#x3D; m</li><li>find largest S ⊆ V(G) such that v1, v2 ∈ S &#x3D;&gt; (v1, v2) !∈ E(G) + d(v) &gt; 2 for v ∈ S</li><li>if m - ∑(d(v)-2)&lt; n (# edges needed for H.cycle), then no H.cycle</li></ul></li></ul><h4 id="Degree-Sequence"><a href="#Degree-Sequence" class="headerlink" title="Degree Sequence"></a>Degree Sequence</h4><ul><li>nonincreasing order</li><li>证明degree sequence无法构成G</li></ul><h4 id="Shortest-Path-Algorithm"><a href="#Shortest-Path-Algorithm" class="headerlink" title="Shortest-Path Algorithm"></a>Shortest-Path Algorithm</h4><ul><li>Dijkstra算法:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dijkstra (w, a, z, L)&#123;</span><br><span class="line">    L(a) = 0;</span><br><span class="line">    for all vertices x != a:</span><br><span class="line">        L(x) = max</span><br><span class="line">    T: set of all vertices</span><br><span class="line">    while(z ∈ T)&#123;</span><br><span class="line">        choose v ∈ T with min L(v)</span><br><span class="line">        T = T - &#123;v&#125;</span><br><span class="line">        for each x ∈ T adjacent to v</span><br><span class="line">            L(x) = min &#123;L(x), L(v) + w(v, x)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图的表示方法-Representations-of-Graphs"><a href="#图的表示方法-Representations-of-Graphs" class="headerlink" title="图的表示方法 Representations of Graphs"></a>图的表示方法 Representations of Graphs</h4><ul><li>邻接矩阵 adjacency matrices:<ul><li>if two vertices have edge &#x3D; 1. otherwise &#x3D; 0</li><li>矩阵的n次方等于以i, j为起点的长度为n的路径的数量</li></ul></li></ul><h4 id="图的同构-Isomorphisms-of-Graphs"><a href="#图的同构-Isomorphisms-of-Graphs" class="headerlink" title="图的同构 Isomorphisms of Graphs"></a>图的同构 Isomorphisms of Graphs</h4><ul><li>如果我们可以找到一组对应关系，使得两个图G与G’上的每个顶点与每条边一一对应，则G与G’是同构关系。<ul><li>同构是等价关系</li></ul></li><li>两个图同构 &lt;&#x3D;&#x3D;&gt; 调换顶点顺序，两个图的邻接矩阵相同</li><li>如何证明两个图不同构？<ul><li>use invariants to detect when graphs are not isomorphic</li></ul></li></ul><h4 id="平面图-Planar-Graphs"><a href="#平面图-Planar-Graphs" class="headerlink" title="平面图 Planar Graphs"></a>平面图 Planar Graphs</h4><ul><li>可以画成边不交叉的图叫做平面图</li><li>面 Faces: 由平面图切割的区域叫做面<ul><li>f &#x3D; e - v + 2: 面数 &#x3D; 边数 - 顶点数 + 2</li><li>因此，如果G不满足此条件，则G不是平面图</li></ul></li></ul><h4 id="Series-Reduction"><a href="#Series-Reduction" class="headerlink" title="Series Reduction"></a>Series Reduction</h4><ul><li>减去顶点v并减去其两条边，然后将连接的两个顶点相连接</li></ul><h4 id="图的同胚-Homeomorphic"><a href="#图的同胚-Homeomorphic" class="headerlink" title="图的同胚 Homeomorphic"></a>图的同胚 Homeomorphic</h4><ul><li>通过series reduction进行减去顶点，如果能将两个图变为同构的，则二者同胚。<ul><li>同胚是等价关系</li></ul></li></ul><h4 id="平面图判断-Kuratowski"><a href="#平面图判断-Kuratowski" class="headerlink" title="平面图判断 Kuratowski"></a>平面图判断 Kuratowski</h4><ul><li>Planar Graph &lt;&#x3D;&#x3D;&gt; G does not contain a subgraph homeomorhpic to K<sub>5</sub> or K<sub>3, 3</sub></li></ul><h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树 Tree"></a>树 Tree</h3><ul><li>simple graph, 且两点之间只有一个simple path</li><li>rooted tree</li><li>树高 height 从0开始算</li><li>Every tree with 2 or more movertices has a vertex of degree 1</li><li>Tree is a bipartite graph</li></ul><h4 id="More-trees"><a href="#More-trees" class="headerlink" title="More trees"></a>More trees</h4><ul><li>树的属性:<ul><li>parent</li><li>ancestors</li><li>child</li><li>descendant</li><li>siblings</li><li>terminal vertex&#x2F;leaft</li><li>internal vertex</li><li>subtree of T rooted at x</li></ul></li><li>graph with no cycles is called acyclic<ul><li>if T is a tree, T is acyclic + connected</li></ul></li><li>下面四个关系是等价的：<ul><li>T is a tree</li><li>T is connected &amp; acyclic</li><li>T is connected &amp; |E(T)| &#x3D; n -1</li><li>T is acyclic &amp; |E(T)| &#x3D; n - 1</li></ul></li></ul><h4 id="生成树-Spanning-Trees"><a href="#生成树-Spanning-Trees" class="headerlink" title="生成树 Spanning Trees"></a>生成树 Spanning Trees</h4><ul><li>subgraph T of G such that T is a tree where V(T) &#x3D; V(G) is called a spanning tree of G</li><li>G存在生成树 &lt;&#x3D;&#x3D;&gt; G是连通图</li><li>如何找到生成树？<ul><li>BFS</li><li>DFS</li></ul></li><li>计算完全图的subgraph数量<ul><li>用组合C求出总量</li><li>注意需要除以重复的环</li><li>如果对称，需要除以2</li></ul></li></ul><h4 id="最小生成树-Minimal-Spanning-Trees"><a href="#最小生成树-Minimal-Spanning-Trees" class="headerlink" title="最小生成树 Minimal Spanning Trees"></a>最小生成树 Minimal Spanning Trees</h4><ul><li>MST: 在weighted graph G中，最小生成树的边加权最小<ul><li></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prim (w, n, s):</span><br><span class="line">    initialize all v(i) = 0, E = Ø</span><br><span class="line">    update v(s) = 1</span><br><span class="line">    for i = 1 to n - 1:</span><br><span class="line">        min = max</span><br><span class="line">        for j = 1 to n:</span><br><span class="line">            if ( v(j) = 1 ):</span><br><span class="line">                for k = 1 to n:</span><br><span class="line">                    if v(k) = 0 and w(j, k) &lt; min:</span><br><span class="line">                        set k to be addable vertex</span><br><span class="line">                        e = (j, k)</span><br><span class="line">                        min = w(j, k)</span><br><span class="line">                update v(addable vertex) = 1</span><br><span class="line">                update E = E∪e</span><br><span class="line">    return E</span><br></pre></td></tr></table></figure><h5 id="二叉树-Binary-Trees"><a href="#二叉树-Binary-Trees" class="headerlink" title="二叉树 Binary Trees"></a>二叉树 Binary Trees</h5><ul><li>满二叉树 full binary tree<ul><li>each vertex has 0 or 2 children</li><li>if a full binary tree T has i internal vertices, then T has i + 1 terminal vertices &amp; 2i+1 total vertices</li><li>证明：V(T) &#x3D; 2i + 1</li></ul></li><li>比赛场数可以用满二叉树计算：<ul><li>比赛场数（internal vertices）&#x3D; 队伍总数（terminal vertices）- 1</li><li>可组合的可能性：2<sup># internal vertices</sup></li><li>二叉树的树高为h，且有t个terminal vertices，则log<sub>2</sub>t &lt;&#x3D; h</li></ul></li></ul><h5 id="树的同构-Isomorphisms-of-Trees"><a href="#树的同构-Isomorphisms-of-Trees" class="headerlink" title="树的同构 Isomorphisms of Trees"></a>树的同构 Isomorphisms of Trees</h5><ul><li><p>普通树的同构：</p><ul><li>5个顶点的树有3种不同构的组合</li><li>Proof by cases，从可能的最高度数到最低度数，通过度数证明</li></ul></li><li><p>Rooted Tree的同构：</p><ul><li>rooted trees如果同构，则两者的root必须相同</li><li>4个顶点的rooted trees有4种不同构的组合</li></ul></li><li><p>二叉树的同构：</p><ul><li>二叉树如果同构，则两者的左子节点与右子节点必须对应</li><li>3个顶点的二叉树有5种不同的同构方式</li><li>由n个节点组成的二叉树不同构的数量C<sub>n</sub></li><li>C<sub>n</sub> &#x3D; [1&#x2F;(n+1)]*C(2n, n) -&gt; catalan numbers</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bin_tree_isom(r1, r2)&#123;</span><br><span class="line">        if(r1 == null &amp;&amp; r2 == null) return true</span><br><span class="line">        if (r1 == null &amp;&amp; r2 != null || r1 != null &amp;&amp; r2 == null) return false</span><br><span class="line">        lc_r1 = left child of r1</span><br><span class="line">        lc_r2 = right child of r2</span><br><span class="line">        rc_r1 = right child of r1</span><br><span class="line">        rc_r2 = right child of r2</span><br><span class="line">        if(bin_tree_isom(lc_r1, lc_r2) == True &amp;&amp; bin_tree_isom(rc_r1, rc_r2) == True)</span><br><span class="line">            return true</span><br><span class="line">        else</span><br><span class="line">            return false</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Review-for-Math-61-Discreted-Structures-at-UCLA&quot;&gt;&lt;a href=&quot;#Review-for-Math-61-Discreted-Structures-at-UCLA&quot; class=&quot;headerlink&quot; title=&quot;Review for Math 61 - Discreted Structures at UCLA&quot;&gt;&lt;/a&gt;Review for Math 61 - Discreted Structures at UCLA&lt;/h2&gt;</summary>
    
    
    
    <category term="Math" scheme="https://xuanhe95.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="https://xuanhe95.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Math 33 Review</title>
    <link href="https://xuanhe95.github.io/2022/11/20/Math-33-Review/"/>
    <id>https://xuanhe95.github.io/2022/11/20/Math-33-Review/</id>
    <published>2022-11-20T21:41:00.000Z</published>
    <updated>2023-03-28T04:41:53.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Review-for-Math-33-Linear-Algebra-at-UCLA"><a href="#Review-for-Math-33-Linear-Algebra-at-UCLA" class="headerlink" title="Review for Math 33 - Linear Algebra at UCLA"></a>Review for Math 33 - Linear Algebra at UCLA</h2><span id="more"></span><h3 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1:"></a>Homework 1:</h3><ul><li><strong>增广矩阵 Augmented matrix：</strong><ul><li>sovling system equations</li></ul></li><li><strong>简化行阶梯形 Reduced Row Echelon Form</strong></li></ul><h3 id="Homework-2"><a href="#Homework-2" class="headerlink" title="Homework 2:"></a>Homework 2:</h3><ul><li><strong>秩 Rank：</strong></li><li><strong>自由元 Free variable：</strong><ul><li>finding all possible numbers for variables</li></ul></li><li><strong>线性变换 Linear transformation：</strong><ul><li>determining weather a function is linear</li><li>线性变换判断方法：<ul><li>if (v, w) in R</li><li>&#x3D;&gt; T(v + w) &#x3D; T(v) + T(w)</li><li>&#x3D;&gt; T(av) &#x3D; aT(v)</li></ul></li></ul></li></ul><h3 id="Homework-3"><a href="#Homework-3" class="headerlink" title="Homework 3:"></a>Homework 3:</h3><ul><li><p><strong>变换矩阵 Transformation matrix：</strong></p><ul><li>finding the matrix of linear transformation (<strong>M</strong>)</li></ul></li><li><p><strong>矩阵乘法 Matrix multiplication：</strong></p></li><li><p><strong>子空间 Subspace:</strong></p><ul><li>子空间判断方法与判断矩阵是否是linear相近：<ul><li>if (v, w) in S</li><li>&#x3D;&gt; (v + w) in S</li><li>&#x3D;&gt; av in S</li></ul></li></ul></li><li><p><strong>线性生成空间 Span:</strong></p><ul><li>判定w是否在span中：</li><li>could we find <strong>a*v1 + b*v2 + … +n*vn &#x3D; w in span{v1…vn}</strong></li><li>using <strong>augemented matrix</strong> to solve the problem</li></ul></li></ul><h3 id="Homework-4"><a href="#Homework-4" class="headerlink" title="Homework 4:"></a>Homework 4:</h3><ul><li><p><strong>线形独立 linearly independent：</strong></p><ul><li>determining weather a matrix M is <strong>linearly independent</strong><ul><li>RREF</li></ul></li></ul></li><li><p><strong>核 Kernal：</strong></p><ul><li>kernal(M) -&gt; sending all vectors to 0</li></ul></li><li><p><strong>象 Image：</strong></p><ul><li>image(M) -&gt; equivalent to the span of the columns of M</li></ul></li><li><p><strong>逆 Inverse：</strong></p><ul><li><p>逆矩阵与矩阵操作后原矩阵不变：<strong>A &#x3D; M<sup>-1</sup>MA</strong></p></li><li><p>判断一个矩阵是否可逆：</p></li><li><p>determining whether a matrix M is <strong>invertible</strong>:</p><ul><li>方形矩阵 Square matrix</li><li>满秩 Full rank</li><li>行列式不为零 det(M) !&#x3D; 0</li></ul></li><li><p>Calculating the invert matrix:</p><ul><li>高斯消元法</li></ul></li></ul></li><li><p><strong>finding basis</strong></p></li></ul><h3 id="Homework-5"><a href="#Homework-5" class="headerlink" title="Homework 5:"></a>Homework 5:</h3><ul><li><p><strong>寻找T的象的线性组合空间 finding image(T) &#x3D; span(v1, v2, ….vn):</strong></p><ul><li>image(T) &#x3D; span{col(T)} -&gt; col(T) &#x3D; {v1, v2, …vn}</li></ul></li><li><p><strong>基 Basis</strong> :</p><ul><li><p>standard basis：</p></li><li><p>finding w that <strong>perpendicular</strong> to vectors span{v1 … vn}:</p><ul><li>(v1 · w) &#x3D; 0, (v2 · w) &#x3D; 0, …  (vn · w) &#x3D; 0</li></ul></li><li><p><strong>在以B &#x3D; {b1, b2, …bn}为基的坐标系中表示向量w：</strong></p><ul><li>将w分解为基向量之和 (a * b1) + (b * b2) + … + (n * bn)</li><li>将factors组成一个新的col向量[a, b, … n]</li></ul></li><li><p><strong>相似变换矩阵 Similar matrix:</strong></p><ul><li>同一个线性变换，不同基下的矩阵，称为相似矩阵</li></ul></li><li><p><strong>求以B为基的坐标系的相似变换矩阵 B-matrix</strong>：</p><ul><li><strong>B &#x3D; S<sup>-1</sup>TS</strong>（以B为基的坐标系的变换矩阵）</li><li>find the matrix of the linear transformation defined by T(v) &#x3D; w with respect to the basis {b1, b2, … bn}</li><li>将bn带入T()，得到变化后的wn</li><li>分解w<sub>n</sub>为aw<sub>1</sub> + bw<sub>2</sub> + … + nw<sub>n</sub></li><li>将factors的解组成一个新的col向量</li><li>B-matrix &#x3D; [col1, col2, … coln]</li></ul></li></ul></li><li><p><strong>let T: R3 -&gt; R3 be the orthogonal projection onto the line spanned by [1 1 1]. Find a basis for which this projection matrix is diagonal</strong></p></li></ul><h3 id="Homework-6"><a href="#Homework-6" class="headerlink" title="Homework 6:"></a>Homework 6:</h3><ul><li><p><strong>正交 orthogonal：</strong></p><ul><li>矩阵A是否正交判断：<strong>A<sup>T</sup> &#x3D; A<sup>-1</sup></strong></li><li>正交矩阵的行列式永远等于+-1</li></ul></li><li><p><strong>标准正交基 Orthonormal：</strong></p><ul><li>所有基向量两两正交</li><li>所有基向量模长为1</li></ul></li><li><p><strong>正交投影 Orthogonal Projection：</strong></p><ul><li>正交投影公式：</li><li><strong>注意：</strong>投影的两个基向量必须是标准正交基</li><li><strong>proj<sub>span{u, v}</sub><sup>w</sup> &#x3D; proj<sub>u</sub><sup>w</sup> + proj<sub>v</sub><sup>w</sup></strong></li><li><strong>proj<sub>v</sub><sup>w</sup> &#x3D; [(u · v)&#x2F;(v · v)]v</strong></li></ul></li><li><p><strong>QR分解 QR factorization (Gram–Schmidt process)：</strong></p><ul><li>首先将第一个向量w<sub>1</sub>单位化<ul><li><strong>v &#x3D; w<sub>1</sub> &#x2F; ||w<sub>1</sub>||</strong> (第一个向量v等于第一个原有向量w<sub>1</sub>除以其模长)</li></ul></li><li>然后将第二个向量w<sub>2</sub>标准正交化：<ul><li><strong>u &#x3D; (w<sub>2</sub> - proj<sub>v</sub><sup>w<sub>2</sub></sup>) &#x2F; ||(w<sub>2</sub> - proj<sub>v</sub><sup>w<sub>2</sub></sup>)||</strong></li><li>（第二个向量u等于第二个原有向量w<sub>2</sub>减去w<sub>2</sub>在向量v上的投影除以其模长）</li><li>最后将第三个向量w<sub>3</sub>标准正交化：</li><li><strong>t &#x3D; (w<sub>3</sub> - proj<sub>span{v, u}</sub><sup>w<sub>3</sub></sup>) &#x2F; ||(w<sub>3</sub> - proj<sub>span{v, u}</sub><sup>w<sub>3</sub></sup>)||</strong></li><li>（第三个向量u等于第三个原有向量w<sub>3</sub>减去w<sub>3</sub>在平面span{v, u}上的投影除以其模长）</li></ul></li></ul></li></ul><h3 id="Homework-7"><a href="#Homework-7" class="headerlink" title="Homework 7:"></a>Homework 7:</h3><ul><li><p><strong>正交补空间 V<sup>⊥</sup>:</strong></p><ul><li><strong>find a basis for the subspace V<sup>⊥</sup>：</strong></li><li>首先找到矩阵M，令V是M的象。因此我们需要解关于V的增广矩阵以得到V &#x3D; span{col(M)}：<ul><li>let M &#x3D; [v1, v2, … vn] for vi in V</li><li><strong>V &#x3D; image(M)</strong> : (V &#x3D; image(M) &#x3D; span{col(M)})</li></ul></li><li>正交补空间中的向量与原空间中所有的向量垂直：<ul><li>因此(w in V<sup>⊥</sup>), (v in V) -&gt; v · w  &#x3D; 0</li><li><strong>V<sup>⊥</sup> &#x3D; ker(M<sup>T</sup>)</strong>: w · v &#x3D; M<sup>T</sup>V<sup>⊥</sup> &#x3D; 0 (M<sup>T</sup> &#x3D; span{row(M)})</li></ul></li><li>解关于ker(M<sup>T</sup>)的增广矩阵，得到所有可以组成V<sup>⊥</sup>的向量</li><li>取一组自由元作为V<sup>⊥</sup>的标准基，得到basis(V<sup>⊥</sup>)</li></ul></li><li><p><strong>最小平方法 Least squares method：</strong></p><ul><li>find <strong>least-squares solution x</strong>*（最小平方解）  of the system:</li><li>A<sup>T</sup>Ax* &#x3D; A<sup>T</sup>b</li></ul></li><li><p><strong>行列式 Determinant：</strong></p><ul><li>如果M将原有空间volume放大n倍，则det(M) &#x3D; n</li><li>如果det(M) &#x3D; 0，则原有空间被降维，因此此时不可逆</li></ul></li></ul><h3 id="Homework-8"><a href="#Homework-8" class="headerlink" title="Homework 8:"></a>Homework 8:</h3><ul><li><p><strong>初等变换 Elementary transformation</strong>：</p><ul><li>当某一行row加到另一行row2时，行列式不变：det(M’) &#x3D; det(M)</li><li>当某一行row被放大n倍时，行列式放大n倍: det(M’) &#x3D; n * det(M)</li><li>当交换两个row时，行列式取负值：det(M’) &#x3D; -det(M)</li></ul></li><li><p><strong>行列式计算技巧：</strong></p><ul><li>det(M) &#x3D; RREF后的对角线的值相乘</li><li>det(M) &#x3D; 0, if M linearly depandent</li><li>det(M) &#x3D; det(M<sup>T</sup>)</li></ul></li><li><p><strong>特征值 Eigenvalues λ 与特征向量 Eigenvector：</strong></p><ul><li>在M对原有空间进行线性变换时，存在一些向量（特征向量）只发生了倍数变换（Mv &#x3D; λv）。</li><li>求解特征值：det(M-λI) &#x3D; 0</li><li>特征值可以为0，但特征向量不能为0</li><li>不可逆方程必有特征值0</li></ul></li><li><p><strong>平行六面体 Parallelepiped的volume计算</strong>:</p><ul><li>将基向量变换到对应的顶点坐标，得到变换矩阵T</li><li>计算|det(T)|</li></ul></li></ul><h3 id="Homework-9"><a href="#Homework-9" class="headerlink" title="Homework 9:"></a>Homework 9:</h3><ul><li><strong>特征基 eigenbasis</strong>:<ul><li>由矩阵的特征向量组成的一组基</li><li>解出特征值，得到特征向量，带入值，组成基</li></ul></li><li><strong>特征空间 eigenspace</strong><ul><li>特征空间的维度决定了是否能找到矩阵的特征基，只有特征空间的维度等于矩阵的维度，才能找到特征基。</li></ul></li><li><strong>对角化</strong><ul><li>对角化的本质是将当前矩阵M的基变更为其特征基</li><li>以特征基作为矩阵新的基，新的基可以组成变换矩阵S</li><li>将特征基向量v与矩阵M进行乘法，得到变换后的向量位置</li><li>将向量分解为特征基的加和w</li><li>将factors的解组成一个新的col向量</li><li>B-matrix &#x3D; [col1, col2, … coln]</li><li>对角化矩阵<strong>M &#x3D; SM’S<sup>-1</sup></strong>,（该操作是相似变换矩阵的逆运算）</li><li>对角化矩阵的对角线是特征值</li></ul></li><li><strong>矩阵乘方</strong><ul><li>先将矩阵M对角化为M’</li><li>计算M’的乘方，直接将对角线上的数值乘方</li><li>M &#x3D; SM’S</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Review-for-Math-33-Linear-Algebra-at-UCLA&quot;&gt;&lt;a href=&quot;#Review-for-Math-33-Linear-Algebra-at-UCLA&quot; class=&quot;headerlink&quot; title=&quot;Review for Math 33 - Linear Algebra at UCLA&quot;&gt;&lt;/a&gt;Review for Math 33 - Linear Algebra at UCLA&lt;/h2&gt;</summary>
    
    
    
    <category term="Math" scheme="https://xuanhe95.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="https://xuanhe95.github.io/tags/Math/"/>
    
    <category term=" Linear Algebra" scheme="https://xuanhe95.github.io/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>26. Remove Duplicates from Sorted Array</title>
    <link href="https://xuanhe95.github.io/2022/11/11/26-Remove-Duplicates-from-Sorted-Array/"/>
    <id>https://xuanhe95.github.io/2022/11/11/26-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2022-11-11T20:32:03.000Z</published>
    <updated>2022-11-11T20:32:23.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p>Return <code>k</code>* after placing the final result in the first <em><code>k</code></em> slots of *<code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>由于数组本身已经排序，只要比较当前nums中的元素是否大于上一个保存的数值就可以决定是否保留。<br>创建一个k记录遍历的位置，每次比较nums[k]与nums[i]的位置元素的大小，如果当前的nums[i]大于nums[k]，则将k位置向后移动1，并将下一个位置记录为nums[i]。</p><p>最后返回k+1。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k] &lt; nums[i])&#123;</span><br><span class="line">                k++;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; sorte</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Easy" scheme="https://xuanhe95.github.io/categories/LeetCode/Easy/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="Array" scheme="https://xuanhe95.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Recursive Relation, LHRC, Honoi Tower</title>
    <link href="https://xuanhe95.github.io/2022/11/06/Recursive-Relation-LHRC-Honoi-Tower/"/>
    <id>https://xuanhe95.github.io/2022/11/06/Recursive-Relation-LHRC-Honoi-Tower/</id>
    <published>2022-11-07T00:37:49.000Z</published>
    <updated>2022-11-07T01:02:50.459Z</updated>
    
    <content type="html"><![CDATA[<p>Find <strong>closed formula</strong> for an.</p><ol><li>Iteration (Proof by Induction)</li><li>Linear homogeneous recursive relation with constant coefficiens (LHRC)<br>find the roots of equation t<sub>2</sub>+c<sub>1</sub>t+C<sub>2</sub><br>then where exist constants b, d such that a<sub>n</sub> &#x3D; br<sub>1</sub><sup>n</sup>+dr<sub>2</sub><sup>n</sup>, for n &gt;&#x3D; 0</li></ol><p>Recursive Relation, Honoi Tower, LHRC</p><iframe src="https://www.slideshare.net/slideshow/embed_code/key/GOe7gGuU9cKhsG?hostedIn=slideshare&page=upload" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe><iframe src="https://www.slideshare.net/ssuser3baeb8/61-week-4-notes-71pdf" style="width:100%;height:550px" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Find &lt;strong&gt;closed formula&lt;/strong&gt; for an.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Iteration (Proof by Induction)&lt;/li&gt;
&lt;li&gt;Linear homogeneous recursive relation w</summary>
      
    
    
    
    <category term="Course" scheme="https://xuanhe95.github.io/categories/Course/"/>
    
    <category term="Math" scheme="https://xuanhe95.github.io/categories/Course/Math/"/>
    
    
  </entry>
  
  <entry>
    <title>1578. Minimum Time to Make Rope Colorful</title>
    <link href="https://xuanhe95.github.io/2022/10/03/1578-Minimum-Time-to-Make-Rope-Colorful/"/>
    <id>https://xuanhe95.github.io/2022/10/03/1578-Minimum-Time-to-Make-Rope-Colorful/</id>
    <published>2022-10-03T23:59:07.000Z</published>
    <updated>2022-10-03T23:59:26.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>Alice has <code>n</code> balloons arranged on a rope. You are given a <strong>0-indexed</strong> string <code>colors</code> where <code>colors[i]</code> is the color of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> balloon.</p><p>Alice wants the rope to be <strong>colorful</strong>. She does not want <strong>two consecutive balloons</strong> to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it <strong>colorful</strong>. You are given a <strong>0-indexed</strong> integer array <code>neededTime</code> where <code>neededTime[i]</code> is the time (in seconds) that Bob needs to remove the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> balloon from the rope.</p><p>Return <em>the <strong>minimum time</strong> Bob needs to make the rope <strong>colorful</strong></em>.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>滑动窗口，遍历字符串。<br>common用来记录连续颜色相同的个数，初始化为1。<br>如果当前字符与下一个字符相同，则窗口向右侧扩展，common++。<br>遍历时记录替换气球需要的最大时间maxTime和替换掉所有同色气球的总时间deleteTime。</p><p>如果common大于1，则总时间加上需要删除的时间（刨除最大时间maxTime）。<br>更新i为i + common。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost</span><span class="params">(String colors, <span class="type">int</span>[] neededTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, totalTime = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] c = colors.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; neededTime.length)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">common</span> <span class="operator">=</span> <span class="number">1</span>, maxTime = neededTime[i], deleteTime = neededTime[i];</span><br><span class="line">            <span class="keyword">while</span>(i + common &lt; neededTime.length &amp;&amp; c[i] == c[i + common])&#123;</span><br><span class="line">                maxTime = Math.max(maxTime, neededTime[i + common]);</span><br><span class="line">                deleteTime += neededTime[i + common];</span><br><span class="line">                common++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(common &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                deleteTime -= maxTime;</span><br><span class="line">                totalTime += deleteTime;</span><br><span class="line">            &#125;</span><br><span class="line">            i += common;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h3&gt;&lt;p&gt;Alice has &lt;code&gt;n&lt;/code&gt; balloons arranged on a ro</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="滑动窗口" scheme="https://xuanhe95.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>609. Find Duplicate File in System</title>
    <link href="https://xuanhe95.github.io/2022/09/19/609-Find-Duplicate-File-in-System/"/>
    <id>https://xuanhe95.github.io/2022/09/19/609-Find-Duplicate-File-in-System/</id>
    <published>2022-09-19T20:37:22.000Z</published>
    <updated>2022-09-19T20:37:22.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given a list <code>paths</code> of directory info, including the directory path, and all the files with contents in this directory, return <em>all the duplicate files in the file system in terms of their paths</em>. You may return the answer in <strong>any order</strong>.</p><p>A group of duplicate files consists of at least two files that have the same content.</p><p>A single directory info string in the input list has the following format:</p><ul><li><code>&quot;root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)&quot;</code></li></ul><p>It means there are <code>n</code> files <code>(f1.txt, f2.txt ... fn.txt)</code> with content <code>(f1_content, f2_content ... fn_content)</code> respectively in the directory “<code>root/d1/d2/.../dm&quot;</code>. Note that <code>n &gt;= 1</code> and <code>m &gt;= 0</code>. If <code>m = 0</code>, it means the directory is just the root directory.</p><p>The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:</p><ul><li><code>&quot;directory_path/file_name.txt&quot;</code></li></ul><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>使用StringBuffer对字符串进行处理。<br>采用HashMap建立内容和对应列表的映射。</p><p>遍历处理字符串，并添加到map中。<br>最后遍历map，如果对应的列表size大于1，则加入结果。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findDuplicate</span><span class="params">(String[] paths)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String path : paths)&#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">folder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(path.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                folder.append(path.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; path.length())&#123;</span><br><span class="line">                <span class="keyword">while</span>(path.charAt(i) == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                <span class="keyword">while</span>(i &lt; path.length() &amp;&amp; path.charAt(i) != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    filename.append(path.charAt(i));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                <span class="keyword">while</span>(i &lt; path.length() &amp;&amp; path.charAt(i) != <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    content.append(path.charAt(i));</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                List&lt;String&gt; arr = map.getOrDefault(content.toString(), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">                arr.add(folder.toString() + <span class="string">&#x27;/&#x27;</span> + filename);</span><br><span class="line">                map.put(content.toString(), arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String content : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(content).size() &gt; <span class="number">1</span>) res.add(map.get(content));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;p&gt;Given a list &lt;code&gt;paths&lt;/code&gt; of directory i</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="String" scheme="https://xuanhe95.github.io/tags/String/"/>
    
    <category term="HashMap" scheme="https://xuanhe95.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>42. Trapping Rain Water</title>
    <link href="https://xuanhe95.github.io/2022/09/18/42-Trapping-Rain-Water/"/>
    <id>https://xuanhe95.github.io/2022/09/18/42-Trapping-Rain-Water/</id>
    <published>2022-09-18T08:17:09.000Z</published>
    <updated>2022-09-18T08:19:35.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>双指针，设置当前左侧的最大高度left和右侧的最大高度right。</p><p>分别从两侧遍历height[]数组，当出现更高的height时更新left和right。<br>否则记录left和right与height[i]的差值，并记录在数组waterLeft[]和waterRight[]中。</p><p>遍历两个数组，添加两者中的最小值到volume。</p><p>*由于单个参数只记录了一侧的最大值，因此最大值另一侧的水的体积会被多计算，因此分别从两侧遍历来获得最小值。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length, left = <span class="number">0</span>, right = <span class="number">0</span>, volume = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] waterLeft = <span class="keyword">new</span> <span class="title class_">int</span>[n], waterRight = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= height[i]) left = height[i];</span><br><span class="line">            <span class="keyword">else</span> waterLeft[i] = left - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right &lt;= height[i]) right = height[i];</span><br><span class="line">            <span class="keyword">else</span> waterRight[i] = right - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            volume += Math.min(waterLeft[i], waterRight[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> volume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;p&gt;Given &lt;code&gt;n&lt;/code&gt; non-negative integers rep</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Hard" scheme="https://xuanhe95.github.io/categories/LeetCode/Hard/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="双指针" scheme="https://xuanhe95.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="Eureka!" scheme="https://xuanhe95.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>1770. Max Score from Multiplication Operations</title>
    <link href="https://xuanhe95.github.io/2022/09/16/1770-Max-Score-from-Multiplication-Operations/"/>
    <id>https://xuanhe95.github.io/2022/09/16/1770-Max-Score-from-Multiplication-Operations/</id>
    <published>2022-09-16T09:19:34.000Z</published>
    <updated>2022-09-16T09:26:57.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>You are given two integer arrays <code>nums</code> and <code>multipliers</code>** **of size <code>n</code> and <code>m</code> respectively, where <code>n &gt;= m</code>. The arrays are <strong>1-indexed</strong>.</p><p>You begin with a score of <code>0</code>. You want to perform <strong>exactly</strong> <code>m</code> operations. On the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> operation <strong>(1-indexed)</strong>, you will:</p><ul><li>Choose one integer <code>x</code> from **either the start or the end **of the array <code>nums</code>.</li><li>Add <code>multipliers[i] * x</code> to your score.</li><li>Remove <code>x</code> from the array <code>nums</code>.</li></ul><p>Return *the <strong>maximum</strong> score after performing *<code>m</code> <em>operations.</em></p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>动态规划，dp[][]数组记录左边取的个数和右边取的个数。</p><p>从取1开始到取multipliers的长度位置开始遍历。<br>然后从left取0个开始，直到left取i个为止遍历。<br>计算对应的right指针位置。</p><p>注意访问数组时需要访问left和right的上一个位置。</p><p>如果left为0，则只能取右侧的上一个位置加上右侧的上一个数值乘以mul。<br>如果right为0，则只能取左侧的上一个位置加上左侧的上一个数值乘以mul。<br>否则取两者之间的最大值。</p><p>最后遍历数组中left + right和为m的位置，并返回最大值。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] multipliers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, m = multipliers.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mul</span> <span class="operator">=</span> multipliers[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt;= i; l++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i - l;</span><br><span class="line">                <span class="type">int</span> <span class="variable">iL</span> <span class="operator">=</span> l - <span class="number">1</span>, iR = n - r;</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">0</span>) dp[l][r] = dp[l][r-<span class="number">1</span>] + mul * nums[iR];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(r == <span class="number">0</span>) dp[l][r] = dp[l-<span class="number">1</span>][r] + mul * nums[iL];</span><br><span class="line">                <span class="keyword">else</span> dp[l][r] = Math.max(dp[l-<span class="number">1</span>][r] + mul * nums[iL], dp[l][r-<span class="number">1</span>] + mul * nums[iR]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l &lt;= m; l++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> m - l;</span><br><span class="line">            ans = Math.max(ans, dp[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;p&gt;You are given two integer arrays &lt;code&gt;nums&lt;/c</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    <category term="复习" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="DP" scheme="https://xuanhe95.github.io/tags/DP/"/>
    
    <category term="Eureka!" scheme="https://xuanhe95.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>1457. Pseudo-Palindromic Paths in a Binary Tree</title>
    <link href="https://xuanhe95.github.io/2022/09/14/1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/"/>
    <id>https://xuanhe95.github.io/2022/09/14/1457-Pseudo-Palindromic-Paths-in-a-Binary-Tree/</id>
    <published>2022-09-14T09:26:41.000Z</published>
    <updated>2022-09-14T09:45:48.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be <strong>pseudo-palindromic</strong> if at least one permutation of the node values in the path is a palindrome.</p><p><em>Return the number of <strong>pseudo-palindromic</strong> paths going from the root node to leaf nodes.</em></p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>用数组bin[]记录一个树枝上的节点。</p><p>回溯，遇到根节点则判断数组bin[]中是否只有0个或1个奇数的数字。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="type">int</span>[] bin;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pseudoPalindromicPaths</span> <span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        bin = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        backtrack(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            bin[root.val]++;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bin.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag &amp;&amp; (bin[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                    bin[root.val]--;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((bin[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">            bin[root.val]--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bin[root.val]++;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) backtrack(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) backtrack(root.right);</span><br><span class="line">        bin[root.val]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given a binary tree where node va</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="Binary Tree" scheme="https://xuanhe95.github.io/tags/Binary-Tree/"/>
    
    <category term="Backtracking" scheme="https://xuanhe95.github.io/tags/Backtracking/"/>
    
    <category term="DFS" scheme="https://xuanhe95.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>393. UTF-8 Validation</title>
    <link href="https://xuanhe95.github.io/2022/09/14/393-UTF-8-Validation/"/>
    <id>https://xuanhe95.github.io/2022/09/14/393-UTF-8-Validation/</id>
    <published>2022-09-14T08:56:02.000Z</published>
    <updated>2022-09-14T09:45:37.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given an integer array <code>data</code> representing the data, return whether it is a valid <strong>UTF-8</strong> encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).</p><p>A character in <strong>UTF8</strong> can be from <strong>1 to 4 bytes</strong> long, subjected to the following rules:</p><ol><li>For a <strong>1-byte</strong> character, the first bit is a <code>0</code>, followed by its Unicode code.</li><li>For an <strong>n-bytes</strong> character, the first <code>n</code> bits are all one’s, the <code>n + 1</code> bit is <code>0</code>, followed by <code>n - 1</code> bytes with the most significant <code>2</code> bits being <code>10</code>.</li></ol><p><code>x</code> denotes a bit in the binary form of a byte that may be either <code>0</code> or <code>1</code>.</p><p>**Note: **The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>位运算，循环更新UTF头部的位置start。<br>getByte()方法用来计算位数。<br>check()方法用来检查从start+1开始直到位数结束是否二进制位数以10开头。<br>isStartWith10()方法使用掩码判断二进制是否以10开头。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dt;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK</span> <span class="operator">=</span> <span class="number">0b11000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validUtf8</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        dt = data;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start &lt; data.length)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> getByte(start);</span><br><span class="line">            <span class="keyword">if</span>(bit == -<span class="number">1</span> || start + bit &gt; data.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!check(start, bit)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start += bit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getByte</span><span class="params">(<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((dt[start] &amp; <span class="number">1</span>) == <span class="number">0</span>) bit = <span class="number">7</span> - i;</span><br><span class="line">            dt[start] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bit == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> || bit &gt; <span class="number">4</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> bit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> bit)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">1</span>; i &lt; start + bit; i++) <span class="keyword">if</span>(!isStartWith10(dt[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isStartWith10</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; MASK) == <span class="number">0b10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given an integer array &lt;code&gt;data</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="位运算" scheme="https://xuanhe95.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>1383. Maximum Performance of a Team</title>
    <link href="https://xuanhe95.github.io/2022/09/11/1383-Maximum-Performance-of-a-Team/"/>
    <id>https://xuanhe95.github.io/2022/09/11/1383-Maximum-Performance-of-a-Team/</id>
    <published>2022-09-11T20:40:33.000Z</published>
    <updated>2022-09-11T20:40:50.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>You are given two integers <code>n</code> and <code>k</code> and two integer arrays <code>speed</code> and <code>efficiency</code> both of length <code>n</code>. There are <code>n</code> engineers numbered from <code>1</code> to <code>n</code>. <code>speed[i]</code> and <code>efficiency[i]</code> represent the speed and efficiency of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> engineer respectively.</p><p>Choose <strong>at most</strong> <code>k</code> different engineers out of the <code>n</code> engineers to form a team with the maximum <strong>performance</strong>.</p><p>The performance of a team is the sum of their engineers’ speeds multiplied by the minimum efficiency among their engineers.</p><p>Return <em>the maximum performance of this team</em>. Since the answer can be a huge number, return it <strong>modulo</strong> <code>10&lt;sup&gt;9&lt;/sup&gt;&lt;span&gt; &lt;/span&gt;+ 7</code>.</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>排序，将所有工程师根据其效率降序排列。</p><p>此时遍历时后一个工程师的效率一定小于等于前一个工程师。</p><p>因此，此时遍历到每一个工程师，其前面所有的工程师的efficiency均大于等于其本身。<br>维护一个所有选取工程师的总速度ttSpd，每次计算并更新max的值。<br>用最小堆来维护选取的工程师速度，如果优先级队列的尺寸超过k-1，则poll掉队列内最低的速度。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPerformance</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] speed, <span class="type">int</span>[] efficiency, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>, <span class="number">9</span>) + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span>[][] engineer = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            engineer[i][<span class="number">0</span>] = speed[i];</span><br><span class="line">            engineer[i][<span class="number">1</span>] = efficiency[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(engineer, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, ttSpd = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> engineer[i][<span class="number">0</span>], e = engineer[i][<span class="number">1</span>];</span><br><span class="line">            ttSpd += s;</span><br><span class="line">            max = Math.max(max, ttSpd * e);</span><br><span class="line">            pq.add(s);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() == k) ttSpd -= pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (max % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;You are given two integers &lt;code&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Hard" scheme="https://xuanhe95.github.io/categories/LeetCode/Hard/"/>
    
    <category term="复习" scheme="https://xuanhe95.github.io/categories/LeetCode/Hard/%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="Sort" scheme="https://xuanhe95.github.io/tags/Sort/"/>
    
    <category term="Eureka!" scheme="https://xuanhe95.github.io/tags/Eureka/"/>
    
    <category term="双参数" scheme="https://xuanhe95.github.io/tags/%E5%8F%8C%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>1996. The Number of Weak Characters in the Game</title>
    <link href="https://xuanhe95.github.io/2022/09/11/1996-The-Number-of-Weak-Characters-in-the-Game/"/>
    <id>https://xuanhe95.github.io/2022/09/11/1996-The-Number-of-Weak-Characters-in-the-Game/</id>
    <published>2022-09-11T20:06:48.000Z</published>
    <updated>2022-09-11T20:09:24.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>You are playing a game that contains multiple characters, and each of the characters has <strong>two</strong> main properties: <strong>attack</strong> and <strong>defense</strong>. You are given a 2D integer array <code>properties</code> where <code>properties[i] = [attack&lt;sub&gt;i&lt;/sub&gt;, defense&lt;sub&gt;i&lt;/sub&gt;]</code> represents the properties of the <code>i&lt;sup&gt;th&lt;/sup&gt;</code> character in the game.</p><p>A character is said to be <strong>weak</strong> if any other character has <strong>both</strong> attack and defense levels <strong>strictly greater</strong> than this character’s attack and defense levels. More formally, a character <code>i</code> is said to be <strong>weak</strong> if there exists another character <code>j</code> where <code>attack&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;&gt; attack&lt;sub&gt;i&lt;/sub&gt;</code> and <code>defense&lt;sub&gt;j&lt;/sub&gt;&lt;span&gt; &lt;/span&gt;&gt; defense&lt;sub&gt;i&lt;/sub&gt;</code>.</p><p>Return <em>the number of <strong>weak</strong> characters</em>.</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>本题与<a href="https://xuanhe95.github.io/2022/05/25/354-Russian-Doll-Envelopes/">354. Russian Doll Envelopes</a>相近。</p><p>首先对数组进行排序，根据角色的attack数值<strong>降序</strong>排序，如果两者的attack数值相等，则根据两者的defence<strong>升序</strong>排序。</p><p>记录一个遍历过的最大defence数值maxDefence，遍历数组，如果当前maxDef大于角色的防御值，则此时当前遍历角色的attack与defence均严格小于上一个计算的角色，因此count加一。<br>否则更新maxDef。</p><p>*由于attack是降序的，因此可以确定遍历时下一组数组的attack一定更弱。（由于相同attack的角色是根据defence升序排列，因此记录maxDef时会逐个更新maxDef的值。）</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfWeakCharacters</span><span class="params">(<span class="type">int</span>[][] properties)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, maxDef = Integer.MIN_VALUE;</span><br><span class="line">            </span><br><span class="line">        Arrays.sort(properties, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] character : properties)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxDef &gt; character[<span class="number">1</span>]) count++;</span><br><span class="line">            <span class="keyword">else</span> maxDef = character[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;You are playing a game that conta</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    <category term="复习" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/%E5%A4%8D%E4%B9%A0/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="Sort" scheme="https://xuanhe95.github.io/tags/Sort/"/>
    
    <category term="双参量" scheme="https://xuanhe95.github.io/tags/%E5%8F%8C%E5%8F%82%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>606. Construct String from Binary Tree</title>
    <link href="https://xuanhe95.github.io/2022/09/06/606-Construct-String-from-Binary-Tree/"/>
    <id>https://xuanhe95.github.io/2022/09/06/606-Construct-String-from-Binary-Tree/</id>
    <published>2022-09-07T06:00:42.000Z</published>
    <updated>2022-09-07T06:01:02.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given the <code>root</code> of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.</p><p>Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>DFS搜索，先序遍历到每个节点将其加入StringBuffer。<br>如果当前节点有左子节点或右子节点，则递归左子节点，并在前后添加一对括号。（如果有右子节点的情况即使左子节点为空也需要添加一对括号加以区别。）<br>如果当前节点有右子节点，则递归右子节点，并在前后添加一对括号。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    StringBuffer sb;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        sb = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasLeft</span> <span class="operator">=</span> root.left != <span class="literal">null</span>, hasRight = root.right != <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hasLeft || hasRight) sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(hasLeft || hasRight) sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hasRight) sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="keyword">if</span>(hasRight) sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a </summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Easy" scheme="https://xuanhe95.github.io/categories/LeetCode/Easy/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="Binary Tree" scheme="https://xuanhe95.github.io/tags/Binary-Tree/"/>
    
    <category term="DFS" scheme="https://xuanhe95.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>814. Binary Tree Pruning</title>
    <link href="https://xuanhe95.github.io/2022/09/06/814-Binary-Tree-Pruning/"/>
    <id>https://xuanhe95.github.io/2022/09/06/814-Binary-Tree-Pruning/</id>
    <published>2022-09-06T07:02:45.000Z</published>
    <updated>2022-09-06T08:40:51.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote><p>Given the <code>root</code> of a binary tree, return <em>the same tree where every subtree (of the given tree) not containing a <em><code>1</code></em> has been removed</em>.</p><p>A subtree of a node <code>node</code> is <code>node</code> plus every node that is a descendant of <code>node</code>.</p></blockquote><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>DFS搜索，首先递归两个子节点。<br>在搜索时如果节点为0且两个子节点均为null，则返回null。否则返回节点本身。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h3><p>DFS搜索，返回子节点和自己中是否包含1。<br>如果节点为null，则返回false。<br>如果自己为1，则返回true。<br>否则返回两个子节点中是否有true。</p><p>BFS搜索，根据每个节点的子节点是否包含1来决定左右子节点是否保存。<br>如果没有1，则将对应的子节点修改为null。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasOne(root)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span>(hasOne(curr.left)) q.add(curr.left);</span><br><span class="line">            <span class="keyword">else</span> curr.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(hasOne(curr.right)) q.add(curr.right);</span><br><span class="line">            <span class="keyword">else</span> curr.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasOne</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> hasOne(root.left) || hasOne(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Given the &lt;code&gt;root&lt;/code&gt; of a </summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xuanhe95.github.io/categories/LeetCode/"/>
    
    <category term="Medium" scheme="https://xuanhe95.github.io/categories/LeetCode/Medium/"/>
    
    
    <category term="每日一题" scheme="https://xuanhe95.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    <category term="Binary Tree" scheme="https://xuanhe95.github.io/tags/Binary-Tree/"/>
    
    <category term="BFS" scheme="https://xuanhe95.github.io/tags/BFS/"/>
    
    <category term="DFS" scheme="https://xuanhe95.github.io/tags/DFS/"/>
    
  </entry>
  
</feed>
